# Doxygen main page

## Описание проекта

Учебный проект школы 21.<br>
В данном проекте я реализовал игру «Тетрис» на 'C'.

### Общая информация

BrickGame — популярная портативная консоль 90-ых годов с несколькими ~~тысячами~~ встроенными играми, разработанная в Китае. Изначально была копией разработанной в СССР и выпущенной Nintendo в рамках платформы GameBoy игры «Тетрис», но включала в себя также и множество других игр, которые добавлялись с течением времени. Консоль имела небольшой экранчик с игровым полем размера 10х20, представляющим из себя матрицу «пикселей». Справа от поля находилось табло с цифровой индикацией состояния текущей игры, рекордами и прочей дополнительной информацией. Самыми распространенными играми на BrickGame были: тетрис, танки, гонки, фроггер и змейка.

<img src="original_tetris.png" alt="Оригинальный тетрис" width="500">

*так выглядел оригинальный тетрис.*

Что-бы максимально подойти к оригинальной игре, была реализована стилизация отображения поля игры и фигур.

<img src="my_tetris.png" alt="Оригинальный тетрис" width="500">

## Требования к проекту

### Часть 1. Основное задание

Тебе необходимо реализовать программу BrickGame v1.0 aka Tetris:

- Программа должна быть разработана на языке С стандарта C11 с использованием компилятора gcc.
- Программа должна состоять из двух частей: библиотеки, реализующей логику игры тетрис, и терминального интерфейса с использованием библиотеки `ncurses`.
- Для формализации логики игры должен быть использован конечный автомат.
- Библиотека должна иметь функцию, принимающую на вход ввод пользователя, и функцию, выдающую матрицу, которая описывает текущее состояние игрового поля при каждом ее изменении.
- Код библиотеки программы должен находиться в папке `src/brick_game/tetris`.
- Код с интерфейсом программы должен находиться в папке `src/gui/cli`.
- Сборка программы должна быть настроена с помощью Makefile со стандартным набором целей для GNU-программ: all, install, uninstall, clean, dvi, dist, test, gcov_report. Установка должна вестись в любой другой произвольный каталог.
- Программа должна быть разработана в соответствии с принципами структурного программирования.
- При написании кода придерживайся Google Style.
- Должно быть обеспечено покрытие библиотеки unit-тестами с помощью библиотеки `check` (тесты должны проходить на ОС Darwin/Ubuntu). Покрытие библиотеки с логикой игры тестами должно составлять не меньше 80 процентов.
- В игре должны присутствовать следующие механики:
  - Вращение фигур;
  - Перемещение фигуры по горизонтали;
  - Ускорение падения фигуры (при нажатии кнопки фигура перемещается до конца вниз);
  - Показ следующей фигуры;
  - Уничтожение заполненных линий;
  - Завершение игры при достижении верхней границы игрового поля;
  - В игре должны присутствовать все виды фигур, показанные на картинке ниже.
- Для управления добавь поддержку всех кнопок, предусмотренных на физической консоли:
  - Начало игры,
  - Пауза,
  - Завершение игры,
  - Стрелка влево — движение фигуры влево,
  - Стрелка вправо — движение фигуры вправо,
  - Стрелка вниз — падение фигуры,
  - Стрелка вверх — не используется в данной игре,
  - Действие (вращение фигуры).
- Игровое поле должно соответствовать размерам игрового поля консоли: десять «пикселей» в ширину и двадцать «пикселей» в высоту.
- Фигура после достижения нижней границы поля или соприкосновения с другой фигурой должна остановиться. Вслед за этим происходит генерация следующей фигуры, показанной на превью.
- Интерфейс библиотеки должен соответствовать описанию, которое находится в materials/library-specification_RUS.md.
- Пользовательский интерфейс должен поддерживать отрисовку игрового поля и дополнительной информации.
- Подготовь в любом формате диаграмму, описывающую используемый КА (его состояния и все возможные переходы).

<img src="diagram.png" alt="Диаграмма" width="500">

Используемые фигуры:

<img src="tetris-pieces.png" alt="Оригинальный тетрис" width="500">

### Часть 2. Дополнительно. Подсчет очков и рекорд в игре

Добавь в игру следующие механики:

- подсчет очков;
- хранение максимального количества очков.

Данная информация должна передаваться и выводиться пользовательским интерфейсом в боковой панели. Максимальное количество очков должно храниться в файле или встраиваемой СУБД и сохраняться между запусками программы.

Максимальное количество очков должно изменяться во время игры, если пользователь превышает текущий показатель максимального количества очков во время игры.

Начисление очков будет происходить следующим образом:

- 1 линия — 100 очков;
- 2 линии — 300 очков;
- 3 линии — 700 очков;
- 4 линии — 1500 очков.

### Часть 3. Дополнительно. Механика уровней

Добавь в игру механику уровней. Каждый раз, когда игрок набирает 600 очков, уровень увеличивается на 1. Повышение уровня увеличивает скорость движения фигур. Максимальное количество уровней — 10.

## Спецификация для библиотеки игры из коллекции игр BrickGame

Это задание является первым из серии BrickGame. Всего будет четыре проекта, в каждой - своя игра и свои технологии. Но помимо разработки новых проектов, необходимо будет поддерживать и старые игры, и добавлять поддержку новых игр в старые проекты. В этот раз интерфейс будет консольным, в следующем - десктопный, и так далее. Для того чтобы поддерживать старые и новые игры необходимо заранее определиться как будет устроено АПИ интерфейсов и библиотек, чтобы в дальнейшем не приходилось переписывать уже сданные проекты.

Игровое поле представляется как матрица размерностью десять на двадцать. Каждый элемент матрицы соответствует "пикселю" игрового поля и может находится в одном из двух состояний: пустой и заполненный. Кроме игрового поля у каждой игры есть дополнительная информация, которая выводится в боковой панели справа от игрового поля. Для дополнительной информации, не используемой во время игры, предусмотреть заглушки.

Каждая библиотека с игрой должна иметь функцию, принимающую на вход пользовательский ввод. У консоли имеется восемь физических кнопок: начало игры, пауза, завершение игры, действие и четыре стрелочки.

Функция `userInput` принимает на вход пользовательское действие `action` и дополнительный параметр `hold`, который отвечает за зажатие клавиши.

Функция `updateCurrentState` предназначена для получения данных для отрисовки в интерфейсе. Она возвращает структуру, содержащую информацию о текущем состоянии игры. Например, для тетриса истечение таймера приводит к смещению фигуры вниз на один ряд. Эта функция должна вызываться из интерфейса с некоторой периодичностью для поддержания интерфейса в актуальном состоянии.

```c
typedef enum {
    Start,
    Pause,
    Terminate,
    Left,
    Right,
    Up,
    Down,
    Action
} UserAction_t;

typedef struct {
    int **field;
    int **next;
    int score;
    int high_score;
    int level;
    int speed;
    int pause;
} GameInfo_t;

void userInput(UserAction_t action, bool hold);

GameInfo_t updateCurrentState();
```

## Инструкция по запуску тестов

Помимо тестов на корректные выходные данные система автотестирования будет проверять вашу программу и ее исходный код по следующим пунктам:

### Стилевые тесты

Чтобы проверить, насколько красота вашего кода соответствует стандартам, вы можете протестировать ваш код с помощью утилиты *clang-format*. В папке ```materials/linters``` лежит файл ```.clang-format```, который содержит необходимые настройки для стилевого теста.

Данный конфигурационный файл распространяет свое действие на все файлы, которые лежат с ним в директории или в директориях ниже. Поэтому, чтобы данные настройки применились к вашим файлам с исходным кодом, скопируйте ```.clang-format``` в папку ```src```.<br>
Чтобы запустить проверку на стиль, выполните следующую команду:

```sh
clang-format -n src/sourcefile_name.c
```

Чтобы скачать *clang-format*, введите в терминал одну из следующих команд:

```sh
brew install clang-format
```

или, если у вас есть root-права (для Ubuntu / Linux Mint / Debian)

```sh
sudo apt install clang-format
```

Необходимая версия clang-format:<br>
**Mac** 14.0.5<br>
**Linux** 13.0.1

[Google Style](https://google.github.io/styleguide/cppguide.html)

### Тест на корректную работу с памятью

При написании C-программ очень важно следить за утечками памяти. Для этого в Unix-подобных операционных системах довольно часто используют утилиту *valgrind*. Однако, на OS X имеются проблемы с   поддержкой *valgrind*, поэтому вместо нее можно использовать утилиту *leaks*. Вдаваться в механизм работы этих утилит мы сейчас не будем — если интересно, можете почитать в гугле.

#### LEAKS

Чтобы запустить ваш исполняемый файл с помощью этой утилиты, наберите в терминале:<br>

```sh
leaks -atExit -- ./main.out | grep LEAK:
```

Обратите внимание на команду

```sh
| grep LEAK:
```

Мы используем ее для короткого вывода, чтобы видеть только линии с утечками, если они есть. Если вы хотите увидеть весь вывод, просто удалите эту команду.

При запуске исполняемого файла с помощью *leaks* может появиться сообщение об ошибке:

> dyld: could not load inserted library ‘/usr/local/lib/libLeaksAtExit.dylib’ because image not found

Ошибка возникает из-за того, что *leaks* не может найти библиотеку *libLeaksAtExit.dylib*.<br>
В этом случае вам необходимо ввести следующие команды:

```sh
cd /usr/local/lib  
sudo ln -s /Applications/Xcode.app/Contents/Developer/usr/lib/libLeaksAtExit.dylib
```

**Дополнительно:**

Используйте флаг ```-exclude``` утилиты *leaks* для того, чтобы отфильтровать утечки в функциях, где известно об утечках памяти. Этот флаг позволяет уменьшить количество посторонней информации, сообщаемой *leaks*.

#### VALGRIND

Чтобы установить *valgrind* на компьютер, введите одну из следующих команд:<br>

```sh
brew install valgrind
```

или, если у вас есть root-права (для Ubuntu / Linux Mint / Debian)

```sh
sudo apt install valgrind
```

Чтобы запустить ваш исполняемый файл с помощью этой утилиты, наберите в терминале:<br>

```sh
valgrind --tool=memcheck --leak-check=yes  ./main.out
```

Не рекомендуется использовать *valgrind* на OS X, вместо нее лучше использовать *leaks*.

### Тест сборки

Программу можно проверить на корректность сборки на тестовой системе. Для этого потребуется установленный *Docker*. Если на системе есть докер, то можно зайти в директорию `materials/build` и запустить оттуда скрипт run.sh. Скрипт обернет ваше решение в докер и запустит его вместе с типовым сценарием сборки.

## Содержание

- [Описание проекта](#описание-проекта)
  - [Общая информация](#общая-информация)
- [Требования к проекту](#требования-к-проекту)
  - [Часть 1. Основное задание](#часть-1-основное-задание)
  - [Часть 2. Дополнительно. Подсчет очков и рекорд в игре](#часть-2-дополнительно-подсчет-очков-и-рекорд-в-игре)
  - [Часть 3. Дополнительно. Механика уровней](#часть-3-дополнительно-механика-уровней)
- [Спецификация для библиотеки игры из коллекции игр BrickGame](#спецификация-для-библиотеки-игры-из-коллекции-игр-brickgame)
- [Инструкция по запуску тестов](#инструкция-по-запуску-тестов)
  - [Стилевые тесты](#стилевые-тесты)
  - [Тест на корректную работу с памятью](#тест-на-корректную-работу-с-памятью)
  - [Тест сборки](#тест-сборки)
