# Введение в программирование с curses

Авторы: Eric S. Raymond и Zeyd M. Ben-Halim [Источник](http://grep.cs.msu.ru/ncurses.html#introduction)

## Содержание

+ [Введение](#введение)
+ [Краткая история Curses](#краткая-история-curses)
+ [Цель этого документа](#цель-этого-документа)
+ [Терминология](#терминология)
+ [<Библиотека Curses](#библиотека-curses)
  + [Краткий обзор Curses](#краткий-обзор-curses)
    + [Компиляция программ, использующих Curses](#компиляция-программ-использующих-curses)
    + [Обновление экрана](#обновление-экрана)
    + [Стандартные окна и соглашения об именах функций](#стандартные-окна-и-соглашения-об-именах-функций)
    + [Переменные](#переменные)
  + [Использование библиотеки](#использование-библиотеки)
    + [Запуск](#запуск)
    + [Вывод](#вывод)
    + [Ввод](#ввод)
    + [Использование символов псевдографики](#использование-символов-псевдографики)
    + [Атрибуты и цвет символа](#атрибуты-и-цвет-символа)
    + [Работа с мышью](#работа-с-мышью)
    + [Завершение](#завершение)
  + [Описания функций](#описания-функций)
    + [Инициализация и завершение](#инициализация-и-завершение)
      + [initscr()](#initscr)
      + [endwin()](#endwin)
      + [newterm(type, ofp, ifp)](#newtermtype-ofp-ifp)
      + [set_term(new)](#set_termnew)
      + [delscreen(sp)](#delscreensp)
    + [Процесс вывода на терминал](#процесс-вывода-на-терминал)
      + [refresh() и wrefresh(win)](#refresh-и-wrefreshwin)
      + [doupdate() и wnoutrefresh(win)](#doupdate-и-wnoutrefreshwin)
    + [Возможности низкоуровневого доступа](#возможности-низкоуровневого-доступа)
      + [setupterm(term, filenum, errret)](#setuptermterm-filenum-errret)
    + [Отладка](#отладка)
      + [trace()](#trace)
      + [_tracef()](#_tracef)
    + [Подсказки, советы и трюки](#подсказки-советы-и-трюки)
      + [Некоторые предостерегающие замечания](#некоторые-предостерегающие-замечания)
      + [Временный выход из режима ncurses](#временный-выход-из-режима-ncurses)
      + [Использование ncurses в xterm](#использование-ncurses-в-xterm)
      + [Обработка нескольких терминальных экранов](#обработка-нескольких-терминальных-экранов)
      + [Проверка возможностей терминала](#проверка-возможностей-терминала)
      + [Настройка скорости](#настройка-скорости)
      + [Специальные свойства ncurses](#специальные-свойства-ncurses)
    + [Совместимость со старыми версиями](#совместимость-со-старыми-версиями)
      + [Регенерация перекрывающихся окон](#регенерация-перекрывающихся-окон)
      + [Заполнение при стирании](#заполнение-при-стирании)
      + [Соответствие XSI Curses](#соответствие-xsi-curses)
  + [Библиотека панелей](#библиотека-панелей)
+ [Компиляция программ, использующих библиотеку панелей]()
+ [Краткий обзор панелей]()
+ [Панели, ввод и стандартный экран]()
+ [Сокрытие панелей]()
+ [Другие различные возможности]()
+ [Библиотека меню]()
+ [Компиляция с библиотекой меню]()
+ [Краткий обзор меню]()
+ [Выбор элементов]()
+ [Отображение меню]()
+ [Окна меню]()
+ [Обработка ввода в меню]()
+ [Другие различные возможности]()
+ [Библиотека форм]()
+ [Компиляция с библиотекой форм]()
+ [Краткий обзор форм]()
+ [Создание и удаление полей и форм]()
+ [Получение и изменение атрибутов поля]()
+ [Получение данных о размере и расположении]()
+ [Изменение расположения поля]()
+ [Атрибуты выравнивания]()
+ [Атрибуты отображения поля]()
+ [Биты опций поля]()
+ [Статус поля]()
+ [Пользовательский указатель поля]()
+ [Поля с изменяемым размером]()
+ [Правильность заполнения поля]()
+ [TYPE_ALPHA]()
+ [TYPE_ALNUM]()
+ [TYPE_ENUM]()
+ [TYPE_INTEGER]()
+ [TYPE_NUMERIC]()
+ [TYPE_REGEXP]()
+ [Прямая работа с буфером поля]()
+ [Атрибуты формы]()
+ [Управление отображением формы]()
+ [Обработка ввода в драйвере формы]()
+ [Запросы перемещения страниц]()
+ [Запросы перемещения между полями]()
+ [Запросы перемещения внутри поля]()
+ [Запросы прокрутки]()
+ [Запросы редактирования]()
+ [Запросы упорядочивания]()
+ [Команды приложения]()
+ [Изменение обработчиков полей]()
+ [Команды смены поля]()
+ [Опции формы]()
+ [Правильность типов, определяемая пользователем]()
+ [Объединение типов]()
+ [Новые типы полей]()
+ [Аргументы функции проверки данных]()
+ [Функции упорядочивания для пользовательских типов]()
+ [Как избежать проблем]()

## Введение

Этот документ является введением в программирование с `curses`. Это не исчерпывающий справочник по Интерфейсу Прикладных Программ(API) для `curses`; эту роль играют **man** страницы `curses`. Скорее, его цель - облегчить понимание пакета программистам на C.

Этот документ предназначен для программистов на C, которые еще плохо знакомы с `ncurses`. Если ты уже имел опыт программирования с curses, тем не менее должен прочитать разделы Работа с мышью, Отладка, Совместимость со старыми версиями, и Подсказки, советы и трюки.

<!-- TODO -->

Они помогут тебе увеличить скорость приложений за счет специальных возможностей и особенностей реализации ncurses. Если ты не так опытен, то продолжай читать.

Пакет curses - библиотека подпрограмм для терминально-независимого вывода на экран и обработки входящих событий, которая для программиста представляет собой высокоуровневую модель представления экрана, скрывающую различия между типами терминалов и выполняющую автоматическую оптимизацию вывода при замене одного заполненного текстом экрана на другой. `Curses` использует **terminfo** - формат базы данных, которым можно описать возможности тысячи различных терминалов.

`curses API` может показаться неким архаизмом на UNIX терминалах при возрастающем преобладании X, Motif, и Tcl/Tk. Тем не менее, UNIX еще поддерживает линии tty и X-ы поддерживают xterm(1); `curses API` имеет преимущества:

+ (а) обратная портируемость на текстовые терминалы, и
+ (б) простота.

Для приложений, в которых не требуется растровой графики и разных шрифтов, реализация интерфейса с помощью curses обычно проще и дешевле, чем использование одного X toolkit.

---
[Содержание](#содержание)

## Краткая история Curses

Исторически, первым предком `curses` были процедуры, написанные для обеспечения работы с экраном в игре **rogue**; они использовали параметры уже существующей базы данных **termcap** описаний возможностей терминалов. Эти процедуры были сложены в документированную библиотеку и впервые появились в ранних версиях BSD UNIX.

В System III UNIX от Bell Labs свойства были переписаны и намного улучшена сама библиотека `curses`. В ней был представлен формат **terminfo**. 

**Terminfo** основывается на базе данных `Berkeley termcap`, но содержит несколько улучшений и расширений. Были представлены параметризованные возможности строк, стало возможным описать различные видео атрибуты и цвета, и она стала работать с намного большим количеством терминалов, чем это было возможно с `termcap`. 

Позднее в выпусках AT&T System V, `curses` развила использование большинства свойств и предоставила большие возможности, оставив далеко позади BSD curses по мощности и гибкости.

---
[Содержание](#содержание)

## Цель этого документа

Этот документ описывает `ncurses`, свободную реализацию **System V curses API** с некоторыми ясно описываемыми расширениями. Она включает в себя следующие свойства System V curses:

+ Поддержку различных выделений светом на экране (BSD curses могла работать только с одним световым `выделением', обычно инверсией цвета).
+ Поддержку рисования линий и прямоугольников с помощью символов псевдографики.
+ Распознавание ввода функциональных клавиш.
+ Поддержку цвета.
+ Поддержку pads (окон, больших чем размер экрана, для которых экран или подокно определены как область вывода).

Также, этот пакет позволяет использовать вставку и удаление строк и свойства символов терминалов, и определяет как оптимально использовать эти свойства без помощи программиста.

Он также позволяет отображать произвольные комбинации видео атрибутов, даже на терминалах, которые оставляют ``magic cookies'' на экране, когда происходят изменения в атрибутах.

Пакет `ncurses` может также перехватывать и использовать сообщения от мыши в некоторых средах (xterm в системе X window). Этот документ включает советы по использованию мыши.

Пакет `ncurses` создал **Pavel Curtis**. Первоначальный ведущий пакета [Zeyd Ben-Halim](zmbenhal@netcom.com).

[Eric S. Raymond](esr@snark.thyrsus.com) написал много новых свойств, которые вошли в версии больше 1.8.1 и написал большую часть введения. [Juergen Pfeifer](Juergen.Pfeifer@T-Online.de) написал целиком код меню и форм и связующий код [Ada95](http://www.adahome.com/).

Дальнейшая работа была выполнена [Thomas Dickey](dickey@clark.net) и [Juergen Pfeifer](Juergen.Pfeifer@T-Online.de).

[Florian La Roche](florian@gnu.org) выступает в роли ведущего для Free Software Foundation, у которого авторское право на ncurses. Связаться с текущими ведущими можно написав по [адресу](bug-ncurses@gnu.org).

В этом документе также описана библиотека расширений панелей,

<!-- TODO -->

имеющая свойства, подобные панелям в SVr4. Эта библиотека обеспечивает хранилище окон, связанное со стеком, или поверхность из перекрывающихся окон, и обеспечивает выполнение операций по перемещению окон по стеку, что меняет их видимость в естественном порядке (обрабатывая перекрывающиеся окна).

И наконец, этот документ подробно описывает библиотеки расширений меню и форм, также аналогичные System V, которые поддерживают легкое создание иерархических меню и заполнение форм.

<!-- TODO -->

---
[Содержание](#содержание)

## Терминология

В этом документе в разумных пределах была использована следующая терминология:

**Окно** - Структура данных, описывающая прямоугольную часть экрана (возможно весь экран). Ты можешь писать в окно как в миниатюрный экранчик, прокручивать его содержимое независимо от других окон на физическом экране.

**Экраны** - Поднабор окон, которые размером с экран терминала, т.е., они начинаются в верхнем левом углу и заканчиваются в нижнем правом углу. Один из них, stdscr, автоматически создается без программиста.

**Экран терминала** - Идея пакета состоит в том, чтобы дисплей терминала выглядел как на самом деле, т.е., чтобы пользователь видел что происходит прямо сейчас. Это специальный экран.

---
[Содержание](#содержание)

## Библиотека Curses

### Краткий обзор Curses

#### Компиляция программ, использующих Curses

Чтобы использовать библиотеку, необходимо иметь определенными некоторые типы и переменные. Поэтому, программист должен иметь строку:

```cpp
#include <curses.h>
```

в начале исходного кода программы.

Экранный пакет использует стандартную I/O библиотеку(ввода/вывода), поэтому `<curses.h>` включает `<stdio.h>`. `<curses.h>` в зависимости от твоей системы также включает `<termios.h>`, `<termio.h>`, или `<sgtty.h>`.

Для программиста излишне (но безопасно) еще раз включать эти строки. При линковке с `curses` тебе нужно иметь `-lncurses` в `LDFLAGS` или в командной строке. Нет необходимости в любых других библиотеках.

---
[Содержание](#содержание)

#### Обновление экрана

Чтобы оптимально обновлять экран, необходимы процедуры, которым нужно знать как выглядит экран в данный момент и что хочет программист чтобы на нем было в следующий момент.

Для этой цели определяется тип данных (структура) называемый `WINDOW`, который описывает изображение окна для программы, включая начальную позицию на экране (координаты (y, x), левого верхнего угла) и его размер.

Один из них (называемый `curscr`, текущий экран) это образ экрана, который в настоящий момент отображается на терминале. Другой экран (называемый `stdscr`, стандартный экран) - на нем по умолчанию делаются все изменения.

**Окно** - исключительно для внутреннего представления. Оно используется для построения и хранения возможного изображения части терминала. Оно ничего не знает относительно реального экрана терминала; оно больше похоже на `scratchpad` или буфер записи.

Чтобы часть физического экрана, связанная с окном, отразила содержимое структуры окна, вызывается процедура `refresh()` (или `wrefresh()`, если окно не `stdscr`).

Любая часть физического экрана может состоять из любого числа перекрывающихся окон. Также, изменения могут быть сделаны в окнах в любом порядке, без оглядки на то, как это отразится на эффективности. После этого, программист может эффектно сказать ``сделай чтобы выглядело так'', и дать реализации пакета определить наиболее эффективный путь перерисовки экрана.

---
[Содержание](#содержание)

#### Стандартные окна и соглашения об именах функций

Как отмечалось выше, программы могут использовать несколько окон, и еще два окна создаются автоматически: `curscr`, которое знает что на терминале в данный момент, и `stdscr`, которое отображает, что хочет получить программист на терминале в следующий момент.

Пользователь никогда не должен иметь прямого доступа к `curscr`.

Изменения должны делаться через API, а затем вызываться процедура `refresh()` (или `wrefresh()`).

Для многих функций определено использование `stdscr` как экрана по умолчанию.

Например, чтобы добавить символ на `stdscr`, нужен один вызов `addch()` с желаемым символов в качестве аргумента. Для записи в другое окно используется процедура `waddch()` (`w` - оконно-зависимая `addch()`).

Это соглашение применимо ко всем функциям с именами, начинающимися с "`w`", когда они должны применяться к определенным окнам. Этому правилу не подчиняются процедуры, для которых окно должно всегда указываться.

Для изменения текущих координат (y, x) используются процедуры `move()` и `wmove()`.

Однако, часто после изменения желательно выполнить какую-нибудь I/O операцию. Чтобы избежать неуклюжести кода большинство I/O процедур могут предваряться префиксом '`mv`' и желаемые (y, x) координаты указываться раньше других аргументов функций. Например, вызовы

```cpp
move(y, x);
addch(ch);
```

можно заменить на

```cpp
mvaddch(y, x, ch);
```

и

```cpp
wmove(win, y, x);
waddch(win, ch);
```

можно заменить на

```cpp
mvwaddch(win, y, x, ch);
```

Обратите внимание, что указатель на описатель окна (win) стоит перед добавляемыми (y, x) координатами. В функции необходимый указатель окна передается всегда первым параметром.

---
[Содержание](#содержание)

#### Переменные

Библиотека `curses` устанавливает некоторые переменные, описывающие возможности терминала.

тип | название | Описание
--- | -------- | ---
int | LINES    | число строк в терминале
int | COLS     | число столбцов в терминале

`curses.h` также вводит некоторые `#define` константы и типы, полезные всем:

+ `bool` - логический тип, на самом деле `char` (например, bool doneit;)
+ `TRUE` - флаг логической `правды' (1).
+ `FALSE` - флаг логической `лжи' (0).
+ `ERR`  - флаг ошибки, возвращается процедурами при неудаче (-1).
+ `OK` - флаг ошибки, возвращается процедурами когда все выполнено правильно.

---
[Содержание](#содержание)

### Использование библиотеки

Теперь мы опишем как на деле использовать экранный пакет. Здесь мы предполагаем, что все обновление, чтение, и так далее применяются к `stdscr`. Эти инструкции будут работать для любого окна, если ты изменишь название функции и параметры как описывалось выше.
Здесь пример программы, которая послужит поводом для обсуждения:

```cpp
#include <curses.h>
#include <signal.h>

static void finish(int sig);

main(int argc, char *argv[]) {
    /* инициализируй свои не относящиеся к curses структуры данных здесь */

    (void) signal(SIGINT, finish);      /* подготовить прерывания для завершения */

    (void) initscr();      /* инициализировать библиотеку curses */
    keypad(stdscr, TRUE);  /* разрешить преобразование кодов клавиатуры */
    (void) nonl();         /* не делать NL->CR/NL при выводе */
    (void) cbreak();       /* читать один символ за раз, не ждать \n */
    (void) noecho();       /* не показывать ввод */

    if (has_colors())
    {
        start_color();

        /*
         * Простое назначение цветов, часто нужное всем.
         */
        init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
        init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
        init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
        init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
        init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
        init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
        init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
        init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
    }

    for (;;)
    {
        int c = getch();     /* обновить, принять одиночное нажатие клавиши с ввода */

        /* обработать команду нажатой клавиши */
    }

    finish(0);               /* мы закончили */
}

static void finish(int sig) {
    endwin(); /* выполни завершающие не curses команды здесь */

    exit(0);
}
```

---
[Содержание](#содержание)

#### Запуск

Чтобы использовать экранный пакет, программы должны знать характеристики терминала, и должно быть выделено пространство для `curscr` и `stdscr`.

Функция `initscr()` заботится об этих вещах.

Т.к. под окна выделяется место, то может произойти переполнение памяти при попытке сделать это. Если этот редкий случай произойдет, то `initscr()` завершит выполнение программы с сообщением об ошибке.

`initscr()` должна всегда вызываться перед любой процедурой, которая воздействует на окна.<br>
Если это не сделано, то программа завершится с образованием файла `core`(дампа памяти), как только попытается обратиться к `curscr` или `stdscr`. Однако, обычно лучше всего подождать, пока вызов действительно не понадобится, например после проверки ошибок запуска. Процедуры, меняющие состояние терминала, типа `nl()` и `cbreak()` должны также вызываться после `initscr()`.

После того как окна были размещены на экране, ты можешь настроить их под свою программу.

+ Если ты хочешь, скажем, разрешить прокрутку экрана, используй `scrollok()`.
+ Если ты хочешь, чтобы курсор был слева от места последнего изменения используй `leaveok()`.
+ Если это не сделано, `refresh()` будет перемещать курсор в текущие оконные координаты (y, x) после его обновления.

Ты можешь создать новые окна с помощью функций `newwin()`, `derwin()`, и `subwin()`. <br>
Процедура `delwin()` позволяет избавиться от старых окон. Все опции, описанные выше, применимы к любому окну.

---
[Содержание](#содержание)

#### Вывод

Теперь, когда мы все настроили, мы бы хотели что-нибудь вывести на терминал. Основные функции, используемые для этого, которые работают и для окон это `addch()` и `move()`.

`addch()` вставляет символ в текущие (y, x) координаты. `move()` изменяет текущие (y, x) координаты на те, которые бы ты хотел.<br>
Она возвращает `ERR`, если ты вышел за пределы окна. Как отмечалось выше, ты можешь объединить две функции в одну `mvaddch()` чтобы сделать обе эти вещи за один раз.

Другие функции вывода, например `addstr()` и `printw()`, все - вызывают `addch()` для добавления символа в окно.

После того как окно заполнено чем надо, то для того чтобы часть терминала, отвечающая за окно, отобразила эту информацию, ты должен вызвать `refresh()`.

Для оптимизации найденных изменений, `refresh()` предполагает что любая часть окна не изменялась с момента последнего вызова `refresh()`, т.е. это окно не изменилось на терминале, т.е. что ты не обновлял эту часть терминала из-из перекрывающихся окон. Если это не такой случай, процедура `touchwin()` делает так как-будто всё окно было изменено, заставляя `refresh()` проверять всю часть терминала.

Если вызвать `wrefresh()` с `curscr` в качестве аргумента, то это заставит думать `curscr`, что экран выглядит как `curscr`. Это полезно для реализации команды, которая перерисовывает экран, в случае если на нём беспорядок.

---
[Содержание](#содержание)

#### Ввод

Дополнительная функция к `addch()` - `getch()`, которая с установленным эхом, будет вызывать `addch()` для повторения символа на экране.<br>
Поскольку экранному пакету необходимо всё время знать что творится на терминале, то если символы отображаются, то `tty` должен быть в `raw` или `cbreak` режиме.<br>
Поскольку изначально эхо на терминал разрешено и он в обычном `cooked` режиме, то одна из этих вещей должна быть изменена перед вызовом `getch()`; иначе вывод программы будет непредсказуем.

Когда тебе нужно ввести строку в окне, то для этого есть функции `wgetstr()` и подобные. <br>
Есть даже функция `wscanw()`, которая может выполнять в `scanf()`-стиле разбор строки с несколькими полями в окне ввода. Также есть псевдостроковые функции, которые включают эхо на время своего выполнения.

Пример кода выше использует вызов `keypad(stdscr, TRUE)` чтобы разрешить поддержку отображения функциональных клавиш.<br>
С помощью этого свойства, код `getch()` отслеживает во входном потоке последовательности символов, которые соответствуют стрелкам и функциональным клавишам.

Эти последовательности возвращаются как значения псевдосимволов. Возвращаются `#define` значения, описанные в `curses.h`.

Перевод последовательностей в `#define` значения определяются `key_` возможностями в терминальных записях `terminfo`.

---
[Содержание](#содержание)

#### Использование символов псевдографики

Функция `addch()` (и некоторые другие, включая `box()` и `border()`) может принимать некоторые псевдосимвольные аргументы, которые специально определены в `ncurses`.

Эти `#define` значения определены в заголовочном файле `curses.h`; смотри там полный список(ищи префикс ACS_).

Большинство полезных ACS определяют символы псевдографики. Ты можешь использовать их для рисования прямоугольников и простых графиков на экране. Если терминал не имеет таких символов, то `curses.h` переводит их в узнаваемый (хотя и некрасивый) набор по умолчанию ASCII.

---
[Содержание](#содержание)

#### Атрибуты и цвет символа

Пакет `ncurses` поддерживает выделения на экране, включающие `standout`, `reverse-video`, подчеркивание и мигание. Он также поддерживает цвет, к которому относятся как еще к одному выделению.

Выделения внутренне кодируются с помощью старших битов в псевдосимвольном типе (`chtype`), который `curses.h` использует для представления содержимого экранной ячейки.<br>
Смотри в заголовочном файле `curses.h` полный список значений масок выделений (ищи префикс `A_`).

Существует два пути сделать выделение.

+ Первый - это логически сложить (`or`) значение выделения с символьным аргументом в вызове `addch()`, или еще сделать один вызов, который принимает `chtype` аргумент.
+ Второй - это установить текущее значение выделения. Оно логически сложится (`or`) с любым выделением, сделанном первым путем. Ты можешь сделать это с помощью функций `attron()`, `attroff()`, и `attrset()`; подробней смотри на страницах руководства.

**Цвет** - это специальный вид выделения.<br>
На самом деле пакет работает с таким термином как цветовая пара - комбинация цветов переднего и заднего плана.<br>
Пример кода выше настраивает восемь цветовых пар, все обязательно существующие цвета на черном фоне.<br>
Обратите внимание что каждая цветовая пара, в сущности, отражает название цвета переднего плана. Любые другие другие значения из неконфликтующего диапазона могут использоваться в качестве значений первых аргументов `init_pair()`.

После того как ты закончил с помощью `init_pair()` создание цветовой пары **N**, ты можешь использовать `COLOR_PAIR(N)` в качестве выделения, вызвав особую цветовую комбинацию.<br>
Обратите внимание, что в `COLOR_PAIR(N)`, константа `N`, является константой во время компиляции и может быть использована в инициализаторах.

---
[Содержание](#содержание)

#### Работа с мышью

Библиотека `ncurses` также обеспечивает взаимодействие с мышью.<br>
**Внимание:** это возможно только в `ncurses`, это не часть ни стандарта XSI Curses, ни System V Release 4, ни BSD curses. Поэтому, мы рекомендуем заключать код работы с мышью в `#ifdef`, используя свойство макроса `NCURSES_MOUSE_VERSION`, для того чтобы он не компилировался и не линковался на не-ncurses системах.

В настоящее время, события от мыши работают только под `xterm`. В будущем, `ncurses` научится определять присутствие свободного сервера мыши `gpm(1)`, Alessandro Rubini для Linux систем и принимать события от мыши через него.

Работа с мышью очень проста. Чтобы начать работу, используй функцию `mousemask()`, принимающую в качестве первого аргумента битовую маску, в которой указываешь какие события ты хочешь чтобы твоя программа видела. Она возвращает битовую маску событий которые на самом деле будут видимы, которая может отличаться от аргумента, если устройство мыши не способно выдавать некоторые типы событий, которые ты указал.

Как только мышь стала работать, цикл команд твоего приложения должен отслеживать возвращаемые значения `KEY_MOUSE` с помощью `wgetch()`. Когда ты видишь его, то значит событие мыши в очереди. Чтобы вытащить его из очереди, используется функция `getmouse()` (ты должен сделать это перед следующим `wgetch()`, иначе может возникнуть другое событие мыши и сделает первое событие недосягаемым).

Каждый вызов `getmouse()` заполняет структуру (адрес которой ты передал) данными события мыши. Данные события включают координаты указателя мыши в координатах экрана. Они также включают маску события. Биты маски установлены соответственно типу возвращаемого события.

Структура мыши содержит два дополнительных поля, которые могут использоваться в будущем для взаимодействия `ncurses` с новыми свойствами устройств указателей. В дополнение к x и y координатам, есть область памяти для z координаты; она может быть полезна для сенсорных экранов, которые возвращают параметр давления или время нажатия. Есть также поле ID устройства, которое может использоваться для распознавания различных устройств указателей.

Признак видимости событий может быть изменён в любое время с помощью `mousemask()`.<br>
События, которые можно отслеживать:

+ нажатие,
+ отпускание,
+ однократный-, двойной- и тройной-щелчок (ты можешь установить максимальное время удержания клавишы между щелчками).

Если ты не сделаешь щелчки видимыми, то они возвращаются в виде пар нажал-отпустил. В некоторых средах в маску событий могут включаться биты состояния клавиш `shift`, `alt`, и `ctrl` клавиатуры во время события.

Функция также предоставляет информацию в каком окне возникло событие от мыши. Ты можешь использовать это для решения уместно ли реагировать на сообщение из этого окна.

Т.к. события мыши доступны не во всех средах, то было бы глупо строить приложения `ncurses`, которым для работы необходима мышь. Предпочтительно использовать мышь как ссылку для команд укажи-и-нажми в приложениях, которые обычно доступны с клавиатуры. Две тестовых игры в поставке `ncurses` (`bs` и `knight`) содержат код, который демонстрирует как это может быть сделано.

Смотри в man страницах `curs_mouse(3X)` полное описание функций взаимодействия с мышью.

---
[Содержание](#содержание)

#### Завершение

Чтобы убрать после процедур `ncurses` , существует процедура `endwin()`. Она восстанавливает режимы `tty`, которые были до первого вызова `initscr()`, и перемещает курсор в нижний левый угол. Таким образом, всегда после вызова `initscr`, перед выходом, должна вызываться `endwin()`.

---
[Содержание](#содержание)

## Описания функций

### Инициализация и завершение

#### initscr()

Почти всегда первой вызываемой функцией должна быть `initscr()`. Она определяет тип терминала и инициализирует структуры данных `curses`.<br>
`initscr()` также все настраивает так, чтобы первый вызов `refresh()` очистил весь экран.<br>
Если произошла ошибка, то записывается сообщение в стандартный поток ошибок и программа завершается.<br>
Иначе возвращается указатель на `stdscr`.

Некоторые функции можно вызывать перед `initscr` (`slk_init()`, `filter()`, `ripofflines()`, `use_env()`, и если ты используешь различные терминалы, `newterm()`.)

#### endwin()

Твоя программа всегда должна вызывать `endwin()` перед тем как выйти или для вызова `shell`. Эта функция восстанавливает режимы `tty`, перемещает курсор в нижний левый угол экрана, сбрасывает терминал в правильный не-визуальный режим. Вызов `refresh()` или `doupdate()` после временного выхода из программы восстанавливает экран **ncurses** в первоначальное состояние.

#### newterm(type, ofp, ifp)

Программа, которая работает более чем с одним терминалом должна использовать `newterm()` вместо `initscr()`. `newterm()` должен вызываться один раз для каждого терминала. Он возвращает переменную типа `SCREEN *`, которая должна сохраняться как ссылка на этот терминал. Аргументами являются тип терминала (строка) и указатели `FILE` для вывода и ввода в терминал. Если тип `NULL` - используется переменная среды `$TERM`.<br>
`endwin()` должна вызываться единожды во время завершения работы для каждого терминала, открытого этой функцией.

#### set_term(new)

Эта функция используется для переключения терминала в другой уже открытый `newterm()` терминал. Указатель на экран передается в качестве параметра. Этой функцией возвращается предыдущий терминал. Все остальные вызовы влияют только на текущий терминал.

#### delscreen(sp)

Обратная `newterm()`; освобождает структуры данных, связанные с данной `SCREEN` ссылкой.

---
[Содержание](#содержание)

### Процесс вывода на терминал

#### refresh() и wrefresh(win)

Эти функции делают вывод непосредственно на терминал, тогда как другие процедуры просто работают со структурами данных. `wrefresh()` копирует заданное окно на физический экран терминала , принимая в расчет то что уже на нем есть, чтобы выполнить оптимизацию.<br>
`refresh()` выполняет регенерацию `stdscr()`. Если `leaveok()` не был разрешен, то физический курсор терминала располагается слева от курсора окна.

#### doupdate() и wnoutrefresh(win)

Эти две функции позволяют различные обновления с большей эффективностью чем `wrefresh`. Для их использования важно понять как работает **curses**.<br>
В дополнение ко всем структурам окна, **curses** содержит две структуры данных, представляющих экран терминала:

+ физический экран, описывающий что по-настоящему есть на экране и
+ виртуальный экран, описывающий что программист хочет иметь на экране.

`wrefresh` во-первых копирует заданное окно на виртуальный экран (`wnoutrefresh()`), и затем вызывает процедуру обновления экрана (`doupdate()`).<br>
Если программист захочет вывести несколько окон за раз, то серия вызовов `wrefresh` в результате приведет к альтернативным вызовам `wnoutrefresh()` и `doupdate()`, приводящим к нескольких всполохам экрана.<br>
Если вызвать `wnoutrefresh()` для каждого окна, то затем возможно вызвать `doupdate()` только один раз, что приведет только к одному всплеску вывода, с незначительной передачей символов (это также помогает избежать визуального раздражающего мерцания при каждом обновлении).

---
[Содержание](#содержание)

### Возможности низкоуровневого доступа

#### setupterm(term, filenum, errret)

Эта процедура вызывается для инициализации описания терминала, без установки экранных структур **curses** или изменения битов режимов драйвера `tty`.

+ **term** - строка символов, обозначающая название используемого терминала.
+ **filenum** - файловый указатель UNIX на терминал, используемый для вывода.
+ **errret** - указатель на целое, в которое пишется успешно или нет выполнение.

Возвращаемое значение может быть 1 (все нормально), 0 (нет такого терминала), или -1 (проблемы с нахождением базы данных `terminfo`).

Значение `term` может быть `NULL`, что приводит к использованию значения среды `TERM`.<br>
Указатель `errret` может также быть `NULL`, что значит код ошибки не нужен. Если `errret` определен и что-то не так, `setupterm()` напечатает соответствующее сообщение об ошибке и программа завершится, что лучше чем просто вернуться. Таким образом, простая программа вызывает `setupterm(0, 1, 0)` и не беспокоится об ошибках инициализации.

После вызова `setupterm()`, глобальная переменная `cur_term` устанавливается на текущую структуру параметров терминала. Вызвав `setupterm()` для каждого терминала и сохранив и восстановить `cur_term`, то для программы возможно использовать два или более терминала сразу.<br>
`Setupterm()` также сохраняет названия разделов описаний терминала в глобальном символьном массиве `ttytype[]`.<br>
Последующие вызовы `setupterm()` перезаписывают этот массив, так что тебе, если требуется, надо сохранять их самому.

---
[Содержание](#содержание)

### Отладка

ВНИМАНИЕ: Эти функции не часть стандартного curses API!

#### trace()

Эта функция используется для точной установки уровня отладки. Если уровень отладки не ноль, во время выполнения твоей программы создастся файл с именем `trace' в текущем рабочем каталоге, в котором содержится отчет о действиях библиотеки. Большие уровни отладки разрешают выводить больше подробностей (и объемнее) -- подробности смотри в комментариях рядом с определениями TRACE_ в файле curses.h. (Также возможно установить уровень отладки, установив его в переменной среды NCURSES_TRACE).

#### _tracef()

Эта функция используется для вывода твоей собственной отладочной информации. Она доступна только если ты линковал с -lncurses_g. Она может использоваться вместо printf(), только она выводит новую строку после всех аргументов. Вывод осуществляется в файл в именем trace в текущий каталог.
Журнал отладки может быть труден для понимания из-за избыточных объемов выводимых данных в нем. Есть сценарий, называемый tracemunch, включенный в поставку ncurses, который может до какой-то степени облегчить задачу; он группирует длинные последовательности похожих операций в более сжатую одиночную строку псевдооперации. Эти псевдооперации можно отличить по названию из заглавных букв.

---
[Содержание](#содержание)

### Подсказки, советы и трюки

**Man** страницы **ncurses** - полное руководство по библиотеке. В оставшейся части этого документа, мы обсудим полезные методы, которые могут быть не так очевидны из описания man страниц.

#### Некоторые предостерегающие замечания

Если ты думаешь что тебе нужно использовать `noraw()` или `nocbreak()`, подумай еще раз и тихонько двигайся дальше. Вероятно лучшим решением будет использовать `getstr()` или подобную для симуляции cooked режима.

Функции `noraw()` и `nocbreak()` стараются восстановить `cooked` режим, но они могут задрать некоторые контрольные биты, установив их перед тем как приложение запустится.

Также, они всегда были плохо описаны и вероятно уменьшат используемость твоего приложения с другими библиотеками `curses`.

Запомни, что `refresh()` это синоним `wrefresh(stdscr)`, и не пытайся смешивать использование `stdscr` с использованием окон, объявленных `newwin()`; вызов `refresh()` сметет их с экрана.<br>
Правильным решением будет использовать `subwin()`, или не трогать `stdscr` совсем и уложить черепицей объявленные окна, которые затем `wnoutrefresh()` где-нибудь в цикле событий программы и одиночным вызовом `doupdate()` выполнить настоящую перерисовку.

Вероятно будет намного меньше проблем если ты будешь располагать окна черепицей, не допуская перекрытия. Исторически, поддержка в **curses** перекрывающихся окон была слаба, хрупка и плохо описана. Библиотека **ncurses** еще не исключение из этого правила.

Есть свободная библиотека панелей, включенная в поставку **ncurses**, которая неплохо выполняет работу по усилению способностей перекрывающихся окон.

Постарайся избежать использования глобальных переменных `LINES` и `COLS`. Используй вместо них `getmaxyx()` в контексте `stdscr`.<br>
Причина: твой код может портироваться для запуска в средах с изменяемыми размерами окна, т.е. несколько экранов могут иметь разные размеры.

#### Временный выход из режима ncurses

Иногда тебе нужно написать программу, которая почти все время находится в экранном режиме, но время от времени возвращается в обычный `cooked` режим. Обычная причина - это поддержка выхода в `shell`. Это просто устроить в **ncurses**.

Для выхода из режима **ncurses**, вызывается `endwin()` как если бы завершалась работа программы. Это возвратит экран из `cooked` режима; ты можешь запустить `shell`. Когда ты захочешь вернуться в режим **ncurses**, просто вызови `refresh()` или `doupdate()`. Они перерисуют экран.

Есть логическая функция, `isendwin()`, код которой можно использовать для определения активен ли экранный режим **ncurses**. Она возвращает `TRUE` в промежутке между вызовом `endwin()` и следующим `refresh()`, иначе `FALSE`.

Вот часть примерного кода для `shell`:

```cpp
addstr("Shelling out...");
def_prog_mode();           /* сохранить текущие режимы tty */
endwin();                  /* восстановить первоначальные режимы tty */
system("sh");              /* запустить shell */
addstr("returned.\n");     /* подготовить сообщение о возвращении */
refresh();                 /* восстановить сохраненные режимы, перерисовать экран */
```

#### Использование ncurses в xterm

Операция изменения размера в **X** посылает `SIGWINCH` в приложения, запущенные в `xterm`.

Библиотека **ncurses** не перехватывает этот сигнал, потому что в общем-то не знает как ты хочешь перерисовать экран. Тебе придется написать обработчик `SIGWINCH` самому.

Простейший код обработчика `SIGWINCH` имеет `endwin`, за ним `refresh` и экран перерисовывается сам.<br>
`refresh` берет новый размер экрана из окружения терминала.

#### Обработка нескольких терминальных экранов

Функция `initscr()` на самом деле вызывает функцию `newterm()` для выполнения большей части работы. Если ты пишешь программу, которая отрывает несколько терминалов, используй `newterm()` напрямую.

Для каждого вызова ты должен указать тип терминала и пару файловых указателей; каждый вызов возвращает экранную ссылку и `stdscr` устанавливается равным последней. Ты можешь переключаться между терминалами с помощью `set_term`. Обратите внимание что ты можешь также вызвать `def_shell_mode` и `def_prog_mode` на каждый `tty`.

#### Проверка возможностей терминала

Иногда нужно написать программу, которая проверяет наличие различных возможностей, перед тем как решить войти ли в **ncurses** режим.<br>
Простое решение проблемы - вызвать `setupterm()`, затем использовать функции `tigetflag()`, `tigetnum()`, и `tigetstr()` для проверки.

В частности это полезно когда ты хочешь проверить считать ли данный тип терминала как "умный" (с адресуемым курсором) или "глупый".<br>
Правильный путь для проверки - это посмотреть что возвращаемое значение `tigetstr("cup")` не `NULL`. Другой способ, это включить файл `term.h` и проверить значение макроса `cursor_address`.

#### Настройка скорости

Используй семейство функций `addchstr()` для быстрого рисования текста на экране, когда ты знаешь, что текст не содержит управляющих символов. Постарайся реже изменять атрибуты на экране. Не используй опцию `immedok()`!

#### Специальные свойства ncurses

Когда программа работает на PC-совместимом компьютере, **ncurses** предоставляет расширенную поддержку IBM high-half и ROM символов. Выделение `A_ALTCHARSET` позволяет отображать обе high-half ACS графику и PC ROM графику 0-31, которая обычно интерпретируется как контрольные символы.

Функция `wresize()` позволяет изменять размер окна по месту.

---
[Содержание](#содержание)

### Совместимость со старыми версиями

Не смотря на все наши усилия, есть некоторые различия между **ncurses** и (недокументированным!) поведением старых реализаций **curses**. Они восстали из двусмысленностей или пропусков в документации API.

#### Регенерация перекрывающихся окон

Если ты определил два окна, A и B, которые перекрываются, и затем как-то переместил и регенерировал их, то как надо делать изменения в перекрывающихся областях в исторических версиях curses часто точно не описаны.

Чтобы понять почему возникла эта проблема, вспомним что обновления экрана подсчитываются между двумя представлениями *всего* экрана. В документации сказано, что когда ты регенерируешь окно, во-первых оно копируется в виртуальный экран, а затем подсчитываются изменения для обновления физического экрана (и применяются на терминале). Но как "применяются" точно не указано, и есть неуловимая разница в том какая разница получилась при копировании в случае где два перекрывающихся окна регенерировались в неизвестные промежутки времени.

Что получится в перекрывающихся областях зависит от того что при `wnoutrefresh()` было с аргументами -- какая часть аргумента окна копируется на виртуальный экран. Некоторые реализации выполняют "измененное копирование", копируя только места в окне, которые были изменены (или были помечены как изменённые с помощью `wtouchln()` и компанией). Некоторые реализации выполняют "целиковое копирование", копируя всё окно в виртуальный экран были или нет в нём изменения.

Сама библиотека **ncurses** не всегда согласуется с этими положениями. С версии 1.8.7 по 1.9.8a был баг и они делали целиковое копирование. Версии 1.8.6 и старее и версии 1.9.9 и новее, выполняли изменённое копирование.

Для большинства коммерческих реализаций **curses**, это не документировано и нельзя знать точно (по крайней мере для ведущих **ncurses**) выполняют ли они изменённое копирование или целиковое копирование. Мы знаем что в System V release 3 curses логика похожа на попытку выполнить изменённое копирование, но логика среды и представление данных достаточно сложны, и наше познания достаточно поверхносны, и очень трудно узнать насколько это правда. Не все чисто и в том что подразумевают документация SVr4 и стандарт XSI. Стандарт XSI Curses упоминает только `wnoutrefresh()`; документы SVr4 кажется описывают целиковое копирование, но возможно с некоторыми усилиями и стилем прочитать их совсем по-другому.

Может быть поэтому неблагоразумно полагаться на какое-либо поведение в программах, которые могут линковаться с другими реализациями curses. Вместо этого, ты можешь выяснить с `touchwin()` перед вызовом `wnoutrefresh()` для гарантии целостности содержимого везде.

По-настоящему просветленный путь обработки этого это использовать библиотеку панелей. Если ты захочешь обновить экран, выполни `update_panels()`, которая сделает все необходимые вызовы `wnoutrfresh()` для всех панелей, в порядке определенной тобой очерёдности. Затем ты можешь сделать один `doupdate()` и это будет один единственный всплеск физического I/O, который выполнит все твои обновления.

#### Заполнение при стирании

Если ты использовал очень старые версии ncurses (1.8.7 или старше) тебя может удивить поведение стирающих функций. В старых версиях стираемые зоны окна заполнялись пробелом, изменяемым с помощью текущего атрибута окна (как установили `wattrset()`, `wattron()`, `wattroff()` и компания).

В новых версиях это не так. Вместо этого атрибут стирания пробел - это нормально, хотя и пока изменяется функциями `bkgdset()` или `wbkgdset()`.

Это изменение в поведение ncurses соответствует System V Release 4 и стандарту XSI Curses.

#### Соответствие XSI Curses

Библиотека **ncurses** предполагает что соответствует базовому уровню стандарта XSI Curses от X/Open. Многие свойства расширенного уровня (фактически, почти все свойства не имеющие отношения к широким символам и интернационализации) также поддерживаются.

Один эффект соответствия XSI это изменение в поведении описан в "Заполнение при стирании -- Совместимость с старыми версиями".

Также **ncurses** удовлетворяет требование XSI, что каждый макрос должен иметь соответствующую функцию, которая линкуется (и будет проверен прототипом) если макроопределение запрещено с помощью `#undef`.

---
[Содержание](#содержание)

## Библиотека панелей

Сама библиотека ncurses обеспечивает хорошую поддержку для отображения экранов, в которых окна расположены черепицей (не перекрываются). В большинстве случаев, в которых окна могут перекрываться, ты можешь использовать серию вызовов wnoutrefresh() и doupdate(), и позаботиться о порядке выполнения регенерации окон. Порядок должен быть снизу вверх, иначе части окна, которые должны быть закрыты будут торчать наружу.
Если разрабатываемый интерфейс такой, что окна могут погружаться в стеке видимости или всплывать во время выполнения программы, то получившееся в результате счетоводство может быть утомительно и сложно для правильного выполнения. Следовательно нужна библиотека панелей.

Библиотека панелей впервые появилась в AT&T System V. Версия, описываемая здесь - это свободный код панелей, распространяющийся с ncurses.