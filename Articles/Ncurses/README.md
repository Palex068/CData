# Введение в программирование с curses

Авторы: Eric S. Raymond и Zeyd M. Ben-Halim [Источник](http://grep.cs.msu.ru/ncurses.html#introduction)

## Содержание

+ [Введение](#введение)
+ [Краткая история Curses](#краткая-история-curses)
+ [Цель этого документа](#цель-этого-документа)
+ [Терминология](#терминология)
+ [<Библиотека Curses](#библиотека-curses)
  + [Краткий обзор Curses](#краткий-обзор-curses)
    + [Компиляция программ, использующих Curses](#компиляция-программ-использующих-curses)
    + [Обновление экрана](#обновление-экрана)
    + [Стандартные окна и соглашения об именах функций](#стандартные-окна-и-соглашения-об-именах-функций)
    + [Переменные](#переменные)
  + [Использование библиотеки](#использование-библиотеки)
    + [Запуск](#запуск)
    + [Вывод](#вывод)
    + [Ввод](#ввод)
    + [Использование символов псевдографики](#использование-символов-псевдографики)
    + [Атрибуты и цвет символа](#атрибуты-и-цвет-символа)
    + [Работа с мышью](#работа-с-мышью)
    + [Завершение](#завершение)
  + [Описания функций](#описания-функций)
+ [Инициализация и завершение]()
+ [Процесс вывода на терминал]()
+ [Возможности низкоуровневого доступа]()
+ [Отладка]()
+ [Подсказки, советы и трюки]()
+ [Некоторые предостерегающие замечания]()
+ [Временный выход из режима ncurses]()
+ [Использование ncurses в xterm]()
+ [Обработка нескольких терминальных экранов]()
+ [Проверка возможностей терминала]()
+ [Настройка скорости]()
+ [Специальные свойства ncurses]()
+ [Совместимость со старыми версиями]()
+ [Регенерация перекрывающихся окон]()
+ [Заполнение при стирании]()
+ [Соответствие XSI Curses]()
+ [Библиотека панелей]()
+ [Компиляция программ, использующих библиотеку панелей]()
+ [Краткий обзор панелей]()
+ [Панели, ввод и стандартный экран]()
+ [Сокрытие панелей]()
+ [Другие различные возможности]()
+ [Библиотека меню]()
+ [Компиляция с библиотекой меню]()
+ [Краткий обзор меню]()
+ [Выбор элементов]()
+ [Отображение меню]()
+ [Окна меню]()
+ [Обработка ввода в меню]()
+ [Другие различные возможности]()
+ [Библиотека форм]()
+ [Компиляция с библиотекой форм]()
+ [Краткий обзор форм]()
+ [Создание и удаление полей и форм]()
+ [Получение и изменение атрибутов поля]()
+ [Получение данных о размере и расположении]()
+ [Изменение расположения поля]()
+ [Атрибуты выравнивания]()
+ [Атрибуты отображения поля]()
+ [Биты опций поля]()
+ [Статус поля]()
+ [Пользовательский указатель поля]()
+ [Поля с изменяемым размером]()
+ [Правильность заполнения поля]()
+ [TYPE_ALPHA]()
+ [TYPE_ALNUM]()
+ [TYPE_ENUM]()
+ [TYPE_INTEGER]()
+ [TYPE_NUMERIC]()
+ [TYPE_REGEXP]()
+ [Прямая работа с буфером поля]()
+ [Атрибуты формы]()
+ [Управление отображением формы]()
+ [Обработка ввода в драйвере формы]()
+ [Запросы перемещения страниц]()
+ [Запросы перемещения между полями]()
+ [Запросы перемещения внутри поля]()
+ [Запросы прокрутки]()
+ [Запросы редактирования]()
+ [Запросы упорядочивания]()
+ [Команды приложения]()
+ [Изменение обработчиков полей]()
+ [Команды смены поля]()
+ [Опции формы]()
+ [Правильность типов, определяемая пользователем]()
+ [Объединение типов]()
+ [Новые типы полей]()
+ [Аргументы функции проверки данных]()
+ [Функции упорядочивания для пользовательских типов]()
+ [Как избежать проблем]()

## Введение

Этот документ является введением в программирование с `curses`. Это не исчерпывающий справочник по Интерфейсу Прикладных Программ(API) для `curses`; эту роль играют **man** страницы `curses`. Скорее, его цель - облегчить понимание пакета программистам на C.

Этот документ предназначен для программистов на C, которые еще плохо знакомы с `ncurses`. Если ты уже имел опыт программирования с curses, тем не менее должен прочитать разделы Работа с мышью, Отладка, Совместимость со старыми версиями, и Подсказки, советы и трюки.

<!-- TODO -->

Они помогут тебе увеличить скорость приложений за счет специальных возможностей и особенностей реализации ncurses. Если ты не так опытен, то продолжай читать.

Пакет curses - библиотека подпрограмм для терминально-независимого вывода на экран и обработки входящих событий, которая для программиста представляет собой высокоуровневую модель представления экрана, скрывающую различия между типами терминалов и выполняющую автоматическую оптимизацию вывода при замене одного заполненного текстом экрана на другой. `Curses` использует **terminfo** - формат базы данных, которым можно описать возможности тысячи различных терминалов.

`curses API` может показаться неким архаизмом на UNIX терминалах при возрастающем преобладании X, Motif, и Tcl/Tk. Тем не менее, UNIX еще поддерживает линии tty и X-ы поддерживают xterm(1); `curses API` имеет преимущества:

+ (а) обратная портируемость на текстовые терминалы, и
+ (б) простота.

Для приложений, в которых не требуется растровой графики и разных шрифтов, реализация интерфейса с помощью curses обычно проще и дешевле, чем использование одного X toolkit.

---
[Содержание](#содержание)

## Краткая история Curses

Исторически, первым предком `curses` были процедуры, написанные для обеспечения работы с экраном в игре **rogue**; они использовали параметры уже существующей базы данных **termcap** описаний возможностей терминалов. Эти процедуры были сложены в документированную библиотеку и впервые появились в ранних версиях BSD UNIX.

В System III UNIX от Bell Labs свойства были переписаны и намного улучшена сама библиотека `curses`. В ней был представлен формат **terminfo**. 

**Terminfo** основывается на базе данных `Berkeley termcap`, но содержит несколько улучшений и расширений. Были представлены параметризованные возможности строк, стало возможным описать различные видео атрибуты и цвета, и она стала работать с намного большим количеством терминалов, чем это было возможно с `termcap`. 

Позднее в выпусках AT&T System V, `curses` развила использование большинства свойств и предоставила большие возможности, оставив далеко позади BSD curses по мощности и гибкости.

---
[Содержание](#содержание)

## Цель этого документа

Этот документ описывает `ncurses`, свободную реализацию **System V curses API** с некоторыми ясно описываемыми расширениями. Она включает в себя следующие свойства System V curses:

+ Поддержку различных выделений светом на экране (BSD curses могла работать только с одним световым `выделением', обычно инверсией цвета).
+ Поддержку рисования линий и прямоугольников с помощью символов псевдографики.
+ Распознавание ввода функциональных клавиш.
+ Поддержку цвета.
+ Поддержку pads (окон, больших чем размер экрана, для которых экран или подокно определены как область вывода).

Также, этот пакет позволяет использовать вставку и удаление строк и свойства символов терминалов, и определяет как оптимально использовать эти свойства без помощи программиста.

Он также позволяет отображать произвольные комбинации видео атрибутов, даже на терминалах, которые оставляют ``magic cookies'' на экране, когда происходят изменения в атрибутах.

Пакет `ncurses` может также перехватывать и использовать сообщения от мыши в некоторых средах (xterm в системе X window). Этот документ включает советы по использованию мыши.

Пакет `ncurses` создал **Pavel Curtis**. Первоначальный ведущий пакета [Zeyd Ben-Halim](zmbenhal@netcom.com).

[Eric S. Raymond](esr@snark.thyrsus.com) написал много новых свойств, которые вошли в версии больше 1.8.1 и написал большую часть введения. [Juergen Pfeifer](Juergen.Pfeifer@T-Online.de) написал целиком код меню и форм и связующий код [Ada95](http://www.adahome.com/).

Дальнейшая работа была выполнена [Thomas Dickey](dickey@clark.net) и [Juergen Pfeifer](Juergen.Pfeifer@T-Online.de).

[Florian La Roche](florian@gnu.org) выступает в роли ведущего для Free Software Foundation, у которого авторское право на ncurses. Связаться с текущими ведущими можно написав по [адресу](bug-ncurses@gnu.org).

В этом документе также описана библиотека расширений панелей,

<!-- TODO -->

имеющая свойства, подобные панелям в SVr4. Эта библиотека обеспечивает хранилище окон, связанное со стеком, или поверхность из перекрывающихся окон, и обеспечивает выполнение операций по перемещению окон по стеку, что меняет их видимость в естественном порядке (обрабатывая перекрывающиеся окна).

И наконец, этот документ подробно описывает библиотеки расширений меню и форм, также аналогичные System V, которые поддерживают легкое создание иерархических меню и заполнение форм.

<!-- TODO -->

---
[Содержание](#содержание)

## Терминология

В этом документе в разумных пределах была использована следующая терминология:

**Окно** - Структура данных, описывающая прямоугольную часть экрана (возможно весь экран). Ты можешь писать в окно как в миниатюрный экранчик, прокручивать его содержимое независимо от других окон на физическом экране.

**Экраны** - Поднабор окон, которые размером с экран терминала, т.е., они начинаются в верхнем левом углу и заканчиваются в нижнем правом углу. Один из них, stdscr, автоматически создается без программиста.

**Экран терминала** - Идея пакета состоит в том, чтобы дисплей терминала выглядел как на самом деле, т.е., чтобы пользователь видел что происходит прямо сейчас. Это специальный экран.

---
[Содержание](#содержание)

## Библиотека Curses

### Краткий обзор Curses

#### Компиляция программ, использующих Curses

Чтобы использовать библиотеку, необходимо иметь определенными некоторые типы и переменные. Поэтому, программист должен иметь строку:

```cpp
#include <curses.h>
```

в начале исходного кода программы.

Экранный пакет использует стандартную I/O библиотеку(ввода/вывода), поэтому `<curses.h>` включает `<stdio.h>`. `<curses.h>` в зависимости от твоей системы также включает `<termios.h>`, `<termio.h>`, или `<sgtty.h>`.

Для программиста излишне (но безопасно) еще раз включать эти строки. При линковке с `curses` тебе нужно иметь `-lncurses` в `LDFLAGS` или в командной строке. Нет необходимости в любых других библиотеках.

---
[Содержание](#содержание)

#### Обновление экрана

Чтобы оптимально обновлять экран, необходимы процедуры, которым нужно знать как выглядит экран в данный момент и что хочет программист чтобы на нем было в следующий момент.

Для этой цели определяется тип данных (структура) называемый `WINDOW`, который описывает изображение окна для программы, включая начальную позицию на экране (координаты (y, x), левого верхнего угла) и его размер.

Один из них (называемый `curscr`, текущий экран) это образ экрана, который в настоящий момент отображается на терминале. Другой экран (называемый `stdscr`, стандартный экран) - на нем по умолчанию делаются все изменения.

**Окно** - исключительно для внутреннего представления. Оно используется для построения и хранения возможного изображения части терминала. Оно ничего не знает относительно реального экрана терминала; оно больше похоже на `scratchpad` или буфер записи.

Чтобы часть физического экрана, связанная с окном, отразила содержимое структуры окна, вызывается процедура `refresh()` (или `wrefresh()`, если окно не `stdscr`).

Любая часть физического экрана может состоять из любого числа перекрывающихся окон. Также, изменения могут быть сделаны в окнах в любом порядке, без оглядки на то, как это отразится на эффективности. После этого, программист может эффектно сказать ``сделай чтобы выглядело так'', и дать реализации пакета определить наиболее эффективный путь перерисовки экрана.

---
[Содержание](#содержание)

#### Стандартные окна и соглашения об именах функций

Как отмечалось выше, программы могут использовать несколько окон, и еще два окна создаются автоматически: `curscr`, которое знает что на терминале в данный момент, и `stdscr`, которое отображает, что хочет получить программист на терминале в следующий момент.

Пользователь никогда не должен иметь прямого доступа к `curscr`.

Изменения должны делаться через API, а затем вызываться процедура `refresh()` (или `wrefresh()`).

Для многих функций определено использование `stdscr` как экрана по умолчанию.

Например, чтобы добавить символ на `stdscr`, нужен один вызов `addch()` с желаемым символов в качестве аргумента. Для записи в другое окно используется процедура `waddch()` (`w` - оконно-зависимая `addch()`).

Это соглашение применимо ко всем функциям с именами, начинающимися с "`w`", когда они должны применяться к определенным окнам. Этому правилу не подчиняются процедуры, для которых окно должно всегда указываться.

Для изменения текущих координат (y, x) используются процедуры `move()` и `wmove()`.

Однако, часто после изменения желательно выполнить какую-нибудь I/O операцию. Чтобы избежать неуклюжести кода большинство I/O процедур могут предваряться префиксом '`mv`' и желаемые (y, x) координаты указываться раньше других аргументов функций. Например, вызовы

```cpp
move(y, x);
addch(ch);
```

можно заменить на

```cpp
mvaddch(y, x, ch);
```

и

```cpp
wmove(win, y, x);
waddch(win, ch);
```

можно заменить на

```cpp
mvwaddch(win, y, x, ch);
```

Обратите внимание, что указатель на описатель окна (win) стоит перед добавляемыми (y, x) координатами. В функции необходимый указатель окна передается всегда первым параметром.

---
[Содержание](#содержание)

#### Переменные

Библиотека `curses` устанавливает некоторые переменные, описывающие возможности терминала.

тип | название | Описание
--- | -------- | ---
int | LINES    | число строк в терминале
int | COLS     | число столбцов в терминале

`curses.h` также вводит некоторые `#define` константы и типы, полезные всем:

+ `bool` - логический тип, на самом деле `char` (например, bool doneit;)
+ `TRUE` - флаг логической `правды' (1).
+ `FALSE` - флаг логической `лжи' (0).
+ `ERR`  - флаг ошибки, возвращается процедурами при неудаче (-1).
+ `OK` - флаг ошибки, возвращается процедурами когда все выполнено правильно.

---
[Содержание](#содержание)

### Использование библиотеки

Теперь мы опишем как на деле использовать экранный пакет. Здесь мы предполагаем, что все обновление, чтение, и так далее применяются к `stdscr`. Эти инструкции будут работать для любого окна, если ты изменишь название функции и параметры как описывалось выше.
Здесь пример программы, которая послужит поводом для обсуждения:

```cpp
#include <curses.h>
#include <signal.h>

static void finish(int sig);

main(int argc, char *argv[]) {
    /* инициализируй свои не относящиеся к curses структуры данных здесь */

    (void) signal(SIGINT, finish);      /* подготовить прерывания для завершения */

    (void) initscr();      /* инициализировать библиотеку curses */
    keypad(stdscr, TRUE);  /* разрешить преобразование кодов клавиатуры */
    (void) nonl();         /* не делать NL->CR/NL при выводе */
    (void) cbreak();       /* читать один символ за раз, не ждать \n */
    (void) noecho();       /* не показывать ввод */

    if (has_colors())
    {
        start_color();

        /*
         * Простое назначение цветов, часто нужное всем.
         */
        init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
        init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
        init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
        init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
        init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
        init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
        init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
        init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
    }

    for (;;)
    {
        int c = getch();     /* обновить, принять одиночное нажатие клавиши с ввода */

        /* обработать команду нажатой клавиши */
    }

    finish(0);               /* мы закончили */
}

static void finish(int sig) {
    endwin(); /* выполни завершающие не curses команды здесь */

    exit(0);
}
```

---
[Содержание](#содержание)

#### Запуск

Чтобы использовать экранный пакет, программы должны знать характеристики терминала, и должно быть выделено пространство для `curscr` и `stdscr`.

Функция `initscr()` заботится об этих вещах.

Т.к. под окна выделяется место, то может произойти переполнение памяти при попытке сделать это. Если этот редкий случай произойдет, то `initscr()` завершит выполнение программы с сообщением об ошибке.

`initscr()` должна всегда вызываться перед любой процедурой, которая воздействует на окна.<br>
Если это не сделано, то программа завершится с образованием файла `core`(дампа памяти), как только попытается обратиться к `curscr` или `stdscr`. Однако, обычно лучше всего подождать, пока вызов действительно не понадобится, например после проверки ошибок запуска. Процедуры, меняющие состояние терминала, типа `nl()` и `cbreak()` должны также вызываться после `initscr()`.

После того как окна были размещены на экране, ты можешь настроить их под свою программу.

+ Если ты хочешь, скажем, разрешить прокрутку экрана, используй `scrollok()`.
+ Если ты хочешь, чтобы курсор был слева от места последнего изменения используй `leaveok()`.
+ Если это не сделано, `refresh()` будет перемещать курсор в текущие оконные координаты (y, x) после его обновления.

Ты можешь создать новые окна с помощью функций `newwin()`, `derwin()`, и `subwin()`. <br>
Процедура `delwin()` позволяет избавиться от старых окон. Все опции, описанные выше, применимы к любому окну.

---
[Содержание](#содержание)

#### Вывод

Теперь, когда мы все настроили, мы бы хотели что-нибудь вывести на терминал. Основные функции, используемые для этого, которые работают и для окон это `addch()` и `move()`.

`addch()` вставляет символ в текущие (y, x) координаты. `move()` изменяет текущие (y, x) координаты на те, которые бы ты хотел.<br>
Она возвращает `ERR`, если ты вышел за пределы окна. Как отмечалось выше, ты можешь объединить две функции в одну `mvaddch()` чтобы сделать обе эти вещи за один раз.

Другие функции вывода, например `addstr()` и `printw()`, все - вызывают `addch()` для добавления символа в окно.

После того как окно заполнено чем надо, то для того чтобы часть терминала, отвечающая за окно, отобразила эту информацию, ты должен вызвать `refresh()`.

Для оптимизации найденных изменений, `refresh()` предполагает что любая часть окна не изменялась с момента последнего вызова `refresh()`, т.е. это окно не изменилось на терминале, т.е. что ты не обновлял эту часть терминала из-из перекрывающихся окон. Если это не такой случай, процедура `touchwin()` делает так как-будто всё окно было изменено, заставляя `refresh()` проверять всю часть терминала.

Если вызвать `wrefresh()` с `curscr` в качестве аргумента, то это заставит думать `curscr`, что экран выглядит как `curscr`. Это полезно для реализации команды, которая перерисовывает экран, в случае если на нём беспорядок.

---
[Содержание](#содержание)

#### Ввод

Дополнительная функция к `addch()` - `getch()`, которая с установленным эхом, будет вызывать `addch()` для повторения символа на экране.<br>
Поскольку экранному пакету необходимо всё время знать что творится на терминале, то если символы отображаются, то `tty` должен быть в `raw` или `cbreak` режиме.<br>
Поскольку изначально эхо на терминал разрешено и он в обычном `cooked` режиме, то одна из этих вещей должна быть изменена перед вызовом `getch()`; иначе вывод программы будет непредсказуем.

Когда тебе нужно ввести строку в окне, то для этого есть функции `wgetstr()` и подобные. <br>
Есть даже функция `wscanw()`, которая может выполнять в `scanf()`-стиле разбор строки с несколькими полями в окне ввода. Также есть псевдостроковые функции, которые включают эхо на время своего выполнения.

Пример кода выше использует вызов `keypad(stdscr, TRUE)` чтобы разрешить поддержку отображения функциональных клавиш.<br>
С помощью этого свойства, код `getch()` отслеживает во входном потоке последовательности символов, которые соответствуют стрелкам и функциональным клавишам.

Эти последовательности возвращаются как значения псевдосимволов. Возвращаются `#define` значения, описанные в `curses.h`.

Перевод последовательностей в `#define` значения определяются `key_` возможностями в терминальных записях `terminfo`.

---
[Содержание](#содержание)

#### Использование символов псевдографики

Функция `addch()` (и некоторые другие, включая `box()` и `border()`) может принимать некоторые псевдосимвольные аргументы, которые специально определены в `ncurses`.

Эти `#define` значения определены в заголовочном файле `curses.h`; смотри там полный список(ищи префикс ACS_).

Большинство полезных ACS определяют символы псевдографики. Ты можешь использовать их для рисования прямоугольников и простых графиков на экране. Если терминал не имеет таких символов, то `curses.h` переводит их в узнаваемый (хотя и некрасивый) набор по умолчанию ASCII.

---
[Содержание](#содержание)

#### Атрибуты и цвет символа

Пакет `ncurses` поддерживает выделения на экране, включающие `standout`, `reverse-video`, подчеркивание и мигание. Он также поддерживает цвет, к которому относятся как еще к одному выделению.

Выделения внутренне кодируются с помощью старших битов в псевдосимвольном типе (`chtype`), который `curses.h` использует для представления содержимого экранной ячейки.<br>
Смотри в заголовочном файле `curses.h` полный список значений масок выделений (ищи префикс `A_`).

Существует два пути сделать выделение.

+ Первый - это логически сложить (`or`) значение выделения с символьным аргументом в вызове `addch()`, или еще сделать один вызов, который принимает `chtype` аргумент.
+ Второй - это установить текущее значение выделения. Оно логически сложится (`or`) с любым выделением, сделанном первым путем. Ты можешь сделать это с помощью функций `attron()`, `attroff()`, и `attrset()`; подробней смотри на страницах руководства.

**Цвет** - это специальный вид выделения.<br>
На самом деле пакет работает с таким термином как цветовая пара - комбинация цветов переднего и заднего плана.<br>
Пример кода выше настраивает восемь цветовых пар, все обязательно существующие цвета на черном фоне.<br>
Обратите внимание что каждая цветовая пара, в сущности, отражает название цвета переднего плана. Любые другие другие значения из неконфликтующего диапазона могут использоваться в качестве значений первых аргументов `init_pair()`.

После того как ты закончил с помощью `init_pair()` создание цветовой пары **N**, ты можешь использовать `COLOR_PAIR(N)` в качестве выделения, вызвав особую цветовую комбинацию.<br>
Обратите внимание, что в `COLOR_PAIR(N)`, константа `N`, является константой во время компиляции и может быть использована в инициализаторах.

---
[Содержание](#содержание)

#### Работа с мышью

Библиотека `ncurses` также обеспечивает взаимодействие с мышью.<br>
**Внимание:** это возможно только в `ncurses`, это не часть ни стандарта XSI Curses, ни System V Release 4, ни BSD curses. Поэтому, мы рекомендуем заключать код работы с мышью в `#ifdef`, используя свойство макроса `NCURSES_MOUSE_VERSION`, для того чтобы он не компилировался и не линковался на не-ncurses системах.

В настоящее время, события от мыши работают только под `xterm`. В будущем, `ncurses` научится определять присутствие свободного сервера мыши `gpm(1)`, Alessandro Rubini для Linux систем и принимать события от мыши через него.

Работа с мышью очень проста. Чтобы начать работу, используй функцию `mousemask()`, принимающую в качестве первого аргумента битовую маску, в которой указываешь какие события ты хочешь чтобы твоя программа видела. Она возвращает битовую маску событий которые на самом деле будут видимы, которая может отличаться от аргумента, если устройство мыши не способно выдавать некоторые типы событий, которые ты указал.

Как только мышь стала работать, цикл команд твоего приложения должен отслеживать возвращаемые значения `KEY_MOUSE` с помощью `wgetch()`. Когда ты видишь его, то значит событие мыши в очереди. Чтобы вытащить его из очереди, используется функция `getmouse()` (ты должен сделать это перед следующим `wgetch()`, иначе может возникнуть другое событие мыши и сделает первое событие недосягаемым).

Каждый вызов `getmouse()` заполняет структуру (адрес которой ты передал) данными события мыши. Данные события включают координаты указателя мыши в координатах экрана. Они также включают маску события. Биты маски установлены соответственно типу возвращаемого события.

Структура мыши содержит два дополнительных поля, которые могут использоваться в будущем для взаимодействия `ncurses` с новыми свойствами устройств указателей. В дополнение к x и y координатам, есть область памяти для z координаты; она может быть полезна для сенсорных экранов, которые возвращают параметр давления или время нажатия. Есть также поле ID устройства, которое может использоваться для распознавания различных устройств указателей.

Признак видимости событий может быть изменён в любое время с помощью `mousemask()`.<br>
События, которые можно отслеживать:

+ нажатие,
+ отпускание,
+ однократный-, двойной- и тройной-щелчок (ты можешь установить максимальное время удержания клавишы между щелчками).

Если ты не сделаешь щелчки видимыми, то они возвращаются в виде пар нажал-отпустил. В некоторых средах в маску событий могут включаться биты состояния клавиш `shift`, `alt`, и `ctrl` клавиатуры во время события.

Функция также предоставляет информацию в каком окне возникло событие от мыши. Ты можешь использовать это для решения уместно ли реагировать на сообщение из этого окна.

Т.к. события мыши доступны не во всех средах, то было бы глупо строить приложения `ncurses`, которым для работы необходима мышь. Предпочтительно использовать мышь как ссылку для команд укажи-и-нажми в приложениях, которые обычно доступны с клавиатуры. Две тестовых игры в поставке `ncurses` (`bs` и `knight`) содержат код, который демонстрирует как это может быть сделано.

Смотри в man страницах `curs_mouse(3X)` полное описание функций взаимодействия с мышью.

---
[Содержание](#содержание)

#### Завершение

Чтобы убрать после процедур `ncurses` , существует процедура `endwin()`. Она восстанавливает режимы `tty`, которые были до первого вызова `initscr()`, и перемещает курсор в нижний левый угол. Таким образом, всегда после вызова `initscr`, перед выходом, должна вызываться `endwin()`.

---
[Содержание](#содержание)

### Описания функций