# Функции (и указатели)

В этом модуле узнаете про:

+ функции в языке Си, зачем они вообще нужны.
  + как передать значение переменной (копию переменной) в функцию.
  + как в функции изменять значение внешней переменной.
+ переменные
  + почему важна явная инициализация и где ее можно опустить.

[Видео](https://youtu.be/o1cevi2SzME)

[Презентация](/C_for_beginners_Stepik/Files/c2019_2.pdf)

## Галеоны и #define

### Вспомнить все

+ Сначала разберем задачу из прошлого урока про сикли, кнаты, галеоны.
+ Определим константы.
+ Поймем, как не хватает функций.

### Галеоны, сикли, кнаты

Решим задачу из прошлой темы.

У магов свои деньги. В магической Великобритании это кнаты (knut), сикли (sickle) и галеоны (galleon). 1 галеон = 17 сиклей 1 сикль = 29 кнатов

В одном кошельке g1 галеонов s1 сиклей и k1 кнатов.<br>
В другом кошельке g2 галеонов s2 сиклей и k2 кнатов.<br>
Сколько всего денег в кошельках?<br>
Представьте эту сумму, используя минимальное количество монет.

Решение:

+ прочитать входные данные
+ вычислить сумму
+ напечатать результат

Напишем чтение данных и печать результатов.

```c
#include <stdio.h>


int main()
{
    int g1, s1, k1;     // кошелек1
    int g2, s2, k2;     // кошелек2
    int g, s, k;        // кошелек результат


    scanf("%d%d%d", &g1, &s1, &k1);
    scanf("%d%d%d", &g2, &s2, &k2);


    // тут надо написать вычисления
    // кошелек результат = кошелек 1 + кошелек 2


    printf("%d %d %d\n", g, s, k);
    return 0;
}
```

### Как решать?

Мы складываем обычные десятичные числа столбиком с переносом излишков в старший разряд.

```sh
123
+ 89
----
 212
```

Аналогично, можно складывать и галеоны, сикли, кнаты, только система не десятичная, а на основе простых чисел (17 и 29).

Это работает в задаче на сложение, но если мы пишем задачу на вычитание, умножение, деление или перевод в другую валюту по курсу, то вычисления очень сложные. Как проще?

### Считайте в копейках

Для расчета в сложных системах "рубли и копейки" (основание 100), "часы, минуты, секунды" (основание 60, а если еще дни и месяцы, то основание меняется), "футы и дюймы" удобно переводить всю сумму в самые мелкие единицы (копейки, секунды, дюймы), считать в них и только результат представлять в сложных "рублях и копейках".

В банковских и финансовых системах все данные хранятся в копейках.

в компьютере даты хранятся в timestamp - количестве секунд с 1 января 1970 года (эта дата называется Epoch, Эпоха).

Это гарантирует точность (в вычислениях с плавающей точкой будет накапливаться ошибка).

### Считаем в кнатах

Переведем деньги в каждом кошельке в кнаты и посчитаем результат тоже в кнатах. Потом из кнатов переведем обратно в кнаты, сикли, галеоны.

Галеоны переведем в сикли, сложим с сиклями $g_i \cdot 17 + s_i$, всю полученную груду сиклей переведем в кнаты и добавим кнаты из кошелька.

$t_i = (g_i \cdot 17 + s_i ) \cdot 29 + k_i$
​

Обратный перевод:

+ из кучи кнатов отложим сикли (большой кучей)
+ оставшиеся кнаты - в кошелек
+ из кучи сиклей отложим галеоны
+ оставшиеся сикли - в кошелек

```c
int t1, t2, t;  // всего в кнатах в кошелек1, кошелек2, кошелек результат


// переводим все в кнаты
t1 = (g1*17 + s1)*29 + k1;      // кошелек1
t2 = (g2*17 + s2)*29 + k2;      // кошелек2


// считаем сумму
t = t1 + t2;                    // кошелек результат


// переводим t обратно в кнаты, сикли, галеоны
s = t / 29; // из кучи кнатов отложим сикли (большой кучей)
k = t % 29; // оставшиеся кнаты - в кошелек
g = s / 17; // из кучи сиклей отложим галеоны
s = s % 17; // оставшиеся сикли - в кошелек
```

Легко ошибиться в формулах, перепутав 29 и 17 (я уже забыла, где сиклей в галеоне, где кнатов в сикле, я же не гоблин!).

Еще легче опечататься. Если в одном месте будет вместо 29 написано 28, такую ошибку будет очень трудно искать.

Как писать правильно?

### #define

Определим константы с именем через команду препроцессора #define.

```c
#define GALEON 17   // 1 galleon = 17 sickles
#define SICKLE 29   // 1 sickle = 29 knuts
```

и используем их в вычислениях

```c
int t1, t2, t;  // всего в кнатах в кошельках


// переводим все в кнаты
t1 = (g1*GALEON + s1)*SICKLE + k1;      // кошелек1
t2 = (g2*GALEON + s2)*SICKLE + k2;      // кошелек2


// считаем сумму
t = t1 + t2;                    // кошелек результат


// переводим t обратно в кнаты, сикли, галеоны
s = t / SICKLE; // из кучи кнатов отложим сикли (большой кучей)
k = t % SICKLE; // оставшиеся кнаты - в кошелек
g = s / GALEON; // из кучи сиклей отложим галеоны
s = s % GALEON; // оставшиеся сикли - в кошелек
```

Препроцессор сначала удаляет все комментарии.

Потом #define определяет макроподстановку. В программе слово GALEON будет заменено на все, что мы написали до конца этой строки (помним, что комментарии уже удалены!)

Компилятору на вход будет подан код с 17 и 29.

### Вся программа

Типичные ошибки при решении и как найти и исправить:

+ Плохо назвали переменные. k_ и k__ в коде плохо различаются.
  + k1, k2, kres - лучше
+ В scanf при чтении одного кошелька передаются переменные из другого кошелька.
  + после чтения рекомендуем напечатать значения галеонов, сиклей, кнатов в каждом кошельке.
+ ошибки в алгоритме
  + переводить все в общие кнаты кошельков, вычислять в кнатах, результат преобразовывать в галеоны, сикли, кнаты
+ ошибки в написании формул перевода
  + использовать функции для перевода из монет в кнаты и обратно.

```c
#include <stdio.h>


#define GALEON 17   // 1 galleon = 17 sickles
#define SICKLE 29   // 1 sickle = 29 knuts


int main()
{
    int g1, s1, k1;     // кошелек1
    int g2, s2, k2;     // кошелек2
    int g, s, k;        // кошелек результат


    scanf("%d%d%d", &g1, &s1, &k1);
    scanf("%d%d%d", &g2, &s2, &k2);


    // кошелек результат = кошелек 1 + кошелек 2
    int t1, t2, t;  // всего в кнатах в кошельках


    // переводим все в кнаты
    t1 = (g1*GALEON + s1)*SICKLE + k1;      // кошелек1
    t2 = (g2*GALEON + s2)*SICKLE + k2;      // кошелек2


    // считаем сумму
    t = t1 + t2;                    // кошелек результат


    // переводим t обратно в кнаты, сикли, галеоны
    s = t / SICKLE; // из кучи кнатов отложим сикли (большой кучей)
    k = t % SICKLE; // оставшиеся кнаты - в кошелек
    g = s / GALEON; // из кучи сиклей отложим галеоны
    s = s % GALEON; // оставшиеся сикли - в кошелек


    printf("%d %d %d\n", g, s, k);
    return 0;
}
```

### Чего не хватает?

Не хватает функций, как в математике. Хочется написать программу так:

+ читаем сколько монет в первом и втором кошельке,
+ переводим эти монеты в кнаты,
+ переводим сумму кнатов обратно в монеты,
+ печатаем монеты.

```c
#include <stdio.h>


#define GALEON 17   // 1 galleon = 17 sickles
#define SICKLE 29   // 1 sickle = 29 knuts


int main()
{
    int g1, s1, k1;     // кошелек1
    int g2, s2, k2;     // кошелек2
    int g, s, k;        // кошелек результат


    scanf("%d%d%d", &g1, &s1, &k1);
    scanf("%d%d%d", &g2, &s2, &k2);


    // переводим все в кнаты
    int total_knats_1 = money2knats(g1, s1, k1);      // кошелек1
    int total_knats_2 = money2knats(g2, s2, k2);      // кошелек2


    // переводим сумму обратно в кнаты, сикли, галеоны
    // Внимание: псевдокод! Так в Си писать нельзя!!!
    g, s, k = knats2money(total_knats_1 + total_knats_2);


    printf("%d %d %d\n", g, s, k);
    return 0;
}
```

Жизнь с функциями money2knats и knats2money была бы гораздо лучше.

Двинемся вперед, к лучшей жизни с функциями, которые мы __напишем сами__.

Узнаем, что g, s, k = knats2money(t1 + t2); в Си нельзя. В этом и следующем модуле рассмотрим разные варианты как сделать функцию, которая переводит одно значение в сразу несколько.

__Это псевдокод! Так возвращать несколько значений в Си нельзя!!!__

### Пример. Движение тела, брошенного под углом к горизонту

Сначала научимся использовать уже написанные функции языка Си.

Тело брошено под углом α градусов к горизонту со скоростью $v_0$ м/с.

На какую максимальную высоту h метров поднимется тело?

![04](/C_for_beginners_Stepik/Pictures/04_01.png)

Максимальная высота подъема

$h = \dfrac{v_0^2 \cdot sin^2(α)}{2g}$
​
Для вычислений нужно уметь брать значение синуса угла. `sin(a)` - это стандартная функция языка Си. Для ее работы нужно подключить `math.h`

```c
#include <stdio.h>  // нужно для работы функций scanf и printf
#include <math.h>   // нужно для работы функции sin


int main()
{
    double
        a,          // угол к горизонту в ГРАДУСАХ, под которым бросили тело
        v0,         // начальная скорость тела, м/с
        g = 9.81,   // ускорение свободного падения
        h;          // максимальная высота подъема тела


   // h = v0 * v0 * sin(a) * sin(a) / (2 * g);


   // читаем входные данные
   scanf("%lf", &a);
   scanf("%lf", &v0);


   // sin вычисляется от радиан, даны градусы
   // переведем градусы в радианы rad = degree * (M_PI / 180.0)
   // M_PI - число PI, определено в стандартной математической библиотеке
   double arad = a * (M_PI / 180.0);
   h = (v0 * v0 * sin(arad) * sin(arad) / (2 * g));


   printf("Максимальная высота подъема %lf м\n", h);


   return 0;
}
```

Сохраним программу в файл func_sin.c

Компилируем с ключом -lm (library mathematics) для подключения математических функций.

```sh
gcc -Wall -Wextra func_sin.c  -lm
```

Запустим для начальной скорости 10 м/с и угла 0 градусов (ожидаю h=0) и 90 градусов (ожидаю h ~ 10*10/(2*10) - чуть больше 5 метров.

```bash
$ ./a.out
0
10
Максимальная высота подъема 0.000000 м
$ ./a.out
90
10
Максимальная высота подъема 5.096840 м
```

### Информация о стандартных функциях языка C

Как мы узнали, что аргумент sin задается в радианах, а не градусах, и нужно писать `#include <math.h>?`

Можно искать в интернете. Можно в командной строке Linux набрать справку по функции. Наверное, функция синуса будет называться sin. Справка по стандартным функциям языка С лежит в 3 томе справки.

```sh
man 3 sin
```

Для выхода из справки нажмите `q`

Так же можно получить справку по `scanf` и `printf`.

Задание: прочитайте справку о стандартной функции `sqrt`. Она вычисляет квадратный корень из числа.

+ Стандартная функция значит, что имя функции, ее аргументы и что она делает зафиксировано в стандарте языка С. В любом компиляторе должна быть эта функция.
+ Прикладные библиотеки (для графики, аудио, архивации и тп.) - это набор функций. Все функции должны быть документированы.
+ Можно создать свои функции.

### Функции

Функции есть в математике.

$y=sin(x)$

+ имя функции sin
+ у функции есть аргумент (параметр) x
+ функция возвращает значение

Функции есть в языке Си.

+ Реализуем (определим, define) функцию foo, она считает значение выражения $x^2 +2x + 3$.
+ Вызовем (call) функцию foo и вычислим её значения для x=0, x=1 и для произвольного числа, введенного с клавиатуры.

```c
#include <stdio.h>


/* определили функцию с именем foo (имя придумали сами),
Она принимает один аргумент типа float
и возвращает результат типа float
*/
float foo(float x)
{
    float res;
    res = x*x + 2*x + 3;
    return res;     // вернули вычисленное значение
}
// } закончило функцию foo


// main - тоже функция
int main()
{
    float z;
    z = foo(0);    // вызвали функцию foo для x=0
    printf("f(%f) = %f\n", 0., z);


    z = foo(1);    // вызвали функцию foo для x=1
    printf("f(%f) = %f\n", 1., z);


    float a;
    scanf("%f", &a);
    z = foo(a);   // вызвали функцию foo для x=a
    printf("f(%f) = %f\n", a, z);


    return 0;
}
```

Выполнение программы начинается с функции main. main возвращает int. У main нет аргументов.

__Определение и вызов функции:__

```c
тип_возвращаемого_значения имя_функции(аргументы через запятую)
{
    тело функции
}
```

+ __Имя функции__ придумаем сами. Мы придумали foo. Потом будем придумывать более осмысленные имена.
+ __аргументы__ пишем как тип_аргумента имя_аргумента, например float x, имя аргумента придумали сами.
  + для каждого аргумента пишем __тип и имя__
    + float dist(float x1, float y1, float x2, float y2) - нужно так
    + float dist(float x1, y1, x2, y2) - ошибка, тип надо писать у каждого аргумента
  + может быть функция без аргументов int main()
+ __тело функции__ - это код, который выполняется во время вызова функции
+ оператор __return__ возвращает значение из функции. Выходим из функции и выносим из нее результат
  + Значение выражения foo(a) равно тому, что вернул оператор return.
+ __тип_возвращаемого_значения__ - тип того, что вернул оператор return

если функция ничего не возвращает, то пишут тип `void`.

тогда пишут `return` ; - ничего не возвращаем. Это выражение в конце функции можно не писать. Мы и так закончим выполнять функцию.

Объявление одно. Вызовов может быть много. Вызовы функции foo:

```c
z = foo(0);
z = foo(1);
z = foo(a);
```

Короче
В функции foo не обязательно создавать переменную res (или с другим именем). Можно сразу в операторе return написать нужное значение:

```c
float foo(float x)
{
    return x*x + 2*x + 3;     // вернули вычисленное значение
}
```

### Что происходит при вызове функции

```c
float foo(float x)
{
    return x*x + 2*x + 3;     // вернули вычисленное значение
}


int main()
{
    float z, a = 3;
    z = foo(a+2);    // вызвали функцию foo для x=a+2


    return 0;
}
```

```c
z = foo(a+2); выполняется так:
```

+ вычисляется значение аргумента функции, то есть вычисляется чему равно a+2, здесь 5.
+ вызывается foo(5)
  + управление передается в функцию foo
  + создается переменная x - аргумент функции foo, она равна 5.
  + вычисляется x*x + 2*x + 3 (38)
  + return передает управление обратно, в место вызова функции z = foo(a+2);, вместо foo(a+2) подставляется значение, которое вернуло return. Это 38.
+ Выполняется присваивание z = 38;

### Из Цельсия в Фаренгейты

Напишем функцию, которая переводит температуру из градусов Цельсия C в градусы Фаренгейта F по формуле

$F=C \cdot \dfrac{9}{5} + 32$

Сначала сделаем тесты. Берем данные, которые легко проверить без калькулятора.

C | F
-|-
0 | 32
50 | 122
-40 | -40
1 | 33.8

Затем напишем вызовы функции и её проверку.

Рекомендую сначала писать использование функции. Тогда ясно, сколько у нее аргументов, какого типа и что именно должна вернуть функция.

Пусть функция называется fahr. Типы аргументов и возвращаемого значения могут быть разные. Пусть аргумент - градусы Цельсия - будут всегда целыми числами, а возвращаемое значение типа float.

```c
int main()
{
    int cel;    // градусы Цельсия
    float f;    // градусы Фаренгейта


    // тест
    cel = 0;
    f = fahr(cel);
    printf("C = %d, F = %.2f\n", cel, f);


    // для произвольного числа
    scanf("%d", &cel);
    f = fahr(cel);
    printf("C = %d, F = %.2f\n", cel, f);


    return 0;
}
```

Определим функцию:

```c
float fahr(int cel)
{
    float res;
    // тут нужно написать код
    return res;
}
```

Рекомендуем сразу объявлять переменную res с тем же типом, что должна вернуть функция и последним оператором в функции писать return res. Это поможет начинающим не терять, что нужно вернуть из функции.

Дальше пишем реализацию функции:

```c
float fahr(int cel)
{
    float res;
    res = (cel * 1.8) + 32;
    return res;
}
```

Если вы уверенно программируете, можно обойтись без дополнительных переменных:

```c
float fahr(int cel)
{
    return (cel * 1.8) + 32;
}
```

### Полная программа перевода из градусов Цельсия в градусы Фаренгейта

```c
#include <stdio.h>


float fahr(int cel)
{
    float res;
    res = (cel * 1.8) + 32;
    return res;
}


int main()
{
    int cel;    // градусы Цельсия
    float f;    // градусы Фаренгейта


    // тест
    cel = 0;
    f = fahr(cel);
    printf("C = %d, F = %.2f\n", cel, f);


    // для произвольного числа
    scanf("%d", &cel);
    f = fahr(cel);
    printf("C = %d, F = %.2f\n", cel, f);


    return 0;
}
```

### Перевод из градусов Цельсия в градусы Фаренгейта

В задачах на функции часто задают какую функцию надо написать, а остальной код (функция main) для тестирования уже есть в проверяющей системе.

В этой задаче нужно послать на проверку только код функции. В этом случае вы пишете main и проверяете работу функции, но посылаете только часть программы.

__Условие задачи:__

Написать функцию, которая переводит температуру из градусов Цельсия C в градусы Фаренгейта F по формуле

$F=C \cdot \dfrac{9}{5} + 32$

Измерения - в целых числах.

Реализуйте функцию

```c
float fahr(int cel);
```

Для отладки использовать функцию main() и написанную функцию float fahr(int cel)

Для проверки отправлять только функцию!!!

В проверяющей системе уже есть код c main, ваш код (реализация функции) дописывается к нему в единый файл и полученный файл компилируется.

```c
#include <stdio.h>

float fahr(int cel);

int main()
{
    int cel;    // градусы Цельсия
    float f;    // градусы Фаренгейта

    scanf("%d", &cel);
    f = fahr(cel);
    printf("%.2f\n", f);    // .2f - печатать с точностью до 2 знаков после .

    return 0;
}
```

В курсе будет много задач вида "пошлите только реализацию функции". В этом случае вы пишете все необходимые функции вместе с main, отлаживаете их, но посылаете только реализацию требуемой функции. Не ленитесь, делайте так в установленном IDE или текстовом редакторе. Очень плохая практика - писать только требуемую функцию в онлайн редакторе прямо в этой задаче. Это удобно сначала, но потом у вас не будет навыка "написать main и протестировать нужную функцию". Не ленитесь.

```c
float fahr(int cel) {
    return cel * 9 / 5.0 + 32;    
}
```

### Из градусов Фаренгейта в градусы Цельсия

Написать функцию, которая переводит температуру из градусов Фаренгейта F в градусы Цельсия C по формуле

$F=C \cdot \dfrac{9}{5} + 32$

Измерения - в целых числах.

Реализуйте функцию

```c
float celsius(int fahr);
```

Для отладки использовать функцию main() и написанную функцию float celsius(int fahr).

Для проверки отправлять только функцию!!!

```c
float celsius(int fahr) {
    return (fahr - 32) * 5 / 9.0;
}
```

### Тестирование функций

Пишем программу, запускаем несколько раз и вводим тестовые значения

```c
$ ./a.out
50
122.00
$ ./a.out
0
32.00
$ ./a.out
1
33.80
$ ./a.out
-40
-40.00
```

Нашли и исправили ошибку? Запускайте все тесты заново! Очень долго.

Поэтому лень тестировать все снова, пропускают ошибку. У вас есть проверяющая система, она автоматически проверяет все тесты, в большой программе тестировать нужно больше, времени нет, появляется ошибка там, где раньше все работало.

__Пишем несколько вызывов функций и печатаем результат:__

```c
int main()
{
    int cel;    // градусы Цельсия
    float f;    // градусы Фаренгейта


    // тест
    cel = 0;
    f = fahr(cel);
    printf("C = %d, F = %.2f\n", cel, f);   // 0 32


    // тест
    cel = 1;
    f = fahr(cel);
    printf("C = %d, F = %.2f\n", cel, f);   // 1 33.8


    // тест
    cel = -40;
    f = fahr(cel);
    printf("C = %d, F = %.2f\n", cel, f);   // -40 -40


    // для произвольного числа
    scanf("%d", &cel);
    f = fahr(cel);
    printf("C = %d, F = %.2f\n", cel, f);


    return 0;
}
```

Плюсы:

+ запускать 1 раз (быстрее)

Минусы:

+ перед посылкой в проверяющую систему нужно закомментировать тесты /*...*/
+ глазами нужно проверять, что все тесты без ошибки

Как убрать минусы?

### assert

assert выражение

+ Выполняет выражение, если оно истинно, то ничего не печатает, программа выполняется дальше.
+ Если выражение ложно, то печатается диагностика и программа останавливается

```c
#include <stdio.h>      // чтобы работали scanf и printf
#include <assert.h>     // чтобы работал assert


float fahr(int cel)
{
    return (cel * 1.8) + 32;
}
int main()
{
    int cel;    // градусы Цельсия
    float f;    // градусы Фаренгейта


    // тесты
    assert(32 == fahr(0));      // сравнение это ДВА ==
    assert(122 == fahr(50));
    assert(-40 == fahr(-40));
    assert(33.8 == fahr(1));


    // для произвольного числа
    scanf("%d", &cel);
    f = fahr(cel);
    printf("C = %d, F = %.2f\n", cel, f);


    return 0;
}
```

Запуск:

```bash
$ ./a.out
a.out: func_farh.c:27: main: Assertion `33.8 == fahr(1)' failed.
Aborted (core dumped)
```

Тесты для 0, 50, -40 прошли без ошибок, молча.

При ошибке Написали в каком файле, на какой строке какой именно assert оказался неверным. Добавим до assert отладочную печать:

```c
printf("C = %d, F = %.2f\n", 1, fahr(1));
assert(33.8 == fahr(1));
```

получим

```sh
C = 1, F = 33.80
a.out: func_farh.c:28: main: Assertion `33.8 == fahr(1)' failed.
Aborted (core dumped)
```

Видно, что число 33.8 верное, но в программе 33.8 ≠ fahr(1), потому что дробные числа вычисляются и хранятся с некоторой погрешностью.

Дробные числа a и b сравнивают как |a-b| < EPS, где EPS - маленькое число.

"Равно?" для дробных чисел. Как это работает разберем в модуле про условные операторы.

```c
#include <stdio.h>      // чтобы работали scanf и printf
#include <assert.h>     // чтобы работал assert
#include <math.h>       // чтобы работало fabs
#define EPS 0.0001      // требуемая точность сравнения


// сравнивает числа a и b с точностью до EPS
// как это работает, поймем позже
int eps(float a, float b)
{
    return fabs(33.8 - fahr(1)) < EPS;
}


// тут реализация функции fahr


int main()
{
    ...
    assert(32 == fahr(0));              // "равно?" это ДВА ==
    assert(eps(33.8, fahr(1)));         // |a - b| < EPS
    ...
}
```

## Прототипы функций

### Термины

В уроке рассмотрим:

+ Объявление функции (declaration). Оно же прототип функции.
+ Определение функции (definition). Оно же реализация функции.
+ Вызов функции (call).

### Запрещено в языке Си

+ функции с одинаковыми именами, у каждой функции должно быть свое уникальное имя;
+ значения по умолчанию;
+ вложенное определение функций (как в pascal или python).
+ переменное число аргументов (как в printf) научимся писать позже;

Так нельзя:

```c
int main()
{
    // определение функции hi внутри main - ОШИБКА
    void hi() {
        printf("Здравствуйте!\n");
    }
    hi();
    return 0;
}
```

Правильно:

```c
// отдельно hi
void hi()
{
    printf("Здравствуйте!\n");
}
// отдельно main
int main()
{
    hi();
    return 0;
}
```

На самом деле, вложенные функции существуют в некоторых расширениях языка, например, в gcc. Поэтому у вас этот код может скомпилироваться. Но техническая реализация такого синтаксиса в компиляторе вызывает ряд проблем.

### int main()

+ Выполнение программы начинается с функции main. Это точка входа в программу.
+ main возвращает int.
+ У main нет аргументов (пока).

Если в вашей программе нет int main(), то она не скомпилируется, потому что не ясно, откуда начинать выполнять программу.

В функции main пишут return код возврата из программы. Код возврата нужен для:

+ проверяющей системы; если код не 0, то это код ошибки и дальше проверять вашу программу система не будет.
+ других программ, которые используют результаты вашей программы. Например, ваша программа обрабатывает изображения. Следующая программа берет изображения и обрабатывает дальше. Если не остановиться при ошибке вовремя, в конце у вас будут проблемы (нет изображений) и непонятно, в какой из программ произошла ошибка.

Если в учебнике написано void main(), то учат другой язык или автор не профессиональный программист. Так писать нельзя.

### Прототип функции

Сначала мы учимся читать, потом читаем. Сначала учимся ездить на велосипеде, потом катаемся на нем. Сначала объявляем функцию, потом вызываем её.

Реализация функции fahr в программе должна быть выше ее вызова (чтобы компилятор узнал о ней до ее вызова).

Иначе пишем прототип функции (declaration) выше ее вызова, а реализацию функции - в любом месте. Прототип функции нужен компилятору, чтобы узнать:

+ имя функции,
+ тип возвращаемого значения,
+ количество аргументов и их типы.

Прототип получится, если заменить тело функции на ;

```c
float fahr(int cel);    // прототип функции
```

Работает:

```c
#include <stdio.h>


float fahr(int cel);    // прототип


int main()
{
    int cel;
    float f;


    scanf("%d", &cel);
    f = fahr(cel);      // вызов функции
    printf("C = %d, F = %.2f\n", cel, f);


    return 0;
}


float fahr(int cel)     // определение (реализация) функции
{
    return (cel * 1.8) + 32;
}
```

Выше вызова функции должна быть или ее реализация, или ее прототип. Прототип не заменяет реализацию. Где-то эта функция должна быть реализована.

### Имена переменных в прототипе функции

Компьютеру имена аргументов в прототипе не нужны. Можно писать так:

```c
float fahr(int);
```

Принято имена аргументов писать, чтобы человеку было понятно, как вызывать функцию.

Пусть функция ipow вычисляет $x^n$, где x и n целые числа. Результат тоже целое число.

```c
int ipow(int, int);
```

Формально прототип написан верно. Компилятор его понимает. Человек не понимает, надо вызывать вызывать ipow(x, n) или ipow(n, x). Поэтому лучше писать в прототипах идентификаторы аргументов. И комментарий, что делает функция.

```c
int ipow(int x, int n);     // x в степени n
```

### Code style

Нужно красиво оформлять код. Такой код легче читать. Обычно пишут:

+ { и } в начале и в конце функции в первой позиции, больше на этой строке не должно ничего быть,
+ тело функции пишут с отступом,
+ между функциями оставляют пустую строку,
+ перечисляя аргументы после каждой запятой , ставят пробел.

Хорошо:

```c
double distance(int x, int y)
{
    doulbe res = sqrt(x * x + y * y);
    return res;
}
```

Плохо (не надо так):

```c
double distance(int x,int y) {
doulbe res=sqrt(x*x+y*y); return res;
}
```

Имя функции пишем:

+ по имени понятно, что делает функция, например, draw_line
+ одна функция - одно действие; если вы не можете придумать имя функции, то она делает много действий;
+ в имени не должно быть отрицания, хорошо: is_empty, плохо: is_not_empty. Потому что потом мы будем писать выражения с отрицаниями и "not is empty" понятно, а "not is not empty" хорошо только как упражнение по булевой логике и заставляет людей думать (не надо, люди не любят думать).

Стиль идентификатора (переменная или функция)

Имена переменных и функций пишем с маленькой буквы.

Длинное имя можно писать в

+ snake style через _, например, get_size() или line_width,
+ camel style с большими буквами, например, getSize() или lineWidth

Нехорошо смешивать стили в одной программе.

### dist Расстояние между двумя точками

![04](/C_for_beginners_Stepik/Pictures/04_02.png)

Отрезок на плоскости задан двумя точками:
координаты (x1, y1) и (x2, y2) - целые числа.

Написать функцию

```c
float dist(int x1, int y1, int x2, int y2)
{
    код пишем с отступом в 1 табуляцию
}
```

Она вычисляет расстояние между этими точками.

Для вычисления $\sqrt{x}$ используйте функцию sqrt из math.h, не забывайте добавлять -lm при компиляции.

Посылать только реализацию функции dist.

В проверяющей системе уже есть функция main. Её посылать не надо:

```c
#include <math.h>

float dist(int x1, int y1, int x2, int y2);

int main()
{
   int x1, y1, x2, y2;            // координаты точек
   float len;                     // длина

   scanf("%d%d", &x1, &y1);       // прочитали числа
   scanf("%d%d", &x2, &y2);
   len = dist(x1, y1, x2, y2);    // вызываем функцию dist
   printf("%.3f\n", len);         // напечатать длину
   return 0;
}
```

```c
float dist(int x1, int y1, int x2, int y2) {
    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));
}
```

```c
float dist(int x1, int y1, int x2, int y2) {
    return hypotf(x1-x2,y1-y2);
}
```

### geron Формула Герона

Можно вычислить площадь треугольника s по трем его сторонам.

Скопируйте из предыдущей задачи функцию

```c
float dist(int x1, int y1, int x2, int y2);
```

, которая вычисляет расстояние между 2 точками.

Напишите функцию

```c
float area(int x1, int y1, int x2, int y2, int x3, int y3);
```

, которая вычисляет площадь треугольника по 3 точкам по формуле

$S= sqrt{p(p−a)(p−b)(p−c)}$, где $p=(a+b+c)/2$ и a,b,c - длины сторон треугольника.

В функции main напечатайте найденную площадь с точностью до 3 десятичных знаков. Используйте %.3f

Посылать всю программу целиком.

Решения, где функция area не совпадает с требуемым прототипом,
будут дисквалифицированы вручную.

```c
#include <math.h>

float dist(int x1, int y1, int x2, int y2);
float area(int x1, int y1, int x2, int y2, int x3, int y3);

int main()
{
   int x1, y1, x2, y2, x3, y3;            // координаты точек
   float res;                     

   scanf("%d%d", &x1, &y1);               // прочитали числа
   scanf("%d%d", &x2, &y2);
   scanf("%d%d", &x3, &y3);
    
   res = area(x1, y1, x2, y2, x3, y3);    // вызываем функцию area
   printf("%.3f\n", res);                 // напечатать результат
   return 0;
}

float dist(int x1, int y1, int x2, int y2) {
    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));
}

float area(int x1, int y1, int x2, int y2, int x3, int y3) {
    float a = dist(x1, y1, x2, y2);
    float b = dist(x1, y1, x3, y3);
    float c = dist(x3, y3, x2, y2);
    float p = (a + b + c) / 2.0;
    return sqrt(p * (p - a) * (p - b) * (p - c));
}
```

### 6ticket Печать номера билета наоборот

Дано целое шестизначное число (6 цифр). Написать функцию

```c
void print_revers(int x);
```

Она печатает 6 цифр числа x в обратном порядке.

Посылать только реализацию функции.

```c
void print_revers(int x) {
    while(x > 0) {
        printf("%d", x % 10);
        x /= 10;
    }
} 
```

## Переменные локальные и аргументы

### Характеристики переменной

```c
int x = 5;
```

Каждая переменная имеет свое:

+ имя (идентификатор), в примере x;
+ значение (число, которое в ней записано), в примере 5;
+ тип, в примере int;
+ время жизни - время от создания переменной до ее уничтожения;
+ область видимости - где можно обратиться к этой переменной, обычно:
  + от декларации и ниже
  + до конца блока, в котором определена
+ начальное значение - чему равно значение переменной после объявления:
  + явная инициализация int x = 8;
    + это хорошая практика, потому что вы точно знаете чему равна переменная.
  + неявная инициализация, чему равно x после int x;

### Локальные переменные

В примере a и b - локальные переменные.

Локальная переменная - это переменная, определенная внутри блока из { }

+ Область видимости - от декларации до конца блока из { .. }, в котором они определены. В примере - до конца функции main.<br>
Может быть до конца блока if или цикла (узнаем потом).
+ Время жизни - до конца выполнения этого блока.
+ Начальное значение - "мусор" (что было записано в этом месте памяти от предыдущих программ, то и осталось).

```c
int main ( )
{
    int a = 2,  // явно инициализирована, число 2
        b;      // неявно инициализирована, "мусор"
    printf ("%d %d\n", a, b ); // 2 ???
    return 0;
}
```

### Пример локальных переменных

Пример содержит материал следующих уроков. Смогли придумать лучше? Напишите в комментариях к шагу.

Напишем программу, которая вычисляет сумму 5 чисел.

```c
#include <stdio.h>


int main()
{
    int sum;               // начало области видимости sum


    sum = 0;                // попробуем удалить эту строку


    for (int i=0; i < 5; i++) {
        int x;              // начало области видимости x
        scanf("%d", &x);
        sum = sum + x;
    }                       // конец области видимости x
    printf("sum = %d\n", sum);
    return 0;
                            // конец области видимости sum
}
```

+ Нельзя использовать переменную до или после области видимости<br>
Нельзя написать х = 0 до или после цикла. x там не видно.
+ Время жизни. В цикле 5 раз:
  + создается переменная х,
  + в нее читается число scanf("%d", &x),
  + ее значение прибавляется к переменной sum,
  + она разрушается в конце каждой итерации цикла.
+ Начальное значение по умолчанию.

Представим, что в программе нет строки sum = 0.

При создании в локальной переменной sum может лежать любое число

(память под переменную выделили, но не записали в нее 0).

Тогда результат работы программы тоже - любое число.

Довольно часто случайно в локальных переменных может оказаться 0, потому что операционная система может выделить память, заполненную нулями. Завтра эта же программа, запущенная в другом состоянии операционной системы, может иметь ненулевое значение. gcc с парой ключей -Wall -O (буква о большая? включена оптимизация) выдает предупреждение о таких переменных.

__Внимание!__ Если у вас на компьютере "все работает", а на другом компьютере "работает неправильно", проверьте все ли переменные инициализированы.

### Аргументы функции. Передаются по значению

+ Область видимости - вся функция.
+ Время жизни - время выполнения функции.
+ Инициируется значением аргумента при вызове.

```c
int sum(int a, int b)
{
    int res;
    res = a + b;
    return res;
}
```

+ a и b - аргументы функции,
+ res - локальная переменная.

### Почему х не изменилось?

```c
#include <stdio.h>


void inc(int x) {
    x = x + 1;
}


int main() {
    int x;
    x = 3;
    inc(x);
    inc(x);
    printf("%d\n", x);
    return 0;
}
```

В программе 2 разных переменных с одинаковым именем х. Одна переменная х - локальная переменная в функции main. В нее записывается число 3.

При вызове inc(x) вычисляется значение этой х (3) и вызывается inc(3).

При вызове inc(3) создается другая переменная с таким же именем х - аргумент функции inc и в нее записывается значение при вызове (3).

Компилятор их не путает, потому что у аргументов функций и локальных переменных область видимости ограничена.

Значение переменной х функции inc увеличивается на 1. Переменная х в inc равна 4, а другая переменная х в main по-прежнему 3 (ее никто не менял).

При выходе из функции inc переменная х разрушается (время жизни аргумента функции = времени вызова функции).

Управление возвращается в функцию main. Переменная х функции main по-прежнему содержит 3. Увеличивалась на 1 и разрушалась другая переменная (с таким же именем x).

То же самое повторяется с другим вызовом inc(x).

### По значению

Аргументы в функцию передаются по значению (копии). Всегда.

Можно ли значение переменной a изменить в функции inc?

```c
a = a+1; // в inc написать нельзя, так как переменная a локальная в другой функции, main.
```

Вызовем inc(a).

```c
#include <stdio.h>


void inc (int x) {
    x = x + 1;      // x++;
    // a = a + 1;   // нельзя, не видно
}
int main () {
    int a = 3;
    inc (a);
    inc (a);
    printf("%d\n", a); // ??
}
```

![04](/C_for_beginners_Stepik/Pictures/04_04.png)

### Как изменить?

Функция может возвращать новое значение, его можно присвоить a.

```c
#include <stdio.h>


int inc (int x) {
    x = x + 1;
    return x;
}
int main () {
    int a = 3;
    a = inc (a);
    a = inc (a);
    printf("%d\n", a); // 5
}
```

Можно функцию написать короче:

```c
int inc (int x) {
    return x + 1;
}
```

## Изменить значение переменной

__Поменять местами значение 2 переменных:__

Пусть a = 3 и b = 7. Как поменять значение переменных, чтобы a = 7 и b = 3?

Представим, что у нас есть стакан a молока и стакан b сока. Как поменять жидкости в стаканах местами, чтобы в a был сок, а в b молоко?

Очевидно, что надо взять еще один стакан, назовем его t (temporary, временный). Сначала t пустой.

Что делаем | a | b | t
-|-|-|-
начальное состояние | сок | молоко | пустой
Сок из а в t | пустой | молоко | сок
Молоко из b в a | молоко | пустой | сок
Сок из t в b | молоко | сок | пустой

Аналогично напишем код, который меняет значение переменных a = 3 и b = 7:

```c
int a = 3, b = 7, t;


t = a;  // a = 3, b = 7, t = 3
a = b;  // a = 7, b = 7, t = 3
b = t;  // a = 7, b = 3, t = 3
```

### swap

Что будет напечатано?

```c
#include <stdio.h>


void swap(int x, int y) {
    int t;
    t = x;
    x = y;
    y = t;
    printf("x=%d y=%d ", x, y);
}
int main() {
    int a = 3, b = 7;
    swap(a, b);
    printf("a=%d b=%d\n", a, b);
    return 0;
}
```

```sh
x=7 y=3 a=3 b=7
```

### Проблема

Как мы видим, код меняет значение переменных-копий х и y, но не трогает a и b.

Вернуть значение, как мы делали в функции inc(x), тоже не получится. Язык Си не позволяет вернуть из функции более одного значения.

Вернемся к задаче о галеонах, сиклях и кнатах. Напишем функцию, которая из тотальных кнатов вычислит галеоны, сикли и кнаты.

```c
g, s, k = knat2mony(t);
```

Увы, это не язык С. Функция не может вернуть несколько значений. Что делать?

### `& в scanf`

Вернуть - это решение для одной переменной. Изначально мы хотели изменять значения переменных в других функциях. Возможно, мы видели решение проблемы. Посмотрим на чтение и печать переменных.

```c
#include <stdio.h>


int main()
{
    int g1, s1, k1;     // кошелек1
    int g2, s2, k2;     // кошелек2
    int g, s, k;        // кошелек результат


    scanf("%d%d%d", &g1, &s1, &k1);
    scanf("%d%d%d", &g2, &s2, &k2);


    // тут надо написать вычисления
    // кошелек результат = кошелек 1 + кошелек 2


    printf("%d %d %d\n", g, s, k);
    return 0;
}
```

Если функция printf печатает __значения__ переменных, то функция `scanf` __изменяет значения переменных__ g1, s1, k1.

То, что нам нужно. Напишем функцию аналогичную scanf. Для этого узнаем об адресах и указателях на переменные.

## Адреса и указатели

__Адрес - это номер байта:__

Память компьютера можно представить как последовательность ячеек одинакового размера 1 байт, у каждой ячейки есть свой порядковый номер (адрес этого байта).

В байте с адресом 2 хранится число 81.

![04](/C_for_beginners_Stepik/Pictures/04_05.png)

__Байт__ - самая маленькая единица памяти с адресом. Бит еще меньше, но адреса у него нет. В современных архитектурах компьютеров как правило байт - это 8 бит. То есть в каждой ячейке может лежать число от 0 до 255, если мы трактуем набор бит как беззнаковое положительное число, или от -128 до 127, если мы считаем эти биты знаковым числом.

Будем считать, что адреса у нас положительные числа от 0 до самого большого адреса.
Какого? Пусть у нас память 1 Гб, то есть $2^30$ байт, тогда адреса от 0 до 1 073 741 823. Если на адрес отводится 32 бита, то адреса есть только для 4 Гб памяти.

__Многобайтные типы:__

Тип char занимает 1 байт. Другие типы занимают несколько байт. Предположим, что у нас int занимает 4 байта. Тогда три переменные могут располагаться в памяти каждая на своих 4 байтах.

```c
int x, y, z;
```

Они могут идти одна за другой:

![04](/C_for_beginners_Stepik/Pictures/04_06.png)

Или находиться в разных местах памяти.

![04](/C_for_beginners_Stepik/Pictures/04_07.png)

Заметим, что переменная хранится одним куском, а не "часть переменной тут, а оставшаяся часть - там".

Где хранится переменная определяет компилятор. Мы не можем сказать "расположи переменную х точно по адресу 100". Дальше для удобства объяснения мы будем предполагать, где лежит переменная. Например, "переменная х размером 4 байта лежит по адресу 100", полагая, что она расположена в байтах 100, 101, 102, 103. Где лежат старшие байты числа, а где младшие - зависит от архитектуры. Подробнее узнаем, когда будем писать проект эмулятор PDP-11.

Когда переменная лежит в нескольких байтах, адресом переменной будем считать самый маленький адрес ее байта. То есть если переменная лежит в байтах с адресами 100, 101, 102, 103, то адрес переменной 100.

![04](/C_for_beginners_Stepik/Pictures/04_08.png)

Нарисуем ленту памяти "в столбик" по 4 байта на строке. Предположим, что переменная x лежит по адресу 100 (т.е. занимает 4 байта: 100, 101, 102, 103), переменная y по адресу 104, переменная z по адресу 200.

![04](/C_for_beginners_Stepik/Pictures/04_09.png)

### Оператор & взятие адреса

В компьютере вся информация хранится в виде чисел. Изображение - набор чисел, музыка и текст - это тоже набор чисел, которые кодируют изображение, музыку, текст.

В байтах всегда хранятся числа. Один или несколько байт можно трактовать как целое число (знаковое или беззнаковое), число с плавающей точкой, символ. Дальше мы узнаем как хранятся строки и наборы данных.

Адреса - это тоже числа. Их можно вычислять и хранить в переменных.

Оператор & взятие адреса. Знак & называется амперсанд (или амперсенд). Пусть переменная x расположена по адресу 100 и её значение 7:

```c
int x = 7;  // предположим, что х расположено по адресу 100
```

+ Выражение x имеет тип int и значение 7.
+ Выражение &x имеет значение 100.

![04](/C_for_beginners_Stepik/Pictures/04_10.png)

__Тип int * указатель на int:__

Что можно сделать с этим адресом 100? Это число и его можно сохранить в переменной. Назовем переменную px (мнемонично, сокращение от pointer to x). Тип этой переменной указатель на int и обозначается int *. Заметим, название типа состоит из двух частей: int и \*. На слэнге программистов его называют "как пишется", то есть "инт звезда".

```c
int x;      // объявили переменную х типа int
x = 7;      // записали в переменную х значение 7
int * px;   // объявили переменную px типа int *
px = &x;    // вычислили значение адреса переменной х, это 100; записали адрес в переменную px.
```

То есть px имеет тип int * и значение 100.

![04](/C_for_beginners_Stepik/Pictures/04_11.png)

__Оператор * разыменования:__

Имея адрес можно пойти по этому адресу и прочитать или записать значение. Это делается с помощью оператора * разыменование.

Вместо адреса данных мы можем работать с самими данными.

```c
int y = *px + 3;
```

+ px имеет тип int * и значение 100. Это адрес данных.
+ *px имеет тип int; чтобы вычислить его значение, нужно пойти по адресу 100, взять байты, в которых хранится int (мы предположили, что это 100, 101, 102, 103) и прочитать число, лежащее в этих байтах, как int. Получим число 7. Сами данные.
+ \*px + 3 - подставим значение выражения \*px, получим 7 + 3, итого 10.
+ Число 10 запишется в переменную y типа int.

Оператор * - обратный оператору &, мы по адресу находим значение, которое там записано.

```c
*px = 634;    // перейти по адресу 100, взять байты, в которых расположится число типа `int` и записать в эти байты значение `634`
```

Вместо адреса данных px мы работаем с самими данными *px. Можем записать туда.

Так как по адресу 100 расположена переменная х, то тот же самый результат можно добиться написав x = 634;

Как видите, * позволяет не только читать по адресу, но и писать по адресу.

```c
*px = *px + 2;  // теперь в переменной x записано значение 636
```

+ сначала вычислим правую часть выражения от оператора =, найдем значение *px + 2
  + px имеет тип int * и значение 100.
  + *px имеет тип int; чтобы вычислить его значение, нужно пойти по адресу 100, взять байты, в которых хранится int (мы предположили, что это 100, 101, 102, 103) и прочитать число, лежащее в этих байтах, как int. Получим число 634.
  + \*px + 2 - подставим значение выражения \*px, получим 634 + 2, итого 636.
+ разберем выражение слева от оператора = и запишем туда число 636.
  + px имеет тип int * и значение 100.
  + *px имеет тип int; чтобы вычислить его значение, нужно пойти по адресу 100, взять байты, в которых хранится int
  + Число 636 запишется по этому адресу, то есть в переменную x.

![04](/C_for_beginners_Stepik/Pictures/04_12.png)

*Зарисуйте в свой конспект эту схему и пользуйтесь ей!*

__Многоликая звезда:__

Вы уже знаете, что символ * (звезда) используется как:

+ бинарный оператор умножения 2 * 3
+ унарный оператор разыменования *px
+ в составе типа "указатель на" int * px;

__Рисуем в столбик:__

Будем считать, что int и адрес занимает 4 байта. Пожалеем тех, кто проходит курс на мобильных телефонах. Нарисуем расположение переменных в столбик по 4 байта в каждой строке. Адрес пишем слева, значение внутри. "Указывает на" рисуем стрелочкой.

```c
int x = 7;
int * px = &x;
```

Допустим, что переменная x расположена по адресу 100, а переменная px расположена по адресу 240. На рисунке это выглядит так:

![04](/C_for_beginners_Stepik/Pictures/04_13.png)

__Напечатать адрес:__

Для печати адреса применяется формат %p. Адрес печатается в шестнадцатеричном виде. Памяти в компьютере много, поэтому адреса очень большие. Мы в примерах и вопросах пишем маленькие адреса, чтобы вам было удобно понимать и отвечать.

```c
#include <stdio.h>


int main()
{
    int x = 123;
    int * p = &x;
    int ** pp = &p;


    printf("x = %d\n", x);
    printf("p = %p\n", p);
    printf("pp = %p\n", pp);


    return 0;
}
```

## Указатели в аргументах

### Функция изменяет значение переменной

Используем знания об адресах и указателях, чтобы внутри функции изменить значение внешней переменной. В функции hack_bank3 в виде аргумента передаем адрес (то есть копию адреса). В функции к этому адресу применяем оператор * разыменования и оперируем данными, на которые этот адрес указывает.

Пусть в функции main есть 3 кошелька с галеонами, g1, g2, g3. Попробуем другими функциями увеличить количество денег в кошельках.

Функция пытается изменить количество галеонов на 100, 200 или 300.

+ hack_bank1 передаем в функцию аргумент g1 по значению, функция ничего не возвращает, денег в кошельке g1 не прибавилось.
+ hack_bank2 передаем в функцию аргумент g2 по значению, функция возвращает новое значение, сохраняем новое значение в g2.
+ hack_bank3 передаем в функцию указатель на g3, по указателю изменяем значение g3.

```c
#include <stdio.h>


void hack_bank1(int g) {
    g = g + 100;            // изменили копию кошелька, бесполезно
}


int hack_bank2(int g) {
    g = g + 200;
    return g;               // вернули измененное значение
}


void hack_bank3(int *pg) {
                            // по указателю меняем значение
    *pg = *pg + 300;        // или *pg += 300
}


int main() {
    int g1 = 1;
    int g2 = 2;
    int g3 = 3;


    hack_bank1(g1);
    printf("g1 = %d\n", g1);    // 1, богаче не стали


    g2 = hack_bank2(g2);
    printf("g2 = %d\n", g2);    // 202, успех


    hack_bank3(&g3);
    printf("g3 = %d\n", g3);    // 303, успех


    return 0;
}
```

### void inc(int *p)

Еще раз разберем реализацию и вызов функции, которая изменяет значение переменной.
В функции inc будем увеличивать на 1 значение переменной a, которая является локальной переменной функции main.

Пример 1. Не получается изменить значение переменной a. В функцию inc передается копия значения переменной a. Аргумент x равен значению переменной a при вызове, то есть 5. После выхода из функции inc переменная x разрушается, значение переменной a при этом не изменилось, так как это локальная переменная другой функции main и в функции inc напрямую не доступна.

```c
#include <stdio.h>


void inc(int x)
{
    x = x + 1;
}


int main()
{
    int a = 5;
    inc(a);
    inc(a);
    printf("%d\n", a);  // 5


    return 0;
}
```

Пример 2. Чтобы в функции inc можно было изменить значение чужих данных, нужно получить указатель на эти данные (их адрес) в переменной px. Перепишем функцию и её вызов:

```c
#include <stdio.h>


void inc(int * px)
{
    *px = *px + 1;
}


int main()
{
    int a = 5;
    inc(&a);
    inc(&a);
    printf("%d\n", a);  // 7


    return 0;
}
```

#### Приоритет операций

Длинная запись:

```c
void inc(int * px)
{
    *px = *px + 1;
}
```

короче (тоже работает):

```c
void inc(int * px)
{
    *px += 1;
}
```

еще короче (не работает!):

```c
void inc(int * px)
{
    *px++;
}
```

В последнем варианте код компилируется, но при запуске переменная a в функции main не изменяет значение. Почему все сломалось?

Дело в приоритете операций. Операция ++ более приоритетна, чем операция разыменования *. Допустим, переменная a в функции main имеет значение 5 и расположена по адресу 100. Тогда параметр px в функции inc при вызове инициализируется значением 100.

Более приоритетный оператор ++ относится к адресу, то есть адрес в px увеличится (когда-то) на 1 и станет 101. И дальше работает оператор разыменования * к переменной px.

Разыменовали (будем надеяться, что 100, а не 101): пришли по адресу, посмотрели на данные. И больше ничего с данными не делаем, ++ отработал, увеличив значение адреса, а не данных.

Как сделать, чтобы самый короткий вариант заработал? Изменить приоритет выполнения операторов с помощью ()

```c
void inc(int * px)
{
    (*px)++;    // работает!
}
```

### Вызов swap

`void swap(int * px, int * py)` меняет значения переменных, на которые указывают px и py. Функция уже написана. Вам нужно только ее вызвать.

Нужно послать только функцию main. В нее дописать ОДНУ строку - вызов функции swap.

Как используют эту функцию?

```c
#include <stdio.h>

void swap(int * px, int * py);

int main()
{
    int x, y;
    scanf("%d%d", &x, &y);      // если ввели 2 3

    // напишите вызов функции swap

    printf("%d %d\n", x, y);    // то напечатает 3 2

    return 0;
}
```

```c
int main()
{
    int x, y;
    scanf("%d%d", &x, &y);
    swap(&x, &y);
    printf("%d %d\n", x, y);

    return 0;
}
```

### Реализация swap

`void swap(int * px, int * py)` меняет значения переменных, на которые указывают px и py. Напишите и пошлите эту функцию.

Функцию main посылать не нужно.

```c
void swap(int * px, int * py) {
    int tmp = *px;
    *px = *py;
    *py = tmp;
}
```

### Заполняем значение переменных

__scanf и printf:__

Сравним аргументы функций scanf и printf. Читаем 2 целых числа и сразу же печатаем их (фрагмент кода):

```c
int x, y;
scanf("%d%d", &x, &y);
printf("%d %d\n", x, y);
```

+ Первый аргумент у них почти одинаковый - строка, в которой указывается формат чтения / печати.
  + не пишите пробельные символы в форматной строке scanf, он сумеет пропустить пробельные символы перед format placeholder %d;
  + не забывайте \n в конце выводимых данных в printf.
+ Остальные аргументы передаются
  + в printf по значению, так как нам хватит копии переменных, чтобы их напечатать;
  + в scanf передаются указатели на x и y, потому что нужно изменить значение этих переменных внутри функции scanf. Как мы не раз говорили, все аргументы в Си передаются по значению, но в этом случае передается значение адреса данных, то есть указатель.

Таким образом, чтобы заполнить значения переменных x и y мы передаем указатели на них.

__Из тотальных кнатов в кнаты, сикли, галеоны:__

Напишем функцию, которая из большого количества кнатов t посчитает кнаты k, сикли s и галеоны g.

Дано t, его не изменяем, значит передаем t в функцию как int, по значению.

Найти g, s, k. Их значение должно измениться, значит передаем указатели на эти переменные и тип аргумента int *.

Функция ничего не возвращает.

```c
void knat2money(int t, int *pg, int *ps, int *pk) {
    // объявим локальные переменные g, s, k для простой записи формул
    int g, s, k;


    k = t % SICKLE; // осталось кнатов
    s = t / SICKLE; // сиклей большой кучей
    g = s / GALEON;
    s = s % GALEON;


    // по указателям изменим значения переменных g, s, k
    *pk = k;
    *ps = s;
    *pg = g;
}
```

Вызов этой функции:

```c
knat2money(t, &g, &s, &k);  // t без &
```

t передаем значение переменной, &g, &s, &k передаем значения адресов переменных. Во всех случаях передаются значения, только значения разные, для t значение самой переменной, а для &g, &s, &k значения адреса переменной.

Полный код программы

```c
#include <stdio.h>


#define GALEON 17   // 1 galeon = 17 SICKLE
#define SICKLE 29   // 1 SICKLE = 29 knats


int money2knats(int g, int s, int k)
{
    return ((g*GALEON) + s) * SICKLE + k;
}


void knats2money(int t, int *pg, int *ps, int *pk) // pointer to
{
    int g, s, k;    // локальные переменные


    k = t % SICKLE; // осталось кнатов
    s = t / SICKLE; // сиклей большой кучей
    g = s / GALEON;
    s = s % GALEON;


    // по указателям изменим значения переменных
    *pk = k;
    *ps = s;
    *pg = g;
}


int main()
{
    int g1, s1, k1, t1;             // кошелек1
    int g2, s2, k2, t2;             // кошелек2
    int g, s, k, t;                 // кошелек результат


    // читаем входные данные
    scanf("%d%d%d", &g1, &s1, &k1);
    scanf("%d%d%d", &g2, &s2, &k2);


    // из монет - в общее количество кнатов
    t1 = money2knats(g1, s1, k1);
    t2 = money2knats(g2, s2, k2);


    // кошелек = кошелек 1 + кошелек 2
    t = t1 + t2;


    // из общего количества кнатов - обратно в монеты
    knats2money(t, &g, &s, &k);


    // печатаем результат
    printf("%d %d %d\n", g, s, k);


    return 0;
}
```

### min2time - вызов функции

Уже есть функция `void min2time(int mm, int * ph, int * pm)` которая минуты с 0:00 переводит в часы и минуты на 24-часовом циферблате.

Нужно послать только функцию main. В нее дописать ОДНУ строку - вызов функции min2time.

Как используют эту функцию?

```c
#include <stdio.h>


void min2time(int mm, int * ph, int * pm);

int main()
{
    int mm, h, m;
    scanf("%d", &mm);

    // напишите вызов функции min2time

    printf("%02d:%02d\n", h, m);

    return 0;
}
```

```c
int main()
{
    int mm, h, m;
    scanf("%d", &mm);

    min2time(mm, &h, &m);

    printf("%02d:%02d\n", h, m);

    return 0;
}
```

### min2time - реализация функции

Напишите функцию `void min2time(int mm, int * ph, int * pm)` которая минуты с 0:00 переводит в часы и минуты на 24-часовом циферблате.

Посылать нужно только эту функцию.

```c
void min2time(int mm, int * ph, int * pm) {
    *ph = (mm / 60) % 24;
    *pm = mm % 60;
}
```

## `int **`

### Указатель на указатель на `...`

__Где ставить пробел?__

Как правильно писать?

+ int* px;
+ int * px;
+ int *px;

Все написания верные, компилятор понимает все три выражения одинаково.

__На что влияет *:__

Разберем объявление переменных:

```c
int x, y;   // переменные x и y типа int.
```

Заметьте, * влияет только на "ближайшую" переменную:

```c
int * p, w;  // p типа "указатель на int" (int*), w типа int <---- ДА, ЭТО ТАК!
```

Поэтому в написании типа принято прижимать * к имени переменной:

```c
int *p1, *p2;   // p1 и p2 обе типа указатель на int.
```

__Много звезд:__

```c
int x = 7;
int *px = &x;
```

Допустим, х лежит по адресу 100, px лежит по адресу 240.

![04](/C_for_beginners_Stepik/Pictures/04_14.png)

Выражение | Тип | Значение выражения
-|-|-
x | int | 7
&x | int * | 100
px | int * | 100
*px | int | 7
&px | int ** | 240

px - это переменная. Значит, у нее можно вычислить адрес с помощью оператора &. Этот адрес 240. Тип адреса "указатель на тот тип, которым является px", то есть "указатель на указатель на int", записывается как int ** и читается "инт звезда, звезда" или "инт две звезды".

Определим переменную такого типа, чтобы в нее можно было записать адрес переменной px. Назовем ее ppx (pointer to pointer to x).

```c
int ** ppx = &px;   // значение переменной ppx равно 240
```

Выражение | Тип | Значение выражения
-|-|-
ppx | int ** | 240
*ppx | int * | 100
**ppx | int | 7

![04](/C_for_beginners_Stepik/Pictures/04_15.png)

Заметим, каждый оператор * "убирает" один уровень "указатель на ..." в типе.

Итого все переменные:

```c
int x = 7;          // переменная х имеет тип int и значение 7 (пусть она лежит по адресу 100)
int * px = &x;      // переменная pх имеет int* и значение 100 (пусть она лежит по адресу 240)
int ** ppx = &px;   // переменная ppх имеет int** и значение 240 (пусть она лежит по адресу 300)
// распечатаем выражения и их значения; обратите внимание на формат, по которому печатаем
printf("x=%d *px=%d **ppx=%d\n", x, *px, **ppx);    // x=7 *px=7 **ppx=7
printf("&x=%p px=%p *ppx=%p\n", &x, px, *ppx);      // &x=100 px=100 *ppx=100
printf("&px=%p ppx=%p\n", &px, ppx);                // &px=240 ppx=240
```

__Обратите внимание, int печатаем по формату %d, любой указатель печатаем по формату %p.__

У вас, естественно, будут другие адреса, не 100 и 240, а большие и печататься как шестнадцатеричные числа.

Зачем такие нагромождения? Не проще ли было сделать один тип "адрес" и везде его использовать?

Допустим, что у нас есть тип "просто_адрес".

```c
int x = 7;              // допустим, что х лежит по адресу 100
просто_адрес p = &x;    // p = 100
```

Теперь мы программируем операцию разыменования *p. От адреса 100 взять сколько байт? Если 4 байта, то это int, или unsigned int, или это 8 байт, то их трактовать как long long int или double? Недостаточно знать адрес, нужно знать еще данные какого типа хранятся по этому адресу. То есть указатель - это "просто адрес" и информация о типе данных по этому адресу.

#### void *

void * - это тип "просто_адрес".

```c
int x = 7;
int * px = &x;
void * pv = px;     // неявное приведение типа
int * q = pv;       // неявное приведение типа
*q = 66;            // в переменную х запишет значение 66
```

+ Значение типа void * нельзя разыменовать:
  + *pv - ошибка
  + *(int*)pv - хорошо, взяли адрес и добавили информацию о типе явным преобразованием типа
+ К нему неявно приводится любой указательный тип: pv = px;
+ Он неявно приводится к любому указательному типу: px = pv;

#### char \* и double \*

Так как указатель - это не только адрес, но и информация о типе данных по этому адресу, нужно правильно определять тип данных для хранения этих адресов. Чтобы потом оператор разыменования * дал правильные данные.

Правильно:

```c
char c = 12;
double z = 3.14;


char * pc = &c;
double * pz = &z;


// используя указатели можно присвоить новые значения переменным по этим адресам
*pc = 34;       // c = 34
*pz = 1.567;    // z = 1.567
```

Неправильно:

```c
int x = 7;
char * p = &x;
char y = *p;
```

Это пример платформо-зависимого кода. То есть на некоторых платформах (компьютер + ОС + компилятор) будет один результат, 7, а на другой платформе - другой. Программисты стараются не писать платформо-зависимый код. Исключение - код, написанный под конкретную платформу (драйвер, например).

### sizeof

+ Оператор sizeof дает размер переменной или типа в байтах.
+ Результат имеет тип size_t.
+ Напечатать результат можно по формату %zd
+ sizeof(char) всегда 1.
  + В современных архитектурах char обычно размером 1 байт. Поэтому мы будем говорить, что "sizeof вычисляет размер в байтах".

Чему равен sizeof(int)? В стандарте языка об этом не говорится. Размер зависит от архитектуры компьютера, от операционный системы и компилятора.

Как правило в gcc int занимает 32 бита, long long int 64 бита. В других комиляторах int и/или long может быть 64 бита в зависимости от платформы, но gcc на linux использует x86-64 abi, в котором int и long имеет размер 4 байта (32 бита).

```c
int x;
printf("%zd\n", sizeof x);      // 4 в моей системе и на repl.it
printf("%zd\n", sizeof(1 + 2)); // 4 в моей системе и на repl.it
printf("%zd\n", sizeof 3.5);    // 8 в моей системе и на repl.it
printf("%zd\n", sizeof(char));  // 1 всегда
```

Можно писать операнд в скобках sizeof(x) или без них sizeof x. Тип можно указать только в скобках. Поэтому не думайте, пишите все в скобках.

Результат вычисляется во время компиляции, а не выполнения программы. Выражения не вычисляются, а подставляется их тип. То есть вместо sizeof(2+3) вычисляется sizeof(int).

#### Размер указателя

В любом указателе хранится адрес. То есть сколько бит надо на него выделить зависит не от данных, на которые он указывает (char или double), а от размера адресуемой памяти. То есть все типы указателей имеют одинаковый размер.

Они равны:

+ `sizeof(char*)`
+ `sizeof(double*)`
+ `sizeof(int*)`
+ `sizeof(void*)`
+ `sizeof(int**)`
+ `sizeof(int***)`

### Инициализация указателя

Наверное, при решении задач вы уже встречались с проблемой неинициализированных переменных.

```c
#include <stdio.h>
int main()
{
    int x;
    printf("%d\n", x+1);
    return 0;
}
```

x - локальная неинициализированная переменная. В ней хранится "мусор" (любое значение, согласно стандарту). В некоторых компиляторах, например, gcc локальные переменные инициализируют по умолчанию 0 и вы не видите ошибки, потому что всегда печатает 1, а при посылке кода на степик внезапно возникают ошибки.

На разных компьютерах или запуская в разное время, вы получаете разный результат работы. Это называется плавающая ошибка. Её неудобно ловить. Если ошибка исправлена, у вас после тестирования не остается уверенности, что ошибка действительно исправлена, а не "закопана" (убрана диагностика об ошибке) или "уплыла" (может проявиться с меньшей вероятностью и прямо сейчас её не видно).

Неинициализированные указатели тоже могут доставить проблем.

Этот код работает:

```c
#include <stdio.h>
int main()
{
    int x;
    int * px = &x;
    scanf("%d", px);    // тут & не нужен, в px указывает на переменную типа int
    printf("%d\n", x+1);
    return 0;
}
```

Этот код НЕ работает:

```c
#include <stdio.h>
int main()
{
    int x;
    int * px;           // px ни на что не указывает - ошибка
    scanf("%d", px);    // результат ошибки, запись куда-то
    printf("%d\n", x+1);
    return 0;
}
```

`px` содержит какое-то число. Это число трактуется как адрес. По этому адресу scanf пытается записать введенные данные. Нам повезет, если это адрес памяти, куда запрещена запись нашей программе. Тогда она сразу же упадет с ошибкой.

Хуже, если в большой программе указатель будет содержать адрес какой-нибудь переменной (с размером вашей зарплаты, например) и вы испортите лежащие там данные. Такая ошибка будет плавающей, её будет трудно найти.

Поэтому ввели понятие "адреса, который не существует", константы NULL. Как правило его компиляторы определяют как (void*)0 (ноль, приведенный к типу void*. То есть NULL можно присвоить любой переменной типа указатель.

Так как этого адреса не существует, то запись по адресу NULL приводит к падению программы. В хороших ОС и чтение по адресу NULL тоже приводит к падению программы. Логично, если мы "прочитали" по несуществующему адресу, то какой-то мусор и его использование приведет когда-то к ошибке. Её будет трудно искать. Поэтому чем раньше к источнику ошибок (чтение по адресу NULL) её диагностика (программа упала с сообщением, "попытка чтения по несуществующему адресу"), тем легче её поймать.

Простое правило облегчит вам жизнь. Любой указатель при объявлении должен быть инициализирован. Если не знаете чем, инициализируйте его NULL.

```c
int * p1 = NULL;
int * p2 = 0;
```

Забегая вперед: код, который проверяет, что указатель НЕ инициализирован:

```c
if (p1 == NULL)
    printf("Указатель p1 не инициализирован\n");
```

или

```c
if (!p1)
    printf("Указатель p1 не инициализирован\n");
```

Первый вариант с `NULL` мне нравится больше, потому что лучше читается. Во втором я не всегда замечаю !, если шрифт мелковат.

Указатели на уже несуществующие данные называются __висячими указателями__ (dangling pointers).

## Геометрические задачи

### mirror Отобразить точку

Написать и использовать функцию

```c
void mirror(int *px, int *py);
```

которая зеркально отображает точку с координатами (x,y) относительно оси Y.

Послать всю программу, и функцию mirror, и функцию main.

Input format: 2 целых числа через пробел - x и y координаты точки до отображения.

Output format: 2 целых числа через пробел - x и y координаты точки после отображения.

```c
#include <stdio.h>

void mirror(int *px, int *py);

int main()
{
    int x, y;
    scanf("%d%d", &x, &y);
    
    mirror(&x, &y);
    
    printf("%d %d", x, y);
    return 0;
}

void mirror(int *px, int *py) {
    *px *= -1;
}
```

### mirror_seg Отобразить отрезок

Написать и использовать функцию

```c
void mirror_seg(int *px1, int *py1, int *px2, int *py2);
```

которая зеркально отображает отрезок с концами (x1,y1) и (x2,y2) относительно оси X.

Послать всю программу, и функцию mirror_seg, и функцию main.

Input format: 4 целых числа через пробел - x1 y1 x2 y2 - координаты концов отрезка до отображения.

Output format: 4 целых числа через пробел - x1 y1 x2 y2 - координаты концов отрезка после отображения.

```c
#include <stdio.h>

void mirror_seg(int *px1, int *py1, int *px2, int *py2);

int main()
{
    int x1, y1, x2, y2;
    scanf("%d%d", &x1, &y1);
    scanf("%d%d", &x2, &y2);
    
    mirror_seg(&x1, &y1, &x2, &y2);
    
    printf("%d %d %d %d", x1, y1, x2, y2);
    return 0;
}

void mirror_seg(int *px1, int *py1, int *px2, int *py2) {
    *py1 *= -1;
    *py2 *= -1;
}
```

### move Сдвиг точки

Написать и использовать функцию

```c
void move(int *px, int *py, int dx, int dy);
```

которая сдвигает точку с координатами (x,y) на dx и dy.

Послать всю программу, и функцию move, и функцию main.

Input format: 4 целых числа через пробел - x y dx dy - координаты точки до отображения и параметры сдвига.

Output format: 2 целых числа через пробел - x y - координаты точки после отображения.

```c
#include <stdio.h>

void move(int *px, int *py, int dx, int dy);

int main()
{
    int x, y, dx, dy;
    scanf("%d%d", &x, &y);
    scanf("%d%d", &dx, &dy);
    
    move(&x, &y, dx, dy);
    
    printf("%d %d", x, y);
    return 0;
}

void move(int *px, int *py, int dx, int dy) {
    *px += dx;
    *py += dy;
}
```

### center Центр прямоугольника

Прямоугольник со сторонами параллельными осям Х и Y задан координатами верхней левой (xlt,ylt) и правой нижней точки (xrb, yrb).

Найти координаты центра прямоугольника. Гарантируется, что это будет точка в целых координатах.

Написать и использовать функцию, которая по координатам левой верхней и правой нижней точки находит координаты центра.

```c
void center(int xlt, int ylt, int xrb, int yrb, int *pxc, int *pyc);
```

Input format: 4 целых числа через пробел - xlt ylt xrb yrb - координаты вершин прямоугольника.

Output format: 2 целых числа через пробел - x y - координаты центра прямоугольника.

Послать всю программу, и функцию center, и функцию main.

```c
#include <stdio.h>

void center(int xlt, int ylt, int xrb, int yrb, int *pxc, int *pyc);

int main()
{
    int xlt, ylt, xrb, yrb, xc, yc;
    scanf("%d%d", &xlt, &ylt);
    scanf("%d%d", &xrb, &yrb);
    
    center(xlt, ylt, xrb, yrb, &xc, &yc);
    
    printf("%d %d", xc, yc);
    return 0;
}

void center(int xlt, int ylt, int xrb, int yrb, int *pxc, int *pyc) {
    *pxc = (xlt + xrb) / 2;
    *pyc = (ylt + yrb) / 2;
}
```

### rotateC Поворот вокруг центра

Прямоугольник со сторонами, параллельными осям, задан координатами двух точек - левой верхней и правой нижней.

Написать и использовать функцию

```c
void rotateC(int *x1, int *y1, int *x2, int *y2);
```

которая поворачивает прямоугольник на 90 градусов вокруг его центра (пересечения диагоналей).

Гарантируется, что тесты будут оставлять прямоугольник после поворота в целых координатах. Ничего округлять не нужно.

Input format: 4 целых числа через пробел - xlt ylt xrb yrb - координаты вершин прямоугольника до поворота.

Output format: 4 целых числа через пробел - xlt ylt xrb yrb - координаты левой верхней и правой нижней вершины прямоугольника после поворота.

Подсказка: кто-то знает математику, а кто-то сдвигает прямоугольник так, чтобы центр был в точке (0,0), поворачивает его и сдвигает его центр на прежнее место.

Послать всю программу, и функцию rotateC, и функцию main.

```c
#include <stdio.h>

void rotateC(int *x1, int *y1, int *x2, int *y2);

void center(int xlt, int ylt, int xrb, int yrb, int *pxc, int *pyc);


int main()
{
    int x1, y1, x2, y2;
    scanf("%d%d", &x1, &y1);
    scanf("%d%d", &x2, &y2);
    
    rotateC(&x1, &y1, &x2, &y2);
    
    printf("%d %d %d %d", x1, y1, x2, y2);
    return 0;
}

void rotateC(int *x1, int *y1, int *x2, int *y2) {
    int xc, yc;
    center(*x1, *y1, *x2, *y2, &xc, &yc);
    
    int rx1 = *y2 - yc;
    int ry1 = *x2 - xc;
    int rx2 = *y1 - yc;
    int ry2 = *x1 - xc;
     
    *x1 = rx1 + xc;
    *y1 = ry1 + yc;
    *x2 = rx2 + xc;
    *y2 = ry2 + yc;
}

void center(int xlt, int ylt, int xrb, int yrb, int *pxc, int *pyc) {
    *pxc = (xlt + xrb) / 2;
    *pyc = (ylt + yrb) / 2;
}
```

## Глобальные и static

### Глобальные переменные

__Глобальные переменные__ - это такие переменные, время жизни которых распространяется на всю программы. Декларируются такие переменные вне функций.

+ Область видимости - от декларации до конца файла.
  + область видимости можно расширить на другие файлы с помощью extern,
  + поэтому принято объявлять глобальные переменные до объявления каких-либо функций.
+ время жизни - время жизни всей программы.
+ начальное значение по умолчанию - ноль.

__Внимание!__ нельзя вне функций написать x = 5 или scanf("%d", &x), только явно задать значение при объявлении переменной.

```c
#include <stdio.h>


int x = 5;  // это глобальная переменная х


void foo() {
    x = x + 1;
}


int main() {
    foo();
    foo();
    printf("x=%d\n", x);
    return 0;
}
```

### Изменение глобальной переменной

Что будет напечатано?

```c
#include <stdio.h>


int x = 5;


void foo() {
    x = x + 1;
}


int main() {
    foo();
    foo();
    printf("%d\n", x);
    return 0;
}
```

```sh
7
```

### Почему 7?

```c
#include <stdio.h>


int x = 5;      // глобальная переменная


void foo() {
    x = x + 1;  // доступ к глобальной переменной
}


int main() {
    foo();
    foo();
    printf("x=%d\n", x);    // глобальная х
    return 0;
}
```

+ Переменная х одна. При создании в нее записали число 5.
+ При вызове foo эта глобальная переменная увеличивается на 1 (стало 6).
+ При следующем вызове увеличивается еще на 1 (стало 7).
+ Дальше идет печать этой же переменной х (печатаем 7).

### Изменение глобальной переменной 2

Что будет напечатано?

```c
#include <stdio.h>


int x;  // неявная инициализация


void foo() {
    x = x + 1;
}


int main() {
    foo();
    foo();
    printf("%d\n", x);
    return 0;
}
```

```sh
2
```

### Почему?

Глобальная int x неявно инициализируется 0. Потом 2 раза увеличивается на 1. Печатается 2.

### Переменные static

Статические переменные похожи на глобальные переменные в том смысле, что время их жизни распространяется до конца выполнения программы. Но область видимости ограничена.

Такие переменные объявляются с ключевым словом static.

```c
static int x;
```

В отличие от глобальных переменных, статические переменные можно объявлять как вне функций, так и внутри любой функции или блока.

+ Область видимости:
  + Внутри функции или блока: до конца функции или блока (такая же, как у локальных переменных).
  + Вне функций: от декларации до конца файла.
    + область видимости нельзя расширить на другие файлы с помощью extern,
    + так как область видимости статических переменных ограничена, то можно объявлять разные статические переменные с одним и тем же именем в разных областях видимости (например, в разных файлах одной программы или в разных блоках).
+ время жизни - время жизни всей программы.
+ начальное значение по умолчанию - ноль.
+ инициализируется один раз.

### Инициализация локальной переменной

Что будет напечатано? Введите 2 числа через 1 пробел. Проверка чувствительна к пробелам.

```c
#include <stdio.h>


void foo() {
    int x = 2;
    x = x + 1;
    printf("%d ", x);
}


int main() {
    foo();
    foo();
    return 0;
}
```

```sh
3 3
```

### Статическая переменная

Что будет напечатано?

```c
#include <stdio.h>


void foo() {
    static int x;  // неявная инициализация
    x = x + 1;
    printf("%d ", x);
}


int main() {
    foo();
    foo();
    return 0;
}
```

```sh
1 2
```

### Почему? 2

Переменная инициализируется неявно 0. Значит сначала напечатает 1.

Переменная х не уничтожается в конце функции. Ее время жизни равно времени жизни программы.

Первый вызов foo закончится, когда x=1.<br>
Переменная сохранится.<br>
В начале второго вызова foo х=1 и станет 2.<br>
Ответ: 1 2

```c
#include <stdio.h>


void foo() {
    static int x;  // неявная инициализация
    x = x + 1;
    printf("%d ", x);
}


int main() {
    foo();
    foo();
    return 0;
}
```

### Явная инициализация статической переменной

Что будет напечатано?

```c
#include <stdio.h>


void foo() {
    static int x = 2;  // явная инициализация
    x = x + 1;
    printf("%d ", x);
}


int main() {
    foo();
    foo();
    return 0;
}
```

```sh
3 4
```

### Почему? 3

+ Переменная инициализируется явно 2. Значит сначала напечатает 3.

+ Переменная х не уничтожается в конце функции. Ее время жизни равно времени жизни программы.
  + Первый вызов foo закончится, когда x=3.
  + Переменная сохранится.
+ переменная инициализируется один раз - при создании, в начале работы программы, а не при первом вызове foo. Значит, при втором вызове x=2 не срабатывает.
  + В начале второго вызова foo х=3 и станет 4.
+ Ответ: 3 4

```c
#include <stdio.h>


void foo() {
    static int x = 2;  // создается в начале выполнения программы
    x = x + 1;
    printf("%d ", x);
}


int main() {
    foo();
    foo();
    return 0;
}
```

### Использование глобальных и статических переменных

Глобальные переменные видны во всем проекте, и их не стоит использовать без нужды.

Два программиста решили объявить глобальные переменные. Один назвал свою переменную total_counter, второй тоже решил назвать свою переменную total_counter. Их проект не компилируется. Трудно договориться с другими разработчиками об уникальных именах глобальных переменных.

Сначала вы радуетесь, что не надо передавать переменную в аргументах функции и возвращать значение, а потом долго ищете кто, где и как изменил переменную в программе, если вот тут она имеет еще правильное значение, а тут - уже нет. Приходится смотреть все вызываемые функции - записывали они в эту переменную или нет. Это очень неудобно, если у вас большой проект из многих файлов. Или вашу библиотеку используют и пользователь библиотеки устанавливают значение переменной g (ускорение свободного падения) в -10, если вы сделали ее глобальной переменной. На вашей планете теперь царит антигравитация и самолет летит хвостом вперед.

Пример хорошего использования глобальной переменной - errno. При работе с функциями (например, открытия файла), она содержит номер ошибки (например, нет такого файла). Это часть интерфейса работы с другими функциям.

"Ужасность" глобальной переменной можно снизить, ограничив доступ к ней всего одним файлом, то есть использовать ключевое слово static. Если вы пишите библиотеку, то "ваше личное ускорение свободного падения" будет доступно только внутри одного файла программы, то есть только вам. Хорошо в этом случае написать функции set_g и get_g для контролируемого изменения этой переменной.

Переменные static внутри функции нужны, когда нужно сохранять информацию между вызовами функции (не надо это делать в глобальных переменных!). Напишем функцию, которая возвращает следующее свободный id.

```c
unsigned int get_free_id()
{
    static int id = 1;
    return id++;
}
int main()
{
    // пользователи Alex, Olya и Gleb получили свои уникальные id
    unsigned int alex_id = get_free_id();       // 1
    unsigned int olga_id = get_free_id();       // 2
    unsigned int gleb_id = get_free_id();       // 3


    return 0;
}
```

С помощью такой переменной можно посчитать сколько раз вызывали функцию.

```c
void hello()
{
    static int counter;
    counter++;
    printf("Я сказал Hello уже %d раз.\n", counter);
}
int main()
{
    hello();        // Я сказал Hello уже 1 раз.
    hello();        // Я сказал Hello уже 2 раз.
    hello();        // Я сказал Hello уже 3 раз.
    hello();        // Я сказал Hello уже 4 раз.


    return 0;
}
```

## `#define`

### Препроцессор

Текст программы до компилятора обрабатывается препроцессором. Он делает поиск текста и его замену.

![04](/C_for_beginners_Stepik/Pictures/04_16.svg)

+ Директивы препроцессора начинаются с #

Пример директив препроцессора в программе:

```c
#include <stdio.h>
#define N 100
```

Между # и директивой (include, define или другой) можно написать любое количество пробельных символов. Принято, если нужно поставить отступы, ставить их не в начале строки, а после #.

Этот пример станет понятнее после следующего раздела про условную компиляцию:

```c
#ifdef __linux__
#   define MY_PI_CONTANT 5
```

### `#include`

__#include имя_файла:__

Заменяет эту строку на содержимое файла имя_файла.

В этом файле пишут прототипы функций и макросы, подробнее изучим позже.

В файле math.h содержатся прототипы функций sin и cos, макрос M_PI (число Пи).

+ #include <stdio.h> - обычно указывают стандартные библиотеки, имя файла ищется последовательно в:
  + системных директориях,
  + указанных с ключом -I (i большое, от include) при компиляции в командной строке
+ #include "myfile.h" - свой проект, имя файла ищется последовательно в:
  + текущей директории запуска gcc,
  + указанных с ключом -I (i большое, от include) при компиляции в командной строке
  + системных директориях.

### #define 2

__#define идентификатор текстовая_замена:__

Заменяет идентификатор на все содержимое до конца строки.

Называется макроподстановка или макрос.

```c
#define A 3
x = A + x;
```

Не ставьте в конце ;

```c
#define A 3;    // поставили ; в конце
x = A + x;      // заменилось на x = 3; + x; - ошибка компиляции
```

+ Идентификатор пишем по правилам идентификатора:
  + символ _
  + латинские буквы
    + __Стилистически принято идентификаторы макроподстановок писать только большие буквами__
  + цифры (не могут быть первым символом)

### Макрос с аргументами

В Си нельзя объявлять функции с одинаковыми именами и нужно объявлять тип аргумента и возвращаемого значения.

Хотим написать функцию, которая вычисляет ∣x∣. Какой должен быть тип аргумента и возвращаемого значения, чтобы функция не внесла погрешность в значение x?

+ float, double - можем внести погрешность для целых чисел,
+ int - маловат для unsigned long long int,
+ unsigned long long int - точно не нужна, ибо всегда положительное число.

Получаем стандартные функции языка Си abs, labs, llabs, imaxabs, fabs.

Другой способ написать простое вычисление модуля числа не зависимо от типа - макросы с параметрами.

Напишем вычисление $x^3$ в виде макроса.

```c
#define cube(x) x*x*x
```

Вызов выглядит так же, как для функции. Но реально это замена текста препроцессором, на этапе компиляции код будет y = 2*2*2;

```c
y = cube(2);    // y = 2*2*2;
```

### Отличия макроса и функции

Функция | Макрос
-|-
компилируется в вызовы функции | подстановка препроцессором текста макроса в код
типы аргументов и возвращаемого значения | типов нет
увеличивает время выполнения | увеличивает время сборки проекта (работа препроцессора)

В макросах труднее искать ошибки. Где можно ошибиться в x*x*x?

### Поставь скобки у каждого аргумента

```c
y = cube(2+3);  // y = 2+3*2+3*2+3;
```

Получим 17. Как исправить? Поставим скобки, чтобы изменить приоритет операций (2+3)*(2+3)*(2+3):

```c
#define cube(x) (x)*(x)*(x)
```

У функции такой ошибки быть не может.

### Поставь скобки вокруг всего макроса

```c
#define sum(a,b)    (a)+(b)
```

Вычислим sum(1, 4)*3;. Ожидаем 15.

Получаем (1)+(4)*3, 13.

Как исправить? Поставьте скобки вокруг всего макроса.

```c
#define sum(a,b)    ((a)+(b))
```

sum(1, 4)*3; будет ((1)+(4))*3, то есть 15.

У функции такой ошибки быть не может.

### Не используй `++` и `--`

Много скобок не гарантирует правильной работы.

```c
int x = 2;
printf("%d\n", x++); // 2
printf("%d\n", x);   // 3
printf("%d\n", ++x); // 4
printf("%d\n", x);   // 4
int x = 2;
int y = ++x + ++x;
printf("x=%d y=%d\n", x, y);   // ???
```

Операция `++` изменит значение x, но гарантирует это только к sequence point (концу всего выражения), то есть к ; или , или && или ||. Скобки никак не влияют.

Иначе неопределенное поведение (undefined behavior) и значение всего выражения по стандарту может быть любым.

Подробнее читайте в порядок вычислений

Использование `++` в аргументах макроса может привести к неопределенному поведению.

```c
#define cube(a)    ((a)*(a)*(a))


int y, x = 2;
y = cube(++x);    // y = ((++x)*(++x)*(++x)); - undefined behavior
```

В функциях таких проблем нет.

### Не делайте вызовы функции в аргументах макроса

Стандартная функция getchar() читает 1 символ с ввода (клавиатуры) и возвращает его код (подробнее расскажем позже).

```c
// макрос
#define cube(a)    ((a)*(a)*(a))


// функция
int cube_func(int a)
{
    return a*a*a;
}
```

+ cube(getchar()) - вызовет getchar() 3 раза и захочет прочитать 3 символа
+ cube_func(getchar()) - вызовет getchar() 1 раз при вычислении значения аргумента функции cube_func

В функциях таких проблем нет.

Как вы поняли, с макросами проблем может быть гораздо больше, чем с функциями. Поэтому принято идентификаторы макросов писать большими буквами. Исключение: название некоторых стандартных макросов/функций, например, getchar (стандарт не указывает, как именно нужно его реализовывать, в одном компиляторе он может быть реализован как макрос, а в другом - как функция).

### Длинный макрос в несколько строк

Макрос можно написать в несколько строк, если экранировать перевод строки символом \

```c
#define QUADP(a, b, c) ((-(b) + sqrt((b) * (b) - 4 * (a) * (c))) / \
                                    (2 * (a)))
```

Можно использовать вложенные макросы:

### Один макрос использует другой

Один макрос может использовать другой макрос.

```c
#define DETERMINANT(a,b,c)  sqrt((b) * (b) - 4 * (a) * (c))
#define QUADP(a, b, c) ((-(b) + DETERMINANT(a,b,c)) / (2 * (a)))
#define QUADM(a, b, c) ((-(b) - DETERMINANT(a,b,c)) / (2 * (a)))
```

### Встроенные макросы

Есть стандартные макросы:

Макрос | Что подставят вместо него
-|-
__LINE__ | номер текущей строки в коде программы
__FUNCTION__ | имя выполняемой функции
__FILE__ | имя файла с текстом программы

Пусть этот код написан в файле hello.c на 5 строке файла в функции main:

```c
printf("%s %d: %s\n", __FILE__, __LINE__, __FUNCTION__);
```

Он напечатает hello.c 5: main

## Условная компиляция

### Как удобно отправлять задачи в проверяющую систему

Некоторые задачи требуют, чтобы посылали только реализацию функции, а не всю программу.

Пусть требуется послать реализацию функции int inc(int x), которая возвращает x+1.

+ Хотим писать всю программу (с main и тестами).
+ Неудобно мышкой выделять часть кода и копировать в проверяющую систему (потеряли #, последнюю }, каждый вспомнит хотя бы одну такую ошибку).
+ Без main не компилируется локально.
+ С main - ошибка компиляции в проверяющей системе.

Хотим написать программу, чтобы она и компилировалась локально, и можно было весь файл посылать на проверку.

### Условная компиляция 2

Кроме определения макроса как

```c
#define N 100
```

можно просто определить макрос, что он вообще есть. Где это используется?

Например, часть кода программы зависит от операционной системы. Тогда пишем:

```c
#define _WIN64
#ifdef __linux__ // или #if defined (__linux__)
много кода, который будет работать в Linux
#elif defined (_WIN64)
много кода для 64-битной Windows
#else
printf ("Какая у вас операционная система?\n");
#endif
```

В зависимости от того, какое условие верное, определен _WIN64 или __linux__, в программе останется один или другой участок кода. Если не один из проверяемых макросов не определен, останется код от #else до #endif.

Обязательными в этой конструкции являются части #ifdef и #endif. Все остальное можно опустить.

### В наших программах

Определим макрос с именем, которого точно не будет в проверяющей системе. Например, AAA и пишем main с условной компиляцией:

```c
#define AAA                 // определили макрос ААА


#ifdef AAA                  // если ААА есть, то включаем код:
#include <stdio.h>
#include <assert.h>


int inc(int x);


int main()
{
    assert(inc(2) == 3);
    assert(inc(-2) == -1);
    return 0;
}
#endif                      // включаем до этой строки


// Код дальше есть всегда:


int inc(int x)
{
    return x + 1;
}
```

Локально запускаем этот код, AAA определен, значит локально до компилятора доходит код с main.

Перед посылкой в проверяющую систему закомментируем строку

```c
//#define AAA       // теперь этот макрос не определен
```

В проверяющей системе такого макроса нет (мы для этого придумывали нелепое имя, которое точно не встретится на сервере). Там компилятору придет код без куска от #ifdef до #endif:

```c
int inc(int x)
{
    return x + 1;
}
```

### Еще удобнее (аргументы командной строки)

Можно не определять AAA в коде программы, комментируя и раскомментируя строку с #define.

При компиляции укажите gcc ключ -D с аргументом AAA. То есть для файла hello.c:

```c
gcc -Wall -Wextra -DAAA hello.c
```

Ключ -D с аргументом AAA определяет макрос AAA, то есть работает, как #define AAA.

Локально вы указываете при компиляции этот ключ, а на сервере компилируются без этого ключа.

Строку #define AAA в коде программы указывать не нужно.

```c
#ifdef AAA
#include <stdio.h>
#include <assert.h>


int inc(int x);


int main()
{
    assert(inc(2) == 3);
    assert(inc(-2) == -1);
    return 0;
}
#endif


int inc(int x)
{
    return x + 1;
}
```

### Полная и краткая формы

Если определен макрос BBB

```c
#ifdef BBB          // краткая форма
#if defined BBB     // полная форма
#if defined (BBB)   // полная форма
```

Если НЕ определен макрос BBB

```c
#ifndef BBB          // краткая форма
#if !defined BBB     // полная форма
#if !defined (BBB)   // полная форма
```

### Еще немного про цепочки условий

Проверяем определение разных макросов:

```c
#if defined FOO
    x = 2;
#elif defined BAR
    x = 3;
#endif
```

Проверяем значение макроса:

```c
#include <stdio.h>


#define HAPPY_FACTOR 1


int main(void)
{


#if HAPPY_FACTOR == 0
    printf("I'm not happy!\n");
#elif HAPPY_FACTOR == 1
    printf("I'm just regular\n");
#else
    printf("I'm extra happy!\n");
#endif


    printf("OK!\n");
}
```

### `#undef`

Если нам не нужен определенный макрос, например, BBB, то можно написать

```c
#undef ВВВ
```

### time2minMacro h, m в минуты с полуночи

Напишите макрос time2min(h,m), который из часов и минут вычисляет минуты с 0:00.

Использование макроса: mm = time2min(1, 25);

При проверке будет использован следующий код:

```c
int h, m, mm;
scanf("%d:%d", &h, &m);

mm = time2min(h, m);
printf("%d\n", mm);

mm = time2min(h, m)*2;
printf("%d\n", mm);

mm = time2min(h+1, m+5);
printf("%d\n", mm);
```

```c
#define time2min(h,m)    ((h) * 60 + (m))
```

### min2timeMacro минуты с полуночи в h, m

Напишите макрос min2time(mm,h,m), который из mm минуты с 0:00 вычисляет часы h и минуты m для циферблата часов.

Использование макроса: min2time(125, hres, mres);

При проверке будет использован этот код:

```c
int h, m, mm;
scanf("%d", &mm);

min2time(mm, h, m);
printf("%02d:%02d\n", h, m);

min2time(mm+65, h, m);
printf("%02d:%02d\n", h, m);
```

```c
#define min2time(mm, h, m) (h = ((mm) / 60) % 24), (m = (mm) % 60) 
```

## Рекурсивный вызов функций

### Рекурсия в математике

Факториал $n!$ может быть задан рекуррентной формулой:

![04](/C_for_beginners_Stepik/Pictures/04_17.png)

Напишем функцию, вычисляющую факториал, пользуясь этим определением.

Функция, которая вызывает саму себя, называется рекурсивной.

```c
#include <stdio.h>


int fact (int n) {
    int res = n * fact (n-1);       // из fact вызывается fact - рекурсия
    return res;
}
int main ( ) {
    printf("4! = %d\n", fact(4));   // из main вызывается fact
    return 0;
}
```

Однако, при запуске программы получаем

```sh
Segmentation fault (core dumped)
```

Что случилось?

Для простоты чтения кода везде будем использовать тип int. В задачах, однако, стоит подумать - какие типы стоит использовать, чтобы вычислить максимально представимый факториал.

### Что хотим получить?

![04](/C_for_beginners_Stepik/Pictures/04_18.png)

### Как работает рекурсивный вызов функции

Рассмотрим код функции, добавив в нее отладочную печать:

```c
int fact (int n) {
    printf("call fact(%d)\n", n);
    int res = n * fact (n-1);           // из fact вызывается fact - рекурсия
    printf("return %d! = %d\n", n, res);
    return res;
}
```

Запустим код и получим:

```c
call fact(4)
call fact(3)
call fact(2)
call fact(1)
call fact(0)
call fact(-1)
call fact(-2)
call fact(-3)
```

и так далее, все дальше углубляясь в отрицательные числа. Почему так происходит?

Что происходит при вызове из функции main этой функции fact(4)?

+ при выполнении кода fact(4)
  + управление передается в функцию fact,
  + создаются новые переменные n = 4 и неинициализированная локальная переменнаяres. Они будут уничтожены, когда закончится выполнения этого вызова функции.
  + начинает выполняться код n * f(n-1),
+ при выполнении кода fact(n-1) при n = 4 выполняется вызов fact(3), то есть:
  + управление передается в функцию fact,
  + создаются новые переменные n = 3 и неинициализированная локальная переменнаяres. Они будут уничтожены, когда закончится выполнения этого вызова функции.
  + начинает выполняться код n * f(n-1),
+ ...
+ при выполнении кода fact(0)
  + управление передается в функцию fact,
  + создаются новые переменные n = 0 и неинициализированная локальная переменнаяres. Они будут уничтожены, когда закончится выполнения этого вызова функции.
  + начинает выполняться код n * f(n-1),
+ при выполнении кода fact(-1) Ошибка! Факториал -1 не определен!
  + управление передается в функцию fact,
  + создаются новые переменные n = -1 и неинициализированная локальная переменнаяres. Они будут уничтожены, когда закончится выполнения этого вызова функции.
  + начинает выполняться код n * f(n-1), и так далее вызывается fact(-2), fact(-3) до тех пор, пока есть возможность создать новые экземпляры переменных n и res, ибо для каждого

Благодаря созданию нового экземпляра переменной n при каждом вызове и возможен рекурсивный вызов функции.

Но мы не можем остановиться. Что делать?

### Главное - вовремя остановиться

Мы забыли часть математического определения факториала $0!=1$.

"Если n=0, то результат 1". Переведем на язык Си.

Условный оператор if:

```c
if (условие)
    оператор   // выполняется только когда условие истинно
```

Если условие истинно, то выполняется оператор. Если ложно, то оператор не выполняется.

+ Условие пишем
  + как в математике, например n > 0.
  + в круглых скобках ( )
+ Оператор пишем
  + с отступом
  + если много операторов, то пишем их в фигурных скобках { }

```c
    if (n == 0) {
        printf("zero! = 1\n");
        return 1;
    }
```

Знак = занят оператором "присвоить" x=2, поэтому "х равно 2?" пишем как x == 2 (два знака = подряд).

В математике | В языке С | По-русски
-|-|-
\> | > | больше
≥ | >= | больше или равно
< | < | меньше
≤ | <= | меньше или равно
= | == | равно
≠ | != | не равно

При двух вариантах выбора "да" или "нет", пишем условный оператор так:

```c
if (условие)
    оператор_ДА   // выполняется только когда условие истинно
else
    оператор_НЕТ  // выполняется только когда условие ложно
```

__Если условие истинно, то выполняется оператор_ДА. Если ложно, то выполняется оператор_НЕТ.__

### Главное - вовремя остановиться 2

Мы забыли часть математического определения факториала $0!=1$.

```c
int fact (int n) {
    printf("call fact(%d)\n", n);
    if (n == 0) {
        printf("zero! = 1\n");
        return 1;
    }
    int res = n * fact (n-1);           // из fact вызывается fact - рекурсия
    printf("return %d! = %d\n", n, res);
    return res;
}
```

Запустим код и получим:

```c
call fact(4)
call fact(3)
call fact(2)
call fact(1)
call fact(0)
zero! = 1
return 1! = 1
return 2! = 2
return 3! = 6
return 4! = 24
```

Видно, что первым был вызван fact(4), который закончился в самую последнюю очередь.

### Отладочная печать с отступами

Хочется наглядно увидеть, когда начинается вызов fact(4) и когда он заканчивается. Для лучшей читаемости кода мы использовали отступы для каждого уровня вложенности (функция или условный оператор). Напечатаем для каждого очередного вызова функции fact дополнительный отступ.

Пусть уровень вложенности будет аргумент depth, который будет увеличиваться при каждом вложенном вызове функции.

Используем для отступов * в форматной строке printf:

```c
#include <stdio.h>


int fact (int n, int depth) {
    printf("%-*c call fact(%d)\n", depth, '>', n);
    if (n == 0) {
        printf("%-*c 0! = 1\n", depth, '>');
        return 1;
    }
    int res = n * fact (n-1, depth+2);
    printf("%-*c %d! = %d\n", depth, '>', n, res);
    return res;
}
int main() {
    printf("main: 4! = %d\n", fact(4, 1));
    return 0;
}
```

получим

```c
> call fact(4)
>   call fact(3)
>     call fact(2)
>       call fact(1)
>         call fact(0)
>         0! = 1
>       1! = 1
>     2! = 2
>   3! = 6
> 4! = 24
main: 4! = 24
```

Такая отладочная печать гораздо понятнее.

### Числа Фибоначчи

Последовательность чисел Фибоначчи задана формулой:

![04](/C_for_beginners_Stepik/Pictures/04_19.png)

Напишем рекурсивную функцию, которая вычисляет n-тое число Фибоначчи:

```c
int fib(int n) {
    if (n == 0 || n == 1)
        return 1;
    return fib(n-1) + fib(n-2);
}
```

Эта функция быстро пишется по математической формуле и правильно считает. (Подумайте, какие лучше взять типы для аргумента и возвращаемого значения).

Есть ли недостатки у рекурсивных функций?

### Эффективность подсчета чисел Фибоначчи с помощью рекурсии

Добавим в функцию отладочную печать:

```c
#include <stdio.h>


int fib (int n, int depth) {
    printf("%-*c call fib(%d)\n", depth, '>', n);
    if (n == 0 || n == 1) {
        printf("%-*c f(0) = f(1) = 1\n", depth, '>');
        return 1;
    }
    int res = fib (n-1, depth+4) + fib (n-2, depth+4);
    printf("%-*c fib(%d) = %d\n", depth, '>', n, res);
    return res;
}
int main() {
    int n = 4;
    printf("main: fib(%d) = %d\n", n, fib(n, 1));
    return 0;
}
```

Получим:

```c
> call fib(4)
>     call fib(3)
>         call fib(2)
>             call fib(1)
>             f(0) = f(1) = 1
>             call fib(0)
>             f(0) = f(1) = 1
>         fib(2) = 2
>         call fib(1)
>         f(0) = f(1) = 1
>     fib(3) = 3
>     call fib(2)
>         call fib(1)
>         f(0) = f(1) = 1
>         call fib(0)
>         f(0) = f(1) = 1
>     fib(2) = 2
> fib(4) = 5
main: fib(4) = 5
```

![04](/C_for_beginners_Stepik/Pictures/04_20.svg)

Видно, что алгоритм не эффективен. Много повторных вычислений.

С ростом n сильно растет количество вызвов функции fib. Для n=4 будет 9 вызовов, а для 20 уже 21891 (допишите код, чтобы он мог напечатать количество вызовов функции fib).

### НОД и НОК двух чисел

Для целых чисел a и b наибольший общий делитель (НОД, greatest common divisor) называется наибольшее из чисел, на которое делится и число a, и число b. Будем обозначать НОД(a,b).

Для чисел 54 и 24 НОД 6.

Для целых чисел a и b наименьшее общее кратное (НОК, least common multiple) называется наименьшее натуральное число, которое делится и на число a, и на число b. Будем обозначать НОК(a,b).

Для чисел 16 и 20 НОК 80.

Для нахождения НОД можно разложить число на множители и найти наибольшую общую часть множителей.

```c
54 = 2*3*3*3
24 = 2*2*2*3
НОД(54, 24) = 2*3 = 6
НОК(54, 24) = 2*2*2*3*3*3 = 216
```

$a⋅b=НОД(a,b)⋅НОК(a,b)$

Числа a и b называют взаимно простыми, если НОД(a,b)=1.

### Алгоритм Евклида нахождения НОД

+ Для чисел a и b ищем a%b
+ На следующем шаге берем вместо a и b числа b и a%b.
+ Повторяем до тех пор, пока a%b не станет 0. Тогда b - НОД.

Найдем НОД(123, 21)

+ 123 % 21 = 18
+ 21 % 18 = 3
+ 18 % 3 = 0

Значит НОД(123, 21) = 3

Найдем НОД(21, 125):

```c
21 % 125 = 21
125 % 21 = 20
21 % 20 = 1
20 % 1 = 0
```

НОД(21, 125) = 1

## Задачи на рекурсию

### half Делим конфеты пополам

На столе лежит n конфет, где n - натуральное число. Каждый ребенок берет половину конфет (с округлением вниз, из 7 конфет он возьмет 3).

Последний ребенок взял 1 конфету.

Сколько детей ели конфеты?

Пусть сначала лежало 7 конфет, их брали так:

Сколько детей | Было конфет | Взяли конфет | Осталось конфет
-|-|-|-
1 | 7 | 3 | 4
2 | 4 | 2 | 2
3 | 2 | 1 | 1
4 | 1 | 1 | 0

Рекомендуем написать функцию, которая по количеству конфет на столе a возвращает сколько детей ели это количество a конфет.

int delim_konfety(int a);

```c
#include <stdio.h>

int delim_konfety(int a) {
    int res = 1;
    while (a > 1) {
        a = a - a / 2;
        res++;
    }
    return res;
}

int main()
{
    int konfet;
    scanf("%d", &konfet);

    int detey = delim_konfety(konfet);
    printf("%d\n", detey);

    return 0;
}
```

### nod Алгоритм Евклида

Наибольшим общим делителем (НОД) двух чисел a и b называется наибольшее число, на которое a и b делятся без остатка.

Можно разложить оба числа на простые делители, найти общую часть этого разложения и получить наибольший общий делитель.

Проще найти НОД по алгоритму Евклида.

+ Возьмем числа 123 и 21. Найдем остаток от деления, число 18.
+ На следующей итерации алгоритма возьмем числа 21 и 18, остаток от деления 3.
+ Будем продолжать, пока в остатке не получится 0. Делитель последней итерации - НОД чисел 123 и 18.

![04](/C_for_beginners_Stepik/Pictures/04_21.png)

Даны 2 целых числа. Найти НОД(a,b) с помощью алгоритма Евклида. Для этого написать рекурсивную функцию

```c
int nod(int a, int b);
```

Посылать только функцию.

```c
int nod(int a, int b) {
    if (b == 0) return a;
    return nod(b, a % b);
}
```

```c
int nod(int a, int b) {
    if (a == b)
        return b;
    else {
        if (a > b)
            return nod(a - b, b);
        else
            return nod(a, b - a);
    }
}
```

### Возведение в натуральную степень

Алгоритм "в лоб"

По определению степени, $a^n - это a умноженное на себя n раз.

Записывая рекуррентную формулу:

$a^n = a ⋅ a^{n−1}$

Для вычисления $a^12$ нам потребуются все остальные степени a

$a^{12}→a^{11}→a^{10}→a^{9}→a^{8}→a^{7}→a^{6}→a^{5}→a^{4}→a^{3}→a^{2}→a^1$

Сложность алгоритма $n−1$

__n - степень двойки:__

Можно ли придумать вычисление эффективнее?

Будем на каждом шаге умножать результат сам на себя. Тогда из $a^1$ получим $a^{32}$ всего за 5 шагов:

$a^1 → a^2 → a^4 → a^8 → a^{16} → a^{32}$

Заметим, что $32 = 2^5$ , то есть мы получаем значение за столько шагов, сколько нужно бинарных цифр для записи степени минус 1.

__Остальные степени:__

Доработаем алгоритм, чтобы он работал с любыми натуральными степенями.

Воспользуемся рекуррентными соотношениями для вычисления четных и нечетных степеней.

![04](/C_for_beginners_Stepik/Pictures/04_22.PNG)

#### Задача 1 (по желанию, для любителей математики)

Докажите, что количество шагов данного алгоритма не превосходит удвоенного числа знаков в бинарной записи n.

#### Задача 2 (по желанию, для любителей математики)

Попробуйте найти более точную оценку эффективности алгоритма.

### ipow Возведение в степень

![04](/C_for_beginners_Stepik/Pictures/04_23.PNG)

Реализуйте этот алгоритм возведения в натуральную степень. Убедитесь, что реализация не ухудшила ожидаемую эффективность.

Напишите функцию

```c
long long int ipow(long long int a, unsigned int n, unsigned int * depth);
```

Она вычисляет $a^n$. В depth запишите глубину рекурсивного вызова функции.

+ Для n=0 функция сразу возвращает 1.
+ Для n=1 функция сразу возвращает a.
$a^{12} →a^6 →a^3 →a^2 →a^1$ , функция ipow вызвана 5 раз (это искомая глубина рекурсивного вызова, которую записываем в depth)

Функция ipow должна быть реализована так, чтобы для нескольких вызовов подряд она записывала в depth корректное значение:

```c
int d = 7;
res = ipow(2, 32, &d);  // res = 4294967296, d = 6
res = ipow(3, 12, &d);  // res = 531441, d = 5
```

```c
int ipow(int a, int n, int* depth) {
    if (n <= 1) {
        *depth = 1;
        return (n && a) ? a : 1;  // если n = 1 то return a, n=0, то 1
    } else if (n % 2 == 0) {
        int res = ipow(a, n / 2, depth);
        (*depth)++;
        return res * res;  // НЕ надо дважды вычислять ipow(a,n/2,depth), надо запомнить вычисленный результат
    } else {
        int res = ipow(a, n - 1, depth);
        (*depth)++;
        return a * res;
    }
}

int main() {
    int a, b, d;
    scanf("%d %d", &a, &b);
    printf("%d ", ipow(a, b, &d));
    printf("%d", d);

    return 0;
}
```

### deliteli Делители числа

Написать рекурсивную функцию для печати простых сомножителей числа a по степеням.

```c
void simpleFactors(unsigned int a, unsigned int last, unsigned int n);
```

+ a - положительное целое число, $(2 ≤ a ≤ 10^9), которое раскладывается на простые сомножители,
+ last - предполагаемый сомножитель для проверки делимости (вначале 2),
+ n - степень сомножителя в числе (вначале 0).

Рекомендуем так же написать функцию для печати сомножителя:

```c
void printFactor(unsigned int last, unsigned int n);
```

Входные данные: целое число $(2 ≤ a ≤ 10^9)$

Выходные данные: сомножители печатаются через пробел

+ с наибольшего сомножителя,
+ степень сомножителя указывается после знака ^
+ если сомножитель в степени 1, то степень не указывается

Input | Output
-|-
8 | $2^3$
105 | 7 5 3
12 | 3 $2^2$

Посылать только simpleFactors и необходимые для ее работы функции, если вы их написали. Функцию main НЕ посылать.

Рекомендуем не читать подсказки и попытаться решить задачу. Если не получится - читайте подсказки по одной.

Рекомендуем в начале функции сделать отладочную печать и печатать значение всех аргументов при вызове: a, last, n

__Подсказка 1. Функция main для проверки:__

```c
int main()
{
    unsigned int a;
    scanf("%u", &a);
    simpleFactors(a, 2, 0);

    return 0;
}
```

__Подсказка 2. Аргументы при вызове при разложении числа 20 на множители:__

Вы можете придумать другое решение. Или напишите решение по этой таблице.

a | last | n | что делаем
-|-|-|-
|20 | 2 | 0 | |
|10 | 2 | 1 | |
|5 | 2 | 2 | печатаем 2^2 |
|5 | 3 | 0 |  |
|5 | 4 | 0 |  |
|5 | 5 | 0 |  |
|1 | 5 | 1 | печатаем 5 |
|0 | 6 | 0 | можно обойтись без этого вызова |

__Подсказка 3. Функция печати одного множителя:__

```c
void printFactor(unsigned int last, unsigned int n)
{
    if (n == 0)
        return;
    if (n == 1)
        printf("%u ", last);
    else
        printf("%u^%u ", last, n);
}
```

__Подсказка 4. Не знаете, как напечатать множители в обратном порядке?__

Посмотрите на порядок печати сообщений для разных вызовов call и return в вычислении факториала.

```c
int is_prime(unsigned int a) {
    for (unsigned int i = 2; i < a / 2 + 1; i++) {
        if (a % i == 0) {
            return 0;
        }
    }
    return 1;
}

void simpleFactors(unsigned int a, unsigned int last, unsigned int n) {
    for (unsigned int i = a; i >= last; i--) {
        if (is_prime(i)) {
            n = 0;
            while (a % i == 0 && a > 1) {
                n++;
                a /= i;
            }
            if (n == 0) continue;
            if (n == 1) printf("%d ", i);
            if (n > 1) printf("%d^%d ", i, n);
        } else
            continue;
    }
}

int main() {
    unsigned int a;
    scanf("%u", &a);
    simpleFactors(a, 2, 0);

    return 0;
}
```

[Продолжение](https://stepik.org/lesson/592538/step/6?unit=587533)

[Продолжение](https://stepik.org/lesson/592538/step/7?unit=587533)

## Заключение (функции)

### Определение функции

Зачем нужны функции:

+ Повторное использование кода.
+ Разбиваем задачу на подзадачи.

Термины:

+ Прототип функции
+ Реализация функции
+ Вызов функции

Аргументы передаются по значению

```c
float foo (float x, int n); // прототип
float foo (float x, int n)  // реализация
{
    float res;
    res = x * n;
    return res;
}
int main ( )
{
    float z;
    z = foo (3.5, -10);     // вызов
    return 0;
}
```

### Переменные

Переменные | Область видимости | Время жизни | int x;
|-|-|-|-|
|Локальные | до конца блока | до конца блока | мусор |
|Аргументы функций | до конца функции | вызов функции | значение при вызове foo(3) |
|Глобальные | до конца файла <br> в другом файле: extern int x; | выполнение программы | 0 |
|static | до конца блока или файла | выполнение программы | 0 |

### Указатели

```c
int x = 1;      // переменная х типа int
int * p;        // переменная p типа указатель на int


p = &x;         // указатель на x
*p = *p + 3;    // результат тот же, что у x = x + 3;
```

![04](/C_for_beginners_Stepik/Pictures/04_24.png)
