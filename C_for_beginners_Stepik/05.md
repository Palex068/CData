# Символы. Структуры

[Видео](https://youtu.be/YFX_AhXu1iE)

[Презентация](/C_for_beginners_Stepik/Files/c2019_3.pdf)

## Символы

### Символы и кодировки
В компьютере хранятся только числа. Для работы с текстом решили кодировать каждый символ своим числом. Например, a - 1, b - 2, c - 3 и так далее. Не забыли о пробеле и знаках препинания. Цифры - это тоже символы, их можно закодировать числами. Так появились таблицы кодировок.

Для кодирования символов английского и русского алфавита (маленьких и заглавных букв), арабских цифр и знаков препинания хватит с запасом 256 чисел. Поэтому таблицы кодировок были 128 или 256 символов для 7-битной или 8-битной кодировок.

Наиболее известны таблицы кодировок: ASCII (7 битная), KOI-8, Latin-1. С русскими буквами: UTF-8, Windows-1251, CP-866, KOI-8R, ISO-8859-5. Однако, первая половина таблицы у этих кодировок совпадает с кодировкой ASCII. Вторую половину обычно занимают символы национальных алфавитов.

#### ASCII-таблица
American Standard Code for Information Interchange (ASCII) был введен как единый стандарт кодировки первых 128 символов в 1969 году и основывалась на [телеграфной кодировке](https://en.wikipedia.org/wiki/Telegraph_code).

![05](/C_for_beginners_Stepik/Pictures/05_01.png)

Заметьте, что цифры, заглавные буквы и маленькие буквы идут в таблице блоками. Символам от 0 до 9 соответствуют коды от 48 до 57. Заглавные буквы от A до Z кодируются числами от 65 до 90, маленькие от a до z - от 97 до 122. Пробел - это 32, \n - 10, \r - 13.

#### Тип char
Коды символов - это небольшие целые числа. Поэтому тип данных самого маленького размера 8 бит, который хранит целые числа, назвали char от слово "character" (символ). В этом типе удобно хранить коды символов, возраст человека, количество студентов в группе.

```
char x = 7;
```

#### Символьные (литеральные) константы

Человек - не компьютер. Он не должен запоминать, что 48 - это ASCII код символа 0. Чтобы было удобнее писать и читать программы ввели понятие символьная константа. Она пишется в одинарных кавычках и обозначает код символа. Тип символьной константы int. Потому что.

Символьная константа | Значение
-|-
'a' | 97
'q' | 113
'Q' | 81
'2' | 50
' ' | 32
'\n' | 10

#### Чтение и печать одного символа
Для чтения с помощью scanf и печати с помощью printf используют форматный спецификатор %c.

```c
char x;
scanf("%c", &x);                            // нажмем на клавиатуре клавишу Q и далее Enter
printf("символ %c, ASCII код %d\n", x, x);  // символ Q, ASCII код 81
```

В переменную x функция `scanf` записала число 81 (ASCII-код введенного символа Q). Это число по формату `%с` напечаталось как соответствующий ему символ Q, и как само десятичное число 81 по формату `%d`.

Есть специальные функции `getchar` и `putchar`, которые читают и печатают 1 символ:

```c
int x;          // да, именно int
x = getchar();  // нажмем на клавиатуре клавишу Q и далее Enter
putchar(x);     // Q
```

Заметим, что в первом случае мы использовали переменную типа `char`, а во втором - типа `int`. Потому что `getchar` нужно еще передать информацию, правильно прочитали символ или произошла ошибка. Поэтому, если прочиталось без ошибок, то в старших байтах нули, а в младшем байте - ASCII-код символа. В случае ошибки во всех битах пишется 1, то есть возвращают число -1.

Если мы напишем код `char x = getchar();` то в случае ошибки в х будет число 255, что в некоторых кодировках совпадает с символом Ъ.

#### Как получить из символа цифры

Пусть в переменной x записан ASCII-код цифры 3. Надо в переменную y записать эту цифру 3:

```c
char x = '3';
char y;
```

Символьная константа | Значение | Закодированная цифра
-|-|-
'0' | 48 | 0
'1' | 49 | 1
'2' | 50 | 2
'3' | 51 | 3
'4' | 52 | 4
'5' | 53 | 5
'6' | 54 | 6
'7' | 55 | 7
'8' | 56 | 8
'9' | 57 | 9

То есть из числа 51 надо получить число 3. Как? Очевидно, отнять 48.

```c
y = x - 48;
```

Код работает, но не надо так писать! Чтобы проверить хорошо ли читается код, представьте, что ваш код взяли как есть и пошли сдавать въедливому преподавателю.

Сможете ли вы, глядя на этот код через 2 месяца, ответить на вопрос "почему 48?" Лучше вместо числа 48, использовать символьную константу '0', которая имеет то же значение 48 (ASCII-код символа 0). Символы цифр идут в ASCII-таблице по порядку от 0, значит надо отнять ASCII-код символа 0.

### Пример: читаем двухзначное число

Представим, что у нас нет возможность прочитать двухзначное десятичное число в переменную x с помощью функции `scanf("%d", &x)`. Как прочитать через `getchar`? Пусть вводят число 47.

```c
int decimal = getchar();        // ASCII-код символа 4
int one = getchar();            // ASCII-код символа 7
```
Получим из ASCII-кодов числа 4 и 7:
```c
decimal = decimal - '0';        // 4
one = one - '0';                // 7
```

Как из чисел 4 и 7 получить число 47?

```c
int res = decimal * 10 + one;   // 47
```

Хорошо, что у нас есть функция `scanf` и разные форматы чтения данных.

Полный код программы:

```c
#include <stdio.h>


int main()
{
    // читаем ASCII-коды
    int decimal = getchar();        // ASCII-код символа 4
    int one = getchar();            // ASCII-код символа 7


    // какие цифры они кодируют?
    decimal = decimal - '0';        // 4
    one = one - '0';                // 7


    // получаем из цифр двухзначное число
    int res = decimal * 10 + one;   // 47


    // теперь можно умножить его на 2 и убедиться, что результат умножения правильный
    printf("%d * 2 = %d\n", res, res * 2);


    return 0;
}
```

### Пример: Шрифт Цезаря
Простой [шифр Цезаря](https://en.wikipedia.org/wiki/Caesar_cipher)

Очень старый шифр. Алфавит сдвигается на N букв и получается зашифрованный алфавит. Cдвинем на N=3 буквы, получим:

```
abcdefghijklmnopqrstuvwxyz - что было
    |  |   |  |            - меняем на
defghijklmnopqrstuvwxyzabc - зашифрованный алфавит
```

+ Шифрование:
    + буква а меняется на d
    + буква b меняется на e
    + ...
    + буква z меняется на c

Слово "hello" по буквам меняется на "khoor".

Напишем программу, которая шифрует слово из 4 букв, алфавит сдвигается на `shift` символов.

Так как буквы стоят одна за другой, чтобы сдвинуть букву `a` на `shift` букв, нужно к ASCII-коду исходной буквы прибавить значение `shift`: `'a' + shift`. Если сдвигаем букву `'w'`, то получаем `'z'`. Добавим и вычтем из `'w'` ASCII-код буквы a, то есть `'w'` - `'a'` + `'a'`. Часть `'w'` - `'a'` - насколько далеко стоит буква w от буквы a.

До шифрования буква стояла на месте `'a' + ('w' - 'a')`.

После шифрования буква стоит на месте `'a' + ('w' - 'a' + shift)`

Но что будет, если прибавить число к ASCII-коду буквы z? Получим число за пределами блока латинских букв в ASCII-таблице. Аналогичная проблема у нас возникала, когда мы складывали минуты и получали число больше 60. Тогда мы брали остаток от деления на 60. Количество букв в алфавите len найдем как 'z' - 'a' + 1. То есть общая формула кодировки буквы w будет `'a' + ('w' - 'a' + shift) % ('z' - 'a' + 1)`

Подумайте, как изменить формулу, чтобы она была верна и для отрицательного сдвига `shift`.

```c
#include <stdio.h>


#define LEN ('z' - 'a' + 1)


// возвращает букву letter, закодированную шифром Цезаря со сдвигом shift
int code(int letter, int shift)
{
    return 'a' + (letter - 'a' + shift) % LEN;
}


int main()
{
    // читаем по символу
    char c1, c2, c3, c4;    // ASCII-коды символов
    int shift;              // сдвиг шифра Цезаря


    // читаем символы и сдвиг
    scanf("%c%c%c%c", &c1, &c2, &c3, &c4);
    scanf("%d", &shift);


    // кодируем символы
    c1 = code(c1, shift);
    c2 = code(c2, shift);
    c3 = code(c3, shift);
    c4 = code(c4, shift);


    // печатаем символы
    printf("%c%c%c%c\n", c1, c2, c3, c4);


    return 0;
}
```

Запустим несколько раз программу.

Входные данные | Выходные данные
-|-
axyz 3 | dabc
cdef 4 | ghij
love 5 | qtaj
zxya 20 | trsu

### формат
Какой формат используют для чтения ASCII-кода символа? Что должно быть написано вместо `???`

```c
char letter;
scanf("???", &letter);
```

```
%c
```

### scanf

```c
char letter = '2';
int res = letter + '5';
```

Что содержит переменная res?

> сумма ASCII-кодов символов 2 и 5

### Читаем и пишем правильно
+ Для работы с `getchar` и `putchar` используйте переменные типа `int`.
+ `printf("%c", x)` - x может быть как `char`, так и `int`, потому что в функциях с переменным числом аргументов любой целый тип, меньший `int`, будет неявно преобразован к `int`. Подробнее читайте об [integer promotion](https://beej.us/guide/bgc/html/index-wide.html#integer-promotions).
+ `printf("%d", x)` - аналогично, x может быть как `char`, так и `int` по той же причине.
+ `scanf("%c", &x)` - x должна быть типа `char`, в случае int ASCII-код будет записан в байт с наименьшим адресом (а старший это или младший байт переменной x - зависит от архитектуры).
+ hh - сокращение от half-half, то есть "половина от половины" int.

```c
char x;
scanf("%hhd", &x); // чтение десятичного числа в переменную типа char
```

### из большой в маленькую
Дана большая латинская буква. Напечатайте соответствующую ей маленькую латинскую букву.

Посылать всю программу. Проверку входных данных делать не нужно, гарантируется, что первый символ входного потока - большая латинская буква.

```c
#include <stdio.h>

int main() {
    char ch;
    scanf("%c", &ch);
    printf("%c", ch + 'a' - 'A');
    return 0;
}
```

### следующая клетка

![04](/C_for_beginners_Stepik/Pictures/05_02.png)

В записи шахматных партий клетки шахматной доски кодируются буквой и цифрой. Буква означает номер столбца, цифра - номер ряда.

Напечатать, координаты клетки на один ряд выше.

Будут даны клетки из рядов с 1 по 7.

```c
#include <stdio.h>

int main() {
    char ch;
    int num;
    scanf("%1c%1d", &ch, &num);
    printf("%c%d", ch, num + 1);
    return 0;
}
```

### королевство кроликов (без границ)
В игре [Королевство кроликов](https://boardgamegeek.com/boardgame/184921/bunny-kingdom) доска 10х10 клеток. Ряды кодируются буквами ABCDEFGHIJ сверху вниз, столбцы кодируются числами от 1 до 10 слева направо.

![05](/C_for_beginners_Stepik/Pictures/05_03.png)

![05](/C_for_beginners_Stepik/Pictures/05_04.PNG)

Дана координата клетки. Напечатайте верхнюю, правую, нижнюю и левую соседние клетки на одной строке через пробел.

Гарантируется, что входные данные не содержат клеток на краю поля.

```c
#include <stdio.h>

int main() {
    char ch;
    int num;
    scanf("%1c%1d", &ch, &num);
    printf("%c%d ", ch - 1, num);
    printf("%c%d ", ch, num + 1);
    printf("%c%d ", ch + 1, num);
    printf("%c%d", ch, num - 1);
    return 0;
}
```

## `Struct`

### Зачем нужны структуры

__Агрегация аргументов функций__

В задаче про вычисление площади треугольника по координатам его трех точек у функции было 6 аргументов:

```c
float area(int x1, int y1, int x2, int y2, int x3, int y3);
```

Многие из вас ошибались с индексами и передачей аргументов в функцию.

Удобнее было бы, если бы были такие типы в языке С, написать функцию так:

```c
float area(Point p1, Point p2, Point p3);
```

или даже так:

```c
float area(Triangle tr);
```

__Возвращаем много значений__

Мы писали простую функцию int time2min(int h, int m), которая по часам и минутам возвращала количество минут с 0:00.

Хочется, чтобы обратная функция перевода из минут с начала суток в часы и минуты была такой же простой. Мы реализовали ее через указатели.

Хочется такой реализации:

```c
Time t = min2time(mm);
```

Для этого нужно сделать новый тип данных, в который, как в вещи в сумку, будут положены разные данные. В языке Си для этого используют структуры.

### Структура
Структура - это определяемый пользователем тип, который содержит данные, возможно разных типов.

__Объявление структуры__

Для хранения спортивных результатов студентов объявим новый тип struct Student. Структура состоит из полей. Каждое поле имеет тип и имя (идентификатор).

```c
struct Student {
    long id;
    int birth_year;         // год рождения
    float weight;           // вес, кг
    float height;           // рост, м
    float run100;           // время забега на 100м, сек
    unsigned char pushup;   // отжиманий
    unsigned char pullup;   // подтягиваний
};  // <---- Не забудь про ;
```

+ ключевое слово struct
+ Student - придумали сами,
    + пишут с большой буквы (code style),
    + название типа struct Student (нельзя опустить часть struct)
+ Поля пишут в `{}`
+ После объявления структуры обязательно `;`
+ Поля определяют как тип идентификатор;
    + поля могут быть разных типов
    + рекомендуем писать у каждого поля комментарий что в нем хранится
    + полное название типа

__Объявление переменной: тип идентификатор;__

```c
int x;                  // объявили переменную `x` типа `int`
struct Student gusev;    // объявили переменную `gusev` типа `struct Student`
```

С явной идентификацией переменной:

```c
int x = 7;              // объявили переменную `x` типа `int`, значение 7
struct Student ivanov = {315101, 2000, 70.4, 1.86, 17.6, 14, 5};
```

Студент с идентификационным номером 315101, родился в 2000 году, вес 70.4 кг, рост 1.86 м, пробежал 100 метров за 17.6 секунд, 14 раз отжался и 5 раз подтянулся.

__Поля при явной инициализации структуры пишем в том же порядке, что и в объявлении структуры.__

Можно инициализировать только часть полей, остальные поля по умолчанию инициализируются 0.

```c
int y;              // 0 только в случае глобальной переменной, иначе "мусор"
struct Student petrov = {315102, 1999};  // указаны только id и birth_year остальные поля 0
```

При инициализации можно указать имя поля, тогда данные можно перечислять в любом порядке:

```c
struct Student sidirov = {.weight=56.6, .height=1.62, .id=315102};
```

Нельзя (можно только при инициализации переменной):

```c
struct Student zotov;           // ok
zotov = {315109, 2001, 61.8};   // Ошибка!
```

__Использование переменных__

_переменная.поле_ - обращение к полю переменной через оператор "точка"

```c
struct Student zotov;
zotov.height = 1.72;
zotov.pullup = 9;


zotov.id = sidorov.id + 2;


printf("Самый высокий рост: %.2f\n", ivanov.height);


scanf("%d", &zotov.id); // скобки не нужны, приоритет . больше, чем приоритет &
```

```c
struct B {
    int k;
    float z;
};


struct B b = {7, -1.24};


b.k = b.k + 2;
```

Чему равно b.k?

```
9
```

### time_def Определение структуры Time
Все мини-вопросы по синтаксису этой линейки МОЖНО (преподаватель не будет ругаться) сразу писать в поле ответа, а не писать полную программу в отдельном файле.

Для хранения и представления показаний часов напишите структуру с именем Time и целочисленными полями h и m.

Посылать только объявление структуры.

Не забудьте про `;`.

Программа будет состоять из:

```c
// ваш код

// Этот код уже будет в проверяющей системе:
#include <stdio.h>

int main()
{
    struct Time t;
    scanf("%d:%d", &t.h, &t.m);
    printf("%02d:%02d\n", t.h, t.m);
    return 0;
}
```

```c
struct Time {
    int h;    // часы    
    int m;    // минуты
};
```

### rect_xywh Определить тип данных для хранения прямоугольника
Прямоугольник на плоскости XY со сторонами, параллельными осям, можно задать по-разному.

![05](/C_for_beginners_Stepik/Pictures/05_05.jpg)

__Точка и размеры__

Объявите тип данных для описания прямоугольника, заданного x и y координатами левой верхней точки и его размерами.

Имя структуры `Rect0`, поля x, y, width (ширина), height (высота) типа int.

Объявите переменную a этого типа и проинициализируйте ее так, чтобы она описывала прямоугольник на рисунке.

Отправлять только объявление структуры, декларацию переменной и ее инициализацию.

```c
struct Rect0 {
    int x;
    int y;
    int width;
    int height;
};

struct Rect0 a = {-7, 5, 12, 8};
```

### rect_ltrb Определить тип данных для хранения прямоугольника
Прямоугольник на плоскости XY со сторонами, параллельными осям, можно задать по-разному.

![05](/C_for_beginners_Stepik/Pictures/05_05.jpg)

__Точки по диагонали__

В программе уже объявлена (не надо ее посылать!) структура для хранения x и y координат точек

```c
struct Point {
    int x;
    int y;
};
```

Объявите тип данных для описания прямоугольника, заданного x и y координатами левой верхней точки и правой нижней точки.

Имя структуры Rect1, поля lt (left top, левая верхняя точка) и rb (right bottom, правая нижняя точка) типа struct Point. Объявите переменную b этого типа и проинициализируйте ее так, чтобы она описывала прямоугольник на рисунке.

Отправлять только объявление структуры, декларацию переменной и ее инициализацию.

```c
struct Rect1 {
    struct Point lt;
    struct Point rb;
};

struct Rect1 b = {{-7, 5}, {5, -3}};
```

### Передаем аргументы в функцию и возвращаем значение
Вспомним, как мы передавали аргументы типа int и возвращали значение типа int из функции.

Структура - это "int на стероидах", то есть в структуре хранят много разных значений, но ведет она себя как int.

__Функция возвращает int__

Функция получает число x и возвращает число x+1:

```c
#include <stdio.h>


int inc (int x) {
    x = x + 1;      // x++;
    return x;
}
int main () {
    int a = 3;
    a = inc (a);
    a = inc (a);
    printf("%d\n", a); // 5
}
```

Возвращается новое значение аргумента x.

__Функция void (ничего не возвращает)__

Передаем в функцию значение переменной a. Аргумент функции a - это другая переменная a, инициированная значением при вызове, то есть копия переменной a из main.

Это копия, если функция ничего не возвращает, то значение переменной a не меняется.

![05](/C_for_beginners_Stepik/Pictures/05_06.png)

__Функция возвращает struct Point__

Аналогично, функция получает struct Point с полем x и возвращает struct Point с полем x на 1 больше.

```c
struct Point{
    int x;
    int y;
};


// получаем точку на плоскости XY и возвращаем другую точку, сдвинутую по Х на +1
struct Point incPoint(struct Point t)
{
    t.x = t.x + 1;
    return t;
}
int main()
{
    struct Point t = {2, 7};
    t = incPoint(t);
    t = incPoint(t);
    printf("t.x=%d t.y=%d\n", t.x, t.y);    // t.x = 4 t.y = 7
}
```

__Функция void (ничего не возвращает)__

Если функция ничего не возвращает, то изменения переданной в функцию inc копии переменной t, в функции main на переменную t не повлияют (это другая переменная в памяти).

Изменяется поле х переменной t в функции inc. Переменная t в функции main не изменяется.

![05](/C_for_beginners_Stepik/Pictures/05_07.png)

### rect_area0 Площадь прямоугольника - 1.
Прямоугольник на плоскости XY со сторонами, параллельным осям, задан x и y координатами левой верхней точки и его размерами. Для его хранения объявлена структура (ее посылать НЕ надо!)

```c
struct Rect {
    int x;      // х координата левой верхней вершины
    int y;      // y координата левой верхней вершины
    int width;  // ширина
    int height; // высота
};
```

Напишите функцию, которая возвращает площадь прямоугольника a.

```c
int area(struct Rect a);
```

Посылать только реализацию функции.

```c
int area(struct Rect a) {
    return a.width * a.height;
}
```

### rect_area1 Площадь прямоугольника - 2.
Прямоугольник на плоскости XY со сторонами, параллельным осям, задан x и y координатами левой верхней и правой нижней вершин. Для его хранения объявлена структура (ее посылать НЕ надо!)

```c
struct Point {
    int x;
    int y;
};
struct Rect {
    struct Point lt;    // координаты левой верхней вершины
    struct Point rb;    // координаты правой нижней вершины
};
```

Напишите функцию, которая возвращает площадь прямоугольника a.

```c
int area(struct Rect a);
```

Посылать только реализацию функции.

```c
int area(struct Rect a) {
    return (a.lt.x - a.rb.x) * (a.rb.y - a.lt.y);
};
```

### Повторим указатели
Для изменения значения переменных внутри функции мы передавали адрес переменной.

```c
int x;
scanf("%d", &x);    // в функцию передается (значение) адреса переменной &x
printf("%d", x);    // в функцию передается значение переменной x
```

![05](/C_for_beginners_Stepik/Pictures/05_08.png)

```c
int x = 7;      // переменная х типа int значение 7
int * px;       // переменная px типа int * (указатель на int)
                // сейчас никуда не указывает
px = &x;        // &x - вычислить адрес переменной х
                // px указывает на x
*px = 23;       // в результате x = 23
                // *px - перейти от указателю к переменной,
                // на которую он указывает
*px = *px + 4;  // *px используют для чтения и записи
```
```c
*px = 23 - записать int по адресу, который хранится в px, потому что px имеет тип указатель на int.
```

### В функцию передаем адрес и изменяем значение переменной
В функцию всегда передается только значение. Сейчас это значение - адрес переменной a

```c
void inc(int * px)
{
    *px = *px + 1;  // или (*px)++, тут нужны скобки ибо приоритет ++ выше, чем *
}
int main()
{
    int a = 3;
    inc(&a);
    inc(&a);
    printf("%d\n", a);  // 5


    return 0;
}
```

![05](/C_for_beginners_Stepik/Pictures/05_09.png)

+ При вызове inc(&a) вычисляется значение &a (пусть это 100),
+ управление передается в функцию inc,
+ в ней создается переменная px типа int * и инициализируется значением 100,
    + то есть px указывает на переменную a
+ выполняется *px = *px + 1
    + читается int значение по адресу, который записан в px (то есть из переменной, на которую он указывает, а, то есть 3),
    + к нему +1, то есть 4,
    + 4 записывается по адресу, который записан в px (то есть в переменную, на которую он указывает, а), итого, в a записали 4

### В функцию передаем адрес структуры и изменяем значение ее полей
Аналогично, можно рассматривать переменную типа "какая-то структура" как большой ящик с полками (полями). Передается адрес этого ящика, а не его копия.

В функции аналогично мы бы писали (*p).x = (*p).x + 1, выглядит ужасно, трудно читать.

В Си для удобства ввели еще один оператор доступа к полю структуры -> ("стрелка", пишется как знаки "минус" и "больше" вместе).

```c
void inc(struct Point * p)
{
    p->x = p->x + 1;
}
int main()
{
   struct Point t;
   t.x = 2;
   inc(&t);
   inc(&t);
   printf("%d\n", t.x);


   return 0;
}
```

![05](/C_for_beginners_Stepik/Pictures/05_10.png)

+ При вызове inc(&t) вычисляется значение &t (пусть это 100),
+ управление передается в функцию inc,
+ в ней создается переменная p типа struct Point * и инициализируется значением 100,
    + то есть p указывает на переменную t
+ выполняется p->x = p->x + 1
    + читается значение поля х у struct Point по адресу, который записан в p (то есть из переменной, на которую он указывает, t.x, то есть 2),
    + к нему +1, то есть 3,
    + 3 записывается в поле х по адресу, который записан в p (то есть в переменную, на которую он указывает, t), итого, в t.x записали 3

### Точка или стрелка?
+ Если переменная типа структура Т, то точка.
+ Если переменная типа указатель на структуру Т, то ->.

```c
struct Point {
    int x;
    int y;
};
struct Rectangle {
    struct Point lt;    // left top point
    struct Point rb;    // right bottom point
};
```

Определяю переменную rect "прямоугольник" типа struct Rectangle

```c
struct Rectangle rect = {{0, 0}, {-640, -480}}; // сам прямоугольник
struct Rectangle * r = &rect;                   // указатель на прямоугольник


rect.lt.x = 10;
r->lt.y = 20;
```

+ `rect` типа `struct Rectangle`, значит обращение к полям точка. Поля у `struct Rectangle` только `lt` и `rb`. Других нет. Получили `rect.lt`
+ `rect.lt` типа `struct Point`, значит обращение к полям точка. Поля у `struct Point` только x и y. Других нет. Получили `rect.lt.x`
+ `r` типа `struct Rectangle *`, значит обращение к полям стрелка. Поля у `struct Rectangle` только `lt` и `rb`. Других нет. Получили `r->lt`
+ `r->lt` типа `struct Point`, значит обращение к полям точка. Поля у `struct Point` только `x` и `y`. Других нет. Получили `r->lt.x`

### rect_move1 Сдвиг прямоугольника на dx
Прямоугольник на плоскости XY со сторонами, параллельным осям, задан x и y координатами левой верхней точки и его размерами. Для его хранения объявлена структура (ее посылать НЕ надо!)

```c
struct Rect {
    int x;      // х координата левой верхней вершины
    int y;      // y координата левой верхней вершины
    int width;  // ширина
    int height; // высота
};
```

Напишите функцию, которая двигает прямоугольник на dx. В функцию передается указатель на этот прямоугольник p.

```c
void move(struct Rect * p, int dx);
```

Посылать только реализацию функции.

```c
void move(struct Rect * p, int dx) {
    p->x += dx;
}
```

### rect_area1 Площадь прямоугольника - 2.
Прямоугольник на плоскости XY со сторонами, параллельным осям, задан x и y координатами левой верхней и правой нижней вершин. Для его хранения объявлена структура (ее посылать НЕ надо!)

```c
struct Point {
    int x;
    int y;
};
struct Rect {
    struct Point lt;    // координаты левой верхней вершины
    struct Point rb;    // координаты правой нижней вершины
};
```

Напишите функцию, которая двигает прямоугольник на dx. В функцию передается указатель на этот прямоугольник p.

```c
void move(struct Rect * p, int dx);
```

Посылать только реализацию функции.

```c
void move(struct Rect * p, int dx) {
    p->lt.x += dx;
    p->rb.x += dx;
}
```

##  Typedef

### Создание псевдонимов typedef
Для любого типа можно определить новое имя (псевдоним, user-defined type) с помощью typedef:

```c
typedef существующий тип псевдоним;
```

Например:

```c
typedef unsigned char Age;              // тип для хранения возраста человека в годах
typedef unsigned long long int llu;     // просто надоело писать длинные слова
```

+ Использовать псевдоним можно там же, где вы используете тип.
+ Можно использовать как псевдоним, так и исходный тип (но стилистически лучше дальше использовать только псевдоним).
+ Псевдоним - одно слово.
+ Принято название типа писать с большой буквы (кроме низкоуровневых - llu и кроме системных - size_t).

```c
unsigned char x;
Age student = 17;


llu z = (llu)x * x;
unsigned long long *p = &z;
```

#### Зачем нужны псевдонимы?
Чтобы код был читаемее и его было легко модифицировать.

Пусть в программе хранится возраст в годах и координаты точек на маленьком экранчике. В обоих случаях достаточно типа unsigned char.

Вариант 1: в программе НЕ используются псевдонимы.

```c
int is_adult(unsigned char student);
void move(unsigned char *x, unsigned char *y, unsigned char dx, unsigned char dy);
```

Вариант 2: в программе используются псевдонимы.

```c
typedef unsigned char Age;
typedef unsigned char Coord;


int is_adult(Age student);
void move(Coord *x, Coord *y, Coord dx, Coord dy);
```

Представим, что у нас увеличился размер экрана. Для хранения координат теперь нужен тип `unsigned short`. В случае использования `typedef` нужно поменять ровно одну строку (и еще формат при печати и чтении данных). Без `typedef` придется менять во всем коде типы руками, потому что если автоматически везде заменить `unsigned char` на `unsigned short` с помощью поиска и замены в текстовом редакторе, вы сильно увеличите возможную продолжительность жизни.

### Отметьте, где правильно описан псевдоним.

+ typedef long double Pressure;
+ typedef float Temperature;

## Использование

```c
typedef long double Pressure;
```

Отметьте синтаксически корректные конструкции

```c
Pressure vacuum(Pressure);
Pressure p = 1031;
k = (Pressure)(z + dz);
```

### Короче
Многих раздражает в языке Си необходимость писать ключевое слово struct при использовании

```c
void move(struct Rect * p, int dx);
```
Используйте typedef и можно писать короче.

```c
struct Point{
    int x;
    int y;
};
typedef struct Point Point;
```

То же самое, но соединим определение структуры с `typedef`:

```c
typedef struct Point {
    int x;
    int y;
} Point;
```

Теперь можно использовать как `struct Point`, так и `Point`:

```c
void move(struct Point *p, int dx);
void mirror_x(Point *p);
```

Хороший стиль - придерживаться в коде одного способа. Или `struct Point`, или `Point`.

### Анонимные структуры
Можно определять структуры без указания имени. Такие структуры называют анонимные.

Можно определить структуру, переменные и дальше их использовать:

```c
struct {
    unsigned char age;
    float weight;
} man, woman, cat;


cat.age = 2;
cat.weight = 4.7;
```

Анонимные структуры не могут быть типом формального аргумента функции:

```c
int is_adult(struct p);   // ОШИБКА, не существует тип struct
```

Но если мы используем анонимную структуру и typedef, то у нас есть псевдоним типа. Его можно использовать везде, где мы используем тип:

```c
typedef struct {
    int hour;
    int minute;
    int second;
} Time;


Time clock = {12, 34, 5};


int time2min(Time t);
Time min2time(int mm);
```

### Определите структуру

Определите структуру, описывающую окружность с центром с координатами x и y типа int и радиусом r типа double так, чтобы было корректен прототип функции:

```c
Circle zoom(Circle c, int k);
```

Функцию zoom реализовывать НЕ НУЖНО.

ТУТ БУДЕТ ВАШ ПОСЛАННЫЙ КОД

```c
// ---- далее код уже определен в проверяющей системе:
Circle zoom(Circle c, int k);

int main()
{
    Circle c = {1, 2, 3};
    Circle z = zoom(c, 5);
    printf("%.0lf\n", z.r);
    return 0;
}

Circle zoom(Circle c, int k)
{
    Circle res = c;
    res.r *= k;
    return res;
}
```

```c
typedef struct {
    int x, y;
    double r;
} Circle;
```

## Struct: примеры кода

### Пример: Отрезок на оси Х
Опишем структуру для хранения одномерного отрезка по оси Х [start, finish]. И определим отрезки a [-4, 7] и b [6, 0]. Объявим еще один отрезок m и введем его начало и конец с клавиатуры.

Объявление нового типа лучше указывать в начале файла, после директив препроцессора.

```c
#include <stdio.h>


// объявили новый тип данных struct Segment
// 1D отрезок
struct Segment {
    int start;    // один конец отрезка
    int finish;   // другой конец отрезка
};


int main()
{
    struct Segment a = {-4, 7}, b;
    b.start = 6;
    b.finish = 0;


                            // распечатаем эти отрезки:
    printf("a = [%d, %d]\n", a.start, a.finish);
    printf("b = [%d, %d]\n", b.start, b.finish);


    struct Segment m;
    scanf("%d", &m.start);  // читаем
    scanf("%d", &m.finish);
                            // печатаем
    printf("m = [%d, %d]\n", m.start, m.finish);


    return 0;
}
```

### Пример: Когда приедет электричка?

Напишем функции, которые переводят время в часах и минутах в минуты с 0:00, а потом обратно. Определим структуру `Time` с полями `h` (часы) и `m` (минуты).

Напишем функции работы со структурой и решим задачу, во сколько прибудет электричка, которая отправилась в `h1:m1` и ехала `dh:dm`? В зависимости от циферблата можем получить разное "во сколько" (для 24-часового или для 12-часового циферблата). Напишем решение для 24-часового циферблата.

Я бы все времена держала в минутах с 0:00, и преобразовывала к часам и минутам только в момент печати. Но у нас учебная задача и мы покажем как хранить промежуточные значения в часах и минутах.

#### Объявление структуры

Объявим новый тип struct Time

```c
struct Time {
    int h;      // часы
    int m;      // минуты
};
```

#### Объявление переменных в main

Проверим работу на случае, когда электричка выехала в 22:55, ехала 2:07 и приехала в 1:02.

В main объявим и проинициализиуем переменные:

```c
    struct Time t1 = {22, 55};
    struct Time dt = { 2, 7};
    struct Time t2,                     // результат
                expected_res = {1, 2};  // ожидаемый результат для тестов
```

#### Печать времени

Сначала будем писать как используем функции, потом их реализовывать. Это поможет понять, какие аргументы нужны и какой будет тип возвращаемого значения.

Для печати времени в main объявленных переменных напишем:

```c
    print_time(t1);     // 22:55
    print_time(dt);     // 02:07
```

+ имя функции print_time
+ аргумент один, тип такой же, как у t1 или dt, то есть struct Time,
+ ничего не возвращает, то есть void.

Получился прототип:

```c
void print_time(struct Time t);
```

В функцию передаем время и печатаем его:

```c
// печать hh:mm
void print_time(struct Time t)
{
    printf("%02d:%02d\n", t.h, t.m);
}
```

В функции у нас единственная переменная t - аргумент. Нет никаких "переменных h и m". Есть `t.h` - поле h переменной t и `t.m` - поле m переменной t.

Скомплируем и запустим программу. Проверим, что функция реализована правильно.

#### `time2min` h, m -> mm

Напишем функцию `time2min`, она получает время и возвращает минуты с 0:00. Действуем по шаблону: объявили переменную `res` того типа, что должна вернуть функция, записали в нее данные, вернули `res`:

```c
int time2min(struct Time t)
{
    int res;
    res = t.h * 60 + t.m;
    return res;
}
```

В функцию передана переменная t время, у нее есть поля h часы и m минуты.

Вызываем в main и сразу проверяем ее работу:

```c
    int mm = time2min(dt);  // 2:07
    assert(mm == 127);
```

В функцию передали "большую сумку с данными" (`struct Time`), вернули из функции `int`. Аналогично в `min2time` из одного числа сделаем "большую сумку с данными" :

#### `min2time`

В функции `min2time` действуем по тому же шаблону объявить/вычислить/вернуть. Но возвращаемое значение время, то есть `struct Time`:

```c
// mm -> h, m
struct Time min2time(int mm)
{
    struct Time res;    // объявили res типа struct Time
    res.m = mm %60;     // вычислили значение res
    res.h = mm/60 % 24;
    return res;         // вернули res
}
```

Вызываем в main:

```c
    struct Time t = min2time(127);
    print_time(t);                  // 02:07
```

#### структура == структура

Хочется написать `assert`, но для структур __оператор == не работает__, нужно написать функцию сравнения. Сравниваем у 2 структур каждое поле. Пусть вернет 1, если все поля одинаковые и 0, если разные.

```c
int is_equal(struct Time t1, struct Time t2)
{
    if (t1.h != t2.h)
        return 0;
    if (t1.m != t2.m)
        return 0;
    return 1;
}
```

используем ее в assert:

```c
    assert(1==is_equal(min2time(127), dt));
Вызов `assert` и функцию можно написать короче, подробнее расскажем на следующем уроке. Если вы уже знаете логические операторы в других языках, то оператор AND в Си это &&:

```c
int is_equal(struct Time t1, struct Time t2)
{
    return t1.h == t2.h && t1.m == t2.m;
}
```

и вызов

```c
    assert(is_equal(min2time(127), dt));
```

#### add - сложение времен
Функция add получает время и время, возвращает тоже время.

```c
// t1 + t2
struct Time add(struct Time t1, struct Time t2)
{
    int mmres = time2min(t1) + time2min(t2);    // всего минут с 0:00
    struct Time res = min2time(mmres);          // из минут во время
    return res;                                 // вернули время
}
```

Протестируем функции:

```c
int main()
{
    struct Time t1 = {22, 55};
    struct Time dt = { 2, 7};
    struct Time t2,
                expected_res = {1, 2};


    print_time(t1);
    print_time(dt);


    t2 = add(t1, dt);
    print_time(t2);


    assert(1==is_equal(t2, expected_res));


    return 0;
}
```

#### Вся программа

```c
#include <stdio.h>


// Объявляем новый тип данных struct Time:
struct Time {
    int h;      // часы
    int m;      // минуты
};


void print_time(struct Time t);     // печать hh:mm


int time2min(struct Time t);        // h, m -> mm
struct Time min2time(int mm);       // mm -> h, m
struct Time add(struct Time t1, struct Time t2);    // t1 + t2


int main()
{
    struct Time t1 = {22, 55};
    struct Time dt = { 2, 7};
    struct Time t2,
                expected_res = {1, 2};


    print_time(t1);
    print_time(dt);


    t2 = add(t1, dt);
    print_time(t2);


    return 0;
}


// печать hh:mm
void print_time(struct Time t)
{
    printf("%02d:%02d\n", t.h, t.m);
}


// h, m -> mm
int time2min(struct Time t)
{
    int res;
    res = t.h * 60 + t.m;
    return res;
}


// mm -> h, m
struct Time min2time(int mm)
{
    struct Time res;
    res.m = mm %60;
    res.h = mm/60 % 24;
    return res;
}


// t1 + t2
struct Time add(struct Time t1, struct Time t2)
{
    int mmres = time2min(t1) + time2min(t2);
    struct Time res = min2time(mmres);
    return res;
}
```

### Пример (повторение). Читаем число
Целое число можно прочитать с клавиатуры в отдельной функции.

```c
int read_int();
void scan_int();
```

Реализация и вызов функций:

```c
int read_int()
{
    int res;
    scanf("%d", &res);
    return res;
}
void scan_int(int * p)
{
    scanf("%d", p);     // p уже указатель, не нужно &
}
int main()
{
    int x, y;
    x = read_int();
    scan_int(&y);
    printf("x=%d y=%d\n", x, y);


    return 0;
}
```

### Пример. Читаем время
Аналогично можно прочитать не целое число, а струтуру (много данных)

Время можно прочитать с клавиатуры с помощью `scanf` в отдельной функции.

```c
void printTime(struct Time t)
{
    printf("%02d:%02d\n", t.h, t.m);
}
struct Time read_Time()
{
    struct Time res;
    scanf("%d:%d", &res.h, &res.m);
    return res;
}
void scan_Time(struct Time * p)
{
    scanf("%d:%d", &p->h, &p->m);     // УКАЗАТЕЛЬ на поле h, нужно &
}
int main()
{
    struct Time t1, t2;
    t1 = read_Time();
    scan_Time(&t2);


    printTime(t1);
    printTime(t2);


    return 0;
}
```

### Пример. Отрезок на плоскости XY

Отрезок задается двумя точками. Сначала определим структуру и функции для работы с точками.

Точка на плоскости XY имеет (пусть целые) координаты х и y.

```c
typedef struct {
    int x;
    int y;
} Point;
```

#### Печать точки

Будем печатать точку по формату (x,y), в конце пробел.

```c
void printPoint(Point p)
{
    printf("(%d,%d) ", p.x, p.y);
}
```

Объявим в main переменные (точки) и распечатаем их:

```c
    Point p1 = {4, 3};
    Point p2 = {-4, -3};
    printPoint(p1);     // (4,3)
    printPoint(p2);     // (-4,-3)
```

#### Расстояние между 2 точками

Для вычисления расстояния между двумя точками напишем функцию distance. Проверим ее работу в main:

```c
    float d = distance(p1, p2);
    assert(d == 10);
```
Реализация функции:

```c
float distance(Point p1, Point p2)
{
    int dx = p1.x - p2.x;
    int dy = p1.y - p2.y;
    return sqrt(dx*dx + dy*dy);
}
```

#### Сдвиг точки на dx

+ Можно при сдвиге создавать новую точку, как в movePoint1.
+ Можно изменять существующую точку, как в movePoint2.

Использование функций:

```c
    // из точки p (4,3) сделаем новую точку p_new (6,3)
    Point p_new = movePoint1(p1, 2);     // 6, 3
    printPoint(p_new);
    Point exp_point = {6, 3};


    // существующую точку p_new сдвинем еще раз, получим (8,3)
    movePoint2(&p_new, 2);
    printPoint(p_new);                  // 8, 3
```

Берем копию точки, возвращаем новую точку:

```c
// Получаем новую точку на dx от p.
Point movePoint1(Point p, int dx)
{
    Point res = p;      // новая точка res из старой p
    res.x += dx;
    return res;         // вернули (откопировали значение) новой точки
}
```

Берем адрес точки и по этому адресу изменяем значение:

```c
void movePoint2(Point * p, int dx)
{
    p->x += dx;
}
```

#### Сравнение структур

Чтобы использовать assert, напишем проверку на равенство точек:

```c
int is_equal(Point p1, Point p2)
{
    return p1.x == p2.x && p1.y == p2.y;
}
```

Определим, какие данные ожидаем получить и сравним с ними результаты сдвига:

```c
    Point p_new = movePoint1(p1, 2);    // 6, 3
    printPoint(p_new);
    Point exp_point = {6, 3};           // ожидаемый результат (6,3)
    assert(is_equal(exp_point, p_new));


    exp_point.x += 2;                   // ожидаемый результат (8,3)
    movePoint2(&p_new, 2);
    printPoint(p_new);                  // 8, 3
    assert(is_equal(exp_point, p_new));
```

#### Прочитать точку с клавиатуры
Как в move, есть два варианта - создать точку и заполнить значения в уже существующей:

```c
    Point p1, p2;
    p1 = readPoint();   // возвращаем новую точку, = копирует структуру
    scanPoint(&p2);     // заполняем значения полей уже существующей


    printPoint(p1);
    printPoint(p2);
```

Возвращаем новую точку:

```c
Point readPoint()
{
    Point res;
    scanf("%d%d", &res.x, &res.y);
    return res;
}
```

+ в функции `readPoint` создается структура, заполняется и возвращается эта структура.
+ Point p1 = readPoint(); - возвращаемая структура копируется в p1.

Изменяем уже существующую:

```c
void scanPoint(Point * p)
{
    int x, y;
    scanf("%d%d", &x, &y);
    p->x = x;
    p->y = y;
    // или короче scanf("%d%d", &p->x, &p->y);
}
```

+ Point p2; - создается структура, которую будем заполнять в scanPoint. (Есть рюкзак).
+ scanPoint(&p2); - в scanPoint передается адрес существующей структуры. (Передали где лежит рюкзак)
+ scanf("%d%d", &p->x, &p->y);
    + p->x- по адресу p перешли к полю структуры x,
    + &p->x - передали в scanf адрес поля x

#### Line - отрезок [a,b]
Отрезок определяется двумя точками. Объявим структуру Line для описания отрезка [a,b]:

```c
typedef struct{
    Point a;
    Point b;
} Line;
```

Выделим в main код, который тестирует поведение Point в отдельную функцию testPoint, а в main начнем тестировать функции отрезка.

```c
    Line s = {{2, 3}, {5, 7}};
    printLine(s);
```

#### printLine - печать отрезка

Реализуем функцию printLine. Можно написать так:

```c
void printLine(Line s)
{
    printf("(%d,%d) (%d,%d) \n", s.a.x, s.a.y, s.b.x, s.b.y);
}
```

или так:

```c
void printLine(Line s)
{
    printPoint(s.a);
    printPoint(s.b);
    printf("\n");
}
```

Выберите какой вариант вам нравится больше. Попытайтесь понять почему.

#### length - длина отрезка

Напишем тест для функции length. Она вычисляет длину отрезка.

Сначала напишем тест:

```c
    Line s = {{2, 3}, {5, 7}};
    printf("length=%.2f\n", length(s));
    assert(length(s) == 5);
```

Длина - это расстояние между концами отрезка. Расстояние между точками вычисляет функция distance:

```c
float length(Line p1)
{
    return distance(p1.a, p1.b);
}
```

#### Отрезки одинаковые?

Прежде чем написать функцию move для отрезков, научимся проверять равны отрезки или нет.

Отрезки равны, если равны их вершины.

```c
int is_equalLine(Line p1, Line p2)
{
    return is_equal(p1.a, p2.a) && is_equal(p1.b, p2.b);
}
```

Хорошая функция сравнения еще проверит вариант, что is_equal(p1.a, p2.a) && is_equal(p1.b, p2.b), но пока обойдемся этим кодом.

Использовать будем в assert.

#### Подвинуть отрезок на dx

+ Можно при сдвиге создавать новый отрезок, как в moveLine1.
+ Можно изменять существующий отрезок, как в moveLine2.

Заметьте, везде используем функции для сдвига точки.

```c
// возвращаем новый отрезок
Line moveLine1(Line s, int dx)
{
    Line res;
    res.a = movePoint1(s.a, dx);    // возвращает новую точку
    res.b = movePoint1(s.b, dx);
    return res;
}
// изменяем существующий отрезок
void moveLine2(Line * p, int dx)
{
    movePoint2( &p->a, dx);         // передаем указатель на точку
    movePoint2( &p->b, dx);
}
```

+ В moveLine2 получаем параметр p - указатель на отрезок. Поэтому стрелка для доступа к полю a.
+ p->a имеет тип точка, то есть struct Point, в movePoint2 нужно передать указатель на точку, поэтому применяем оператор &.
+ приоритет -> выше, чем у &, поэтому скобок не нужно, порядок работы правильный.

Проверим работу функций:

```c
    Line s_new = moveLine1(s, 3);
    printLine(s_new);
    Line exp_line = {{5, 3}, {8, 7}};
    assert(is_equalLine(s_new, exp_line));


    exp_line.a.x += 3;
    exp_line.b.x += 3;
    moveLine2(&s_new, 3);
    printLine(s_new);
    assert(is_equalLine(s_new, exp_line));
```

#### Чтение отрезка
Аналогично можно написать 2 варианта чтения отрезка с клавиатуры: функция возвращает новый отрезок или заполняет данные уже существующего отрезка.

__Функция возвращает отрезок__

Функция должна прочитать с клавиатуры и вернуть отрезок. Никаких аргументов нет!

```c
    Line s3 = readLine();
    printLine(s3);
```

Реализуем функцию:

```c
Line readLine()
{
    Line res;
    res.a = readPoint();
    res.b = readPoint();
    return res;
}
    Line s3;
    scanLine(&s3);
    printLine(s3);


void scanLine(Line * p)
{
    // scanLine(&p);
    scanPoint(&p->a);
    scanPoint(&p->b);
}
```

#### Весь код

```c
#include <stdio.h>
#include <math.h>
#include <assert.h>

typedef struct {
    int x;
    int y;
} Point;  
typedef struct{
    Point a;
    Point b;
} Line;    
  
// Работаем с точкой
void printPoint(Point p);
void scanPoint(Point * p);          // scanPoint(&p);

float distance(Point p1, Point p2);
int is_equal(Point p1, Point p2);

Point movePoint1(Point p, int dx);       // x = inc(x);
void movePoint2(Point * p, int dx);      // inc(&x);

// Работаем с отрезком
void printLine(Line p);
void scanLine(Line * p);          // scanLine(&p);

float length(Line p1);
int is_equalLine(Line p1, Line p2);

Line moveLine1(Line p, int dx);       // x = inc(x);
void moveLine2(Line * p, int dx);      // inc(&x);


void testPoint()
{
    Point p1 = {4, 3};
    Point p2 = {-4, -3};
    printPoint(p1);     // (4,3)
    
    float d = distance(p1, p2);
    assert(d == 10);

    Point p_new = movePoint1(p1, 2);     // 6, 3
    printPoint(p_new);
    Point exp_point = {6, 3};
    assert(is_equal(exp_point, p_new));
    
    exp_point.x += 2;
    movePoint2(&p_new, 2);
    printPoint(p_new);              // 8, 3
    assert(is_equal(exp_point, p_new));
    
    Point t;
    scanPoint(&t);
    printPoint(t);
    
    printf("\n");
}    
int main()
{
    Line s = {{2, 3}, {5, 7}};
    printLine(s);
    assert(length(s) == 5);
    printf("length=%.2f\n", length(s));
    
    Line s_new = moveLine1(s, 3);
    printLine(s_new);
    Line exp_line = {{5, 3}, {8, 7}};
    assert(is_equalLine(s_new, exp_line));

    exp_line.a.x += 3;
    exp_line.b.x += 3;
    moveLine2(&s_new, 3);
    printLine(s_new);
    assert(is_equalLine(s_new, exp_line));
    
    Line s3;
    scanLine(&s3);
    printLine(s3);
    
    return 0;
}
void scanLine(Line * p)
{
    // scanLine(&p);
    scanPoint(&p->a);
    scanPoint(&p->b);
}
void moveLine2(Line * p, int dx)
{
    movePoint2( &p->a, dx);
    movePoint2( &p->b, dx);
}    
Line moveLine1(Line s, int dx)
{
    Line res;
    res.a = movePoint1(s.a, dx);
    res.b = movePoint1(s.b, dx);
    return res;
}

float length(Line p1)
{
    return distance(p1.a, p1.b);
}    
int is_equalLine(Line p1, Line p2)
{
    return is_equal(p1.a, p2.a) && is_equal(p1.b, p2.b);
}
void printLine(Line p)
{
    // printf("(%d,%d) (%d,%d)", p.a.x, p.a.y, p.b.x, p.b.y); 
    printPoint(p.a);
    printPoint(p.b);
    printf("\n");
}
void scanPoint(Point * p)
{
    int x, y;
    scanf("%d%d", &x, &y);
    p->x = x;
    p->y = y;
}

void movePoint2(Point * p, int dx)
{
    p->x += dx;
}
Point movePoint1(Point p, int dx)
{
    Point res = p;
    res.x += dx;
    return res;
}

int is_equal(Point p1, Point p2)
{
    return p1.x == p2.x && p1.y == p2.y;
}    

float distance(Point p1, Point p2)
{
    int dx = p1.x - p2.x;
    int dy = p1.y - p2.y;
    return sqrt(dx*dx + dy*dy);
}
 
void printPoint(Point p)
{
    printf("(%d,%d) ", p.x, p.y);
}
```

## Sruct: контрольные вопросы

### Имена
Дана структура и фрагмент кода:

```c
struct Vector
{
    float x;
    float y;
};


int main()
{
    struct Vector vec;
    int x, y;
    //.....
    vec.x = y;
    vec.y = y;
}
```

При таком написании: __синтаксической ошибки нет__

### Доступ к полям
Дана структура и код программы:

```c
typedef struct Vec
{
    float x;
    float y;
} Vector;


int main()
{
    Vector vec;
    Vector * pvec;
    int x, y;
    pvec = &vec;
    pvec.x = x;
    vec.y = y;
}
```

При таком написании: __компилятор выдаст ошибку, так как для доступа к атрибуту через pvec нужно использовать ->__

Дана структура и код программы:

```c
typedef struct Vec
{
    float x;
    float y;
} Vector;


int main()
{
    Vector vec;
    Vector * pvec;
    int x, y;
    pvec->x = x;
    vec.y = y;
    printf("x: %f y: %f\n", pvec->x, vec.y);
}
```

При таком написании: __результат работы программы не определён, так как pvec не получает адреса переменной-структуры__

### Адрес атрибута х
Дана структура и код программы:

```c
typedef struct Vec
{
    int x;
    int y;
} Vector;


int main()
{
    Vector vec;
    Vector * pvec
    int x, y;
    int *px;
    pvec = &vec;
    // необходимо получить адрес атрибута x
    // ...
}
```

Адрес атрибута x: __px = &pvec->x;__

### Копирование поля
Дана структура и код программы:

```c
typedef struct Vec
{
    int x;
    int y;
} Vector;


// реализация функции
int funct(Vector *a, Vector b)
{
 // здесь должен быть код
};
```

При копировании из b в a поля x правильным написанием будет: __a->x = b.x;__

## Struct: задачи

### time_struct 12-часовой циферблат

Ручные часы имеют 12 часовой циферблат (от 00:00 до 11:59).

Для хранения и представления показаний часов используется структура:

```c
typedef struct{
    int h; // часы
    int min; // минуты (от 0 до 59)
}TicTac;
```

Написать следующие функции для работы с часами:

```c
// получает показание часов a и возвращает показание этих часов
// через min минут, .
TicTac after(TicTac a, int min);

// "переводит" вперед стрелки этих часов (me)
// на a.h часов и a.min минут
void forward(TicTac * me, TicTac a);

// "переводит" назад стрелки этих часов (me)
// на a.h часов и a.min минут
void backward(TicTac * me, TicTac a);

// проверяет совпадают ли показания часов a и b
// если совпадают, возвращает 1, если нет - 0
int isEqualTime(TicTac a, TicTac b);

// печатает показания этих часов в формате hh:mm\n
void printTic(TicTac a);
```

Посылать только реализации нужных функций. Если вы пишете дополнительные функции, например, time2min и min2time, то посылать все дополнительные функции.

Объявление структуры и функцию main посылать не нужно. Они уже есть в проверяющей системе.

Для проверки функций используется код:

```c
int main(){
    TicTac a,b,c;
    int mk;

    scanf("%d:%d", &(a.h), &(a.min));
    scanf("%d", &mk);
    scanf("%d:%d", &(b.h), &(b.min));

    printf("equal: %d\n",isEqualTime(a,b));
    c = after(a, mk);
    printf("after: ");
    printTic(c);

    c = a;
    printf("forward: ");
    forward(&a, b);
    printTic(a);

    printf("backward: ");
    backward(&c, b);
    printTic(c);

    return 0;
}
```

```c
void printTic(TicTac a);

// получает показание часов a и возвращает показание этих часов
// через min минут, .
TicTac after(TicTac a, int min) {
    TicTac result;
    result.min = (a.min + min) % 60;
    result.h = (a.h + (a.min + min) / 60) % 12;
    return result;
}

// "переводит" вперед стрелки этих часов (me)
// на a.h часов и a.min минут
void forward(TicTac* me, TicTac a) {
    me->h = (me->h + a.h + (me->min + a.min) / 60) % 12;
    me->min = (me->min + a.min) % 60;
}

// "переводит" назад стрелки этих часов (me)
// на a.h часов и a.min минут
void backward(TicTac* me, TicTac a) {
    int min = (me->min - a.min) < 0 ? -1 : 0;
    me->h = (12 + me->h - a.h + min) % 12;
    me->min = (60 + me->min - a.min) % 60;
}

// проверяет совпадают ли показания часов a и b
// если совпадают, возвращает 1, если нет - 0
int isEqualTime(TicTac a, TicTac b) {
    if (a.h == b.h && a.min == b.min) return 1;
    return 0;
}

// печатает показания этих часов в формате hh:mm\n
void printTic(TicTac a) { printf("%02d:%02d\n", a.h, a.min); }
```

### struct_line_0rotR Поворот

Написать функцию

```c
void rotRLine(struct Line * t)
```

Она поворачивает отрезок на плоскости XY на 90 градусов по часовой стрелке вокруг точки (0,0).

Напечатайте полученный отрезок и его длину с точностью до 3 десятичных знаков.

Посылать на проверку всю программу.

Входные данные: 4 целых числа через пробел - x, y координаты точки - целые числа через пробел.

Выходные данные: x y координаты концов отрезка и его длина с точностью до десятичных знаков.

```c
typedef struct {
    int x;
    int y;
} Point;

typedef struct {
    Point a;    // начало отрезка
    Point b;    // конец отрезка
    float len;  // длина отрезка
} Line;

float distance(Point a, Point b);   // расстояние между точками
void scanLine(Line * t);
void printLine(Line t);
void rotRLine(Line * t);

int main() {
    Line t;

    scanLine(&t);
    // тут должен быть вызов функции rotRLine
    printLine(t);

    return 0;
}
```

### struct_colors Цвета RGB
__В языке Си числа печатаются и читаются в шестнадцатеричной системе счисления по формату %X или %x, в десятичной системе счисления по формату %d__

```c
unsigned int k = 255;
printf("%X\n", k);      // FF - большими буквами
printf("%x\n", k);      // ff - маленькими буквами
printf("%u\n", k);      // 255, unsigned int
printf("%d\n", 255);    // 255, int
```

Для описания цветов при отображении на мониторе существуют разные форматы.

Один из форматов RGB: все цвета получаются смешением красного (red), зеленого (green) и синего (blue) различной интенсивности. Интенсивность можно описать структурой:

```c
typedef struct
{
    unsigned char red;
    unsigned char green;
    unsigned char blue;
} Color;
``` 

Эти же цвета используются в "HTML"-формате. В этом случае цвет представляется шестизначным шестнадцатеричными числами, записанными в символьном виде. Старшие разряды соответствуют числу "red" RGB-формата, следующие два - "green", младшие - "blue". Число записывается в переменные типа

```c
unsigned long long
```

Например, если в формате Color

```c
red = 255; green = 128; blue = 22;
```

то в HTML-формате будет записано

```c
FF8016
```

Требуется написать функции:

```c
// считать RGB-формат с консоли
Color getColor();
// перевод из RGB-формата в число
unsigned long long convertToHTML(Color);
// преобразование числа цвета в RGB-формат
Color convertToRGB(unsigned long long);
// печать цвета в RGB-формате (печать значений в десятичном виде через пробел)
// red green blue:
// 255 128 222
// Печатать только числа через пробел и \n в конце!!!
void printRGB(Color);

// печать цвета в HTML-формате и \n в конце.
// Примеры: FFA902 0AA3FF
void printHTML(Color);
```

Отправлять только функции.

Функции будут проверяться так:

```c
int main(){
    Color z, z2;
    unsigned long long html;

    z = getColor();
    printRGB(z);

    html = convertToHTML(z);
    printf("%llu\n", html);
    printHTML(z);

    z2 = convertToRGB(html);
    printRGB(z2);

    return 0;
}
```
