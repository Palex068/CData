# 10. Библиотеки ввода вывода

Почти в любом приложении приходится читать или записывать файлы, а также выполнять другие операции ввода—вывода. Qt обеспечивает поддержку ввода—вывода при помощи QIODevice — мощной абстракции «устройств», способных читать и записывать блоки байтов.

Qt содержит следующие подклассы QIODevice:

+ `QFile` — получает доступ к файлам, находящимся в локальной файловой системе или внедренным в исполняемый модуль,
+ `QTemporaryFile` — создает временные файлы в локальной файловой системе и получает доступ к ним,
+ `QBuffer` — считывает или записывает данные в `QByteArray`,
+ `QProcess` — запускает внешние программы и обеспечивает связь между процессами,
+ `QTcpSocket` — передает поток данных по сети, используя протокол TCP,
+ `QUdpSocket` — передает и принимает из сети дейтаграммы UDP.

`QProcess`, `QTcpSocket` и `QUdpSocket` позволяют получить доступ к данным всего один раз по порядку от первого байта к последнему, т.е. являются последовательными устройствами. `QFile`, `QTemporaryFile` и `QBuffer` позволяют считывать байты из любой позиции, т.е. являются устройствами произвольного доступа и используют функцию `QIODevice::seek()` для изменения положения указателя файла.

Кроме этих устройств Qt предоставляет два класса высокоуровневых потоков данных, которые можно использовать для чтения и записи на любое устройство ввода—вывода:

+ `QDataStream` для двоичных данных и
+ `QTextStream` для текста.

Эти классы учитывают такие аспекты, как порядок байтов и кодировка текста, позволяя работающим на разных платформах и в разных странах приложениям Qt считывать и записывать файлы друг друга.

`QFile` позволяет легко получать доступ к отдельным файлам, независимо от того, располагаются они в файловой системе или оказываются внедренными в исполняемый модуль приложения как ресурсы. Для приложений, которым приходится работать с целыми наборами файлов, в Qt предусмотрены классы `QDir` и `QFileInfo`, которые позволяют работать с каталогами и получать сведения о файлах, расположенных внутри каталогов.

Класс `QProcess` позволяет запускать внешние программы и устанавливать связь с ними через стандартные каналы ввода, вывода и ошибок (`cin`, `cout` и `cerr`). Мы можем устанавливать переменные среды и рабочий каталог, которые будут использоваться внешним приложением.

## Ввод и вывод в консоли

По умолчанию язык С++ не содержит встроенных средств для ввода с консоли и вывода на консоль, эти средства предоставляются библиотекой `iostream`.

В ней определены два типа: `istream` и `ostream`:

+ `istream` представляет поток ввода, а
+ `ostream` - поток вывода.

Для записи или вывода символов на консоль применяется объект `cout` (console output — вывод на консоль), который представляет тип ostream. А для чтения с консоли используется объект ст (console input — ввод с консоли).

Для использования этих объектов в начало исходного файла необходимо подключить библиотеку `iostream`:

```cpp
#include <iostream>
```

## Вывод данных на консоль

Объект `cout` используется для вывода обычных сообщений в окно консоли.

Объекты `cerr` и `clog` применяются для вывода сообщений об ошибках. Так же как и объект `cout` объекты `cerr` и `clog` первоначально связаны с окном консоли, однако возможно перенаправить поток на другое устройство или в файл.

Для вывода на консоль применяется оператор `<<`. Этот оператор получает два операнда. Левый операнд представляет объект типа `ostream`, в данном случае объект `cout`. А правый операнд - значение, которое надо вывести на консоль.

После подключения файла `iostream` все объекты будут доступны через пространство имен `std`, поэтому при обращении к объекту необходимо указать название пространства имен и два символа двоеточия перед названием объекта.

Например, вывести строку "Hello, world!" можно так:

```cpp
std::cout << "Hello, world!";
```

Вывести сообщение об ошибке можно следующим образом:

```cpp
std::cerr << "Error 1";
std::clog << "Error 2";
```

Так как оператор `<<` возвращает левый операнд - `cout`, то с помощью цепочки операторов мы можем передать на консоль несколько значений.

Например:

```cpp
# include <iostream>

int main() {
  int age = 23;
  std::cout << "Name: " << "Tatiana" << "\n";
  std::cout <<  "Age : " << age << std::endl;
  return O;
}
```

В консоли видим следующее:

```sh
Name: Tatiana
Age: 23
```

## Ввод данных с консоли

Объект `cin` позволяет ввести данные любого встроенного типа, например, число, символ или строку.

Для считывания с консоли данных применяется оператор ввода `>>`, который принимает два операнда. Левый операнд представляет объект типа `istream` (в данном случае объект `cin`), с которого производится считывание, а правый операнд - объект, в который считываются данные.

Для примера использования `cin` произведем суммирование двух целых чисел, введенных пользователем:

```cpp
#include <iostream>

int main() {
  std:: setlocale (LC_ALL, "Russian_Russia.1251");
  int x = 0, y = 0;
  std::cout << "x = ";  // Вывод подсказки
  std::cout.flush();    // Сброс буфера вывода
  std::cin >> х;        // Ввод числа
  std::cout << "y = ";  // Вывод подсказки
  std::cout.flush();    // Сброс буфера вывода
  std::cin >> у;        // Ввод числа
  std::cout << "Sum: " << x + y << std::endl;
  return 0;
}
```

Здесь происходит подключение заголовочного файлов `iostream` и `clocale`. Внутри функции `main()` с помощью `setlocale()` настраивается локаль и объявляются две локальные переменные `х` и `у`. `int` означает, что объявляются целочисленные переменные. Переменным сразу присваивается начальное значение (`0`) с помощью оператора `=`.

Далее посредством объекта `cout` выводится подсказка для пользователя, благодаря которой пользователь будет знать, что от него требуется. вызов метода `flush()` объекта `cin` сбрасывает данные из буфера потока вывода `stdout` в консоль. Если буфер не сбросить, пользователь не увидит подсказку.

После ввода числа по нажатию клавиши `Enter` значение будет присвоено переменной `х`.

```sh
x = 1
y = 3
Sum: 4
```

При вводе данных производится попытка преобразования к типу переменной.

Однако, пользователь вместо числа может ввести все что угодно, например, строку, не содержащую число. В этом случае преобразование закончится неудачей, переменной не будет присвоено значение, а введенное значение останется в буфере и будет автоматически считано следующей операцией ввода.

Проверить отсутствие ошибки при преобразовании можно с помощью метода `good()` объекта `cin`. Прототип метода:

```cpp
bool good() const;
```

Метод `good()` возвращает логическое значение `true` , которое соответствует числу `1`, если ошибок не произошло, или значение `faIse`, соответствующее числу `0`, в противном случае.

Вывести сообщение об ошибке и прервать выполнение программы можно так:

```cpp
#include <iostream>

int main() {
  std:: setlocale (LC_ALL, "Russian_Russia.1251");
  int x = 0, y = 0;
  std::cout << "x = ";  // Вывод подсказки
  std::cout.flush();    // Сброс буфера вывода
  std::cin >> х;        // Ввод числа
  std::cout << "y = ";  // Вывод подсказки
  std::cout.flush();    // Сброс буфера вывода
  std::cin >> у;        // Ввод числа
  if (std::cin.good() == false) {
    std::cout << "Error" << std::endl;
    return 1; // Выходим из функции main()
  }
  return 0;
}
```

Если выражение возвращает логическое значение `true`, то будут выполнены инструкции внутри фигурных скобок. Если выражение возвращает значение `false`, то инструкции внутри фигурных скобок игнорируются и управление передается инструкции, расположенной сразу после закрывающей фигурной скобки. Проверка значения, возвращаемого методом `good()`, осуществляется с помощью оператора `==`.

При ошибке метод `good()` вернет значение `false`, следовательно, условие `false` == `false` будет истинным. В этом случае выводим сообщение об ошибке и выходим из фунщии `main()` (и, следовательно, из программы), возвращая значение `1`.

## Домашнее задание

Написать программу «Чек-лист» используя структуры и циклы.

В приложении должно быть реализовано следующее:

+ Добавление пунктов (задач), с описанием (название, дата, приоритет). (удовлетворительно)
+ Удаление и редактирование пунктов. (хорошо)
+ Поиск по каталогу. (отлично)
