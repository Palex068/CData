# 04.Способы организации данных

Ранее мы разобрали как строить языковые конструкции, и там встречались свои правила и рекомендации. В этой части методички мы будем говорить об общих правилах написания кода.

## Последовательность написания кода

### Шаг №1

В начале файла обычно (не обязательно) перечисляются построчно подключаемые библиотеки.

Библиотеки сильно облегчают жизнь программиста. Мы разберем стандартные и необходимые для задач диспетчеризации библиотеки. Каждая библиотека подключается с помощью директивы:

```cpp

#include <название_библиотеки_из_числа_системных_библиотек> // или
#include "название_пользовательской_библиотеки_из_папки_проекта"
```

### Шаг №2

Настраиваем рабочее место, вводя конкретные переменные и функции, на которые будем ссылаться в теле программы:

```cpp
using пространство_имен::идентификатор;
```

**способ_хранения_данных** (называется модификатор хранения переменной `const`|`extern`|`static`)

**тип_данных** (`bool`|`float`|`int`|...) имя (придумываем идентификатор) = инициализатор (присваиваем
имени конкретное значение в виде литерала).

### Шаг №3

Можем (не обязательно) объявить и определить свои типы данных для работы программы, которых нет в стандартной библиотеке (STD).

### Шаг №4

Объявляем глобальные переменные - `declaration statements`.

---

**Важный факт!**

Для быстродействия программы и большего контроля программиста нужно использовать меньше глобальных переменных и больше локальных переменных. Локальные переменные будут записываться внутри функций, которые их используют.<br>
При таком использовании локальных переменных нужно помнить об ограничениях области видимости - использовать локальную переменную можно только в теле функции (внутри фигурных скобок "{}"), где она объявлена.

При описании типа данных память не выделяется. При объявлении переменных место в памяти выделяется.

---

### Шаг №5

Пишем реализацию функции `int main(int argc, char **argv, char **envp)` – то, что в скобках не обязательно.

Типом данных `int` мы определяем тип данных возвращаемого значения (для функции "`main`" это всегда "`int`");

`main` – идентификатор главной функции программы (с него начинается исполнение программы);

в круглых скобках описаны входные данные, последовательность которых нужно соблюдать:

+ количество аргументов: `int argc`, где "`int`" тип данных, а "`arg + c`" количество аргументов
+ адрес места в памяти, где расположен массив адресов строк: `char **argv`, где "`char`" - целочисленный тип данных для хранения символов с помощью таблицы кодировки, "`**`" - указатель двухмерного массива, "`argv`" – `arguments vector` идентификатор массива строк, `envp` – `environment pointer` указатель на массив переменных системы.

---
**Важный факт!**

Количество звёзд указывает на количество измерений в массиве. Измерений может быть больше чем нужно.

---

### Шаг №6

Пишем реализацию функции "`main`" в `{}` (желательно писать каждую фигурную скобку на новой строке – так мы отделим тело программы для удобства восприятия).

Минимально требуется указать "`return 0;`", чтобы выполнить программу ради её выполнения.

## Директивы препроцессора (дополнение к шагу №1)

**Директивы препроцессора** – препроцессор нужен для предобработки текста перед тем, как он пойдёт на компиляцию. В процессе предобработки все идентификаторы макросов распаковываются, комментарии и отступы стираются.

**Заголовочные файлы библиотек содержат директивы препроцессора.**

Для того, чтобы каждый раз не писать один и тот же код, в системном программировании так же, как и при программировании ПЛК используются макросы.

Для того, чтобы пользоваться макросами необходима программа – препроцессор. Препроцессор заменяет токены в вашем коде на заранее подготовленный текст. Для этого есть 13 специальных команд – директив.

Пишется так: `#ключевое_слово`

Директивы кроме `#include` мы использовать не будем, т.к. все остальные директивы нужны для создания библиотек, а для диспетчеризации создавать библиотеки не нужно.

Каждая библиотека может содержать в себе команды и данные:

+ `#include` подгружает файл в программу;
+ `#define` – создаёт макрос или константу;
+ `#undef` – удаляет макрос или константу;
+ `#if` – описывает условие, при котором вставится макрос;
+ `#else` – разделяет блоки, предоставляющие выбор в зависимости от условия;
+ `#elif` – разделяет блоки и добавляет ещё одно условие;
+ `#ifdef` – исполнение при наличии макроса или константы;
+ `#ifndef` – исполнение при отсутствии макроса или константы;
+ `#line` – указание имени файла и номера текущей строки;
+ `#error` – вывод ошибки и остановка компилятора;
+ `#warning` – вывод ошибки без остановки компилятора;
+ `#pragma` – для настройки компилятора;
+ `#endif` – служит для завершения любой из директив.

## Правила составления функции

Для того, чтобы написать функцию необходимы 2 части: `declaration` (объявления – ТЗ на функцию) и `definition` (реализация тело функции).

### Declaration

+ Определить формат хранения функции (могут использоваться в комбинациях, по одиночке или вовсе отсутствовать):
  + `extern` - функция описана в другом месте, и мы хотим её использовать;
  + `inline` - позволяет при компиляции распаковать код функции и вставить его в места вызова. При этом достигается оптимизация кода для быстродействия (размер `*.exe` файла увеличивается, т. к. мы не используем ссылки, а каждый раз повторяем код).<br>
    Есть другие форматы хранения функций: `static`|`virtual`|`private`|`public`|`protected` - их разберём позже.
+ Записываем тип данных возвращаемого значения:
  + `int`|`float`|`bool` и другие.
+ Придумываем идентификатор для вызова этой функции в будущем (функция должна начинаться с маленькой буквы).
+ Составляем список аргументов (список данных, с которыми будет работать функция) в "`()`": (тип_данных имя_переменной, тип_данных имя_переменной,...).

### Definition

+ Начинается и заканчивается фигурными скобками "`{}`".

---
**Важный факт!**<br>
Для командной работы и написания "вежливого" кода, "`declaration`" мы указываем в начале файла, а в конце повторяем "`declaration`" и после пишем "`definition`".

---

## Как работает тело функции? Или составляем ТЗ на функцию

У нас есть входные переменные (в круглых скобках), есть выходная (для функции "`main`" это "`return 0;`").

В процессе проектирования мы должны определиться с количеством и типом необходимых данных.

Также нужно определиться с типом результирующего значения функции.

Нужно руководствоваться правилу: одна функция выполняет 1 логическую задачу:

+ изменения ранее объявленных переменных – результат процесса вычисления;
+ вызов системных функций – для ввода-вывода;
+ возвращение результата;
+ получение пользовательского ввода;
+ обработка и вывод значения пользователю.

---

**Важный факт!**<br>
Часто в библиотеках и функциях, которые отвечают за ввод-вывод информации, используется аббревиатура "`io`" – это `input-output`.

## Как работать с данными

Многим функциям требуется работать с большим количеством данных.

Для того, чтобы систематизировать работу с данными используются `struct` (структуры) и `class` (классы).

Структуры используют, чтобы хранить данные, а классы нужны, чтобы данные и хранить, и обрабатывать в одном месте.

Структура выглядит, как список объявления переменных. Каждая переменная имеет простой (переменной присваивается конкретное значение) или сложный тип (переменная является ссылкой).

А класс выглядит, как список объявления переменных и функций.

Позже мы разберем классы подробнее.

Для хранения однотипных данных и возможности обращаться к ним по порядковому номеру используют массивы.

Чтобы объявить массив нужно указать тип данных, придумать идентификатор, написать количество элементов в "`[ ]`" и в конце можно инициализировать (задать начальное значение) массива, написав = {через запятую перечисляем элементы массива в виде цифровых литералов}.

В квадратных скобках "`[ ]`" желательно писать не цифру, а константу, которую нужно объявить заранее.

Чтобы объявить константу пишем:

```cpp
const int size1 = 16;
int massiv1[size1] = {7, 11, 4, 10, 2, 12, 14, 8, 16, 1, 17, 13, 5, 3, 15, 6};

int main (…)
{
    //тело функции пишется в соответствии с рекомендациями 
    //описанными в заявлении итерации;
return 0;
}
```

## Домашнее задание

Задан массив из 16 чисел. В нём фигурируют числа от 1 до 17 в произвольном порядке (числа не повторяются). Одно из чисел данного диапазона пропущено.

Задача - написать программу, находящую пропущенное число. Это может быть любое число в заданном диапазоне. Алгоритм должен находить решение при любом из пропущенных чисел.

Пропущенное число может быть только одно.

Пример массива: [7, 11, 4, 10, 2, 12, 14, 8, 16, 1, 17, 13, 5, 3, 15, 6].

## Массивы

**Массив** — совокупный тип данных, который позволяет получить доступ ко всем переменным одного и того же типа данных через использование одного идентификатора.

Рассмотрим случай, когда нужно записать результаты тестов 30 студентов в классе. Без использования массива нам придется выделить 30 почти одинаковых переменных.

```cpp
// Выделяем 30 целочисленных переменных (каждая с разным именем)
int testResultStudent1;
int testResultStudent2;
int testResultStudent3;
// ...
int testResultStudent30;
```

С использованием массива всё гораздо проще. Следующая строка эквивалентна коду, приведенному выше:

```cpp
int testResult[30]; // выделяем 30 целочисленных переменных, используя фиксированный массив
```

В объявлении переменной массива мы используем квадратные скобки `[]`, чтобы сообщить компилятору, что это переменная массива, а в скобках — количество выделяемых элементов.

В примере, приведенном выше, мы объявили фиксированный массив с именем `testResult` и длиной 30. Фиксированный массив представляет собой массив, размер которого известен во время компиляции. При создании `testResult`, компилятор выделит 30 целочисленных переменных.

Вместо динамических массивов рекомендуется использовать `std::vector<>`

Шаблон `vector` расположен в заголовочном файле `<vector>`. Как и все стандартные компоненты, он расположен в пространстве имён `std`. Данный интерфейс эмулирует работу стандартного массива C (например, быстрый произвольный доступ к элементам), а также некоторые дополнительные возможности, вроде автоматического изменения размера вектора при вставке или удалении элементов.

**Дека** (`deque`) — это сокращенная фраза «double-ended-queue», что, в переводе с английского, означает — двусторонняя очередь.

Контейнер Дек очень похож на контейнер — Вектор, так же как и Вектора, Деки являются динамическими массивами. Разница между Вектором и Деком состоит лишь в том, что в деках динамический массив открыт с двух сторон. Это и позволяет очень быстро добавлять новые элементы как в конец, так и в начало контейнера. В векторах элементы можно добавлять лишь в конец массива.

**list** - не упорядоченный в памяти массив, связь между элементами осуществляется путем сохранения указателя на следующий и/или предыдущий элемент. Быстрый произвольный доступ - подразумевает доступ к N элементу за константное время. Лист же предоставляет доступ лишь за линейное время, т.к. для доступа к N элементу необходимо перебрать все предыдущие элементы.

**map** — стандартный шаблонный класс библиотеки языка программирования C++, предназначенный для реализации абстракции отображения в виде упорядоченного ассоциативного контейнера.

Элементами класса `map` являются пары из ключей и соответствующих им значений. Хранение элементов класса map реализовано в упорядоченном виде на основании критерия сортировки, который применяется по значениям ключей. Благодаря упорядоченной структуре контейнера map операции поиска или внесения нужного элемента могут быть выполнены за логарифмическое время `0(logn)`.

**unordered_map** - шаблон класса описывает объект, управляющий последовательностью элементов типа с различной длиной `std::pair<const Key, Ty>`.

Последовательность слабо упорядочена хэшфункцией, которая разделяет последовательность в упорядоченный набор подпоследовательностей, называемых блоками.

В каждом блоке функция сравнения определяет, упорядочена ли каждая пара элементов соответствующим образом.

Каждый элемент содержит два объекта:

+ ключ и
+ значение сортировки.

Последовательность представляется в виде, позволяющем выполнять поиск, вставку и удаление произвольного элемента несколькими операциями, которые могут не зависеть от числа элементов в последовательности (постоянное время), по крайней мере, когда все блоки имеют примерно одинаковую длину.

Мы будем использовать простые фиксированные массивы (известной длины) для простых задач, например, для описания массива аналоговых входов контроллера. И будем использовать `QVector` для большинства других задач.

Что же касается производительности систем, то до тех пор, пока данная задача не выявится - нет большого смысла всерьёз тратить время на расчёт того, какой способ организации массива (`Vector`, `Deque`, `Map`, `List`, и т.д.) наиболее эффективен с точки зрения производительности, в ваших условиях.

## Циклы

Для выполнения некоторых действий множество раз в зависимости от определенного условия используются циклы. В языке C++ имеются следующие виды циклов:

+ for
+ while
+ do...while

Если мы знаем точное количество действий (итераций) цикла, то можем использовать цикл `for`.

Синтаксис его выглядит примерно так:

```cpp
for (действие до начала цикла; условие продолжения цикла; действия в конце каждой итерации
цикла) {
  инструкция цикла 1;
  инструкция цикла 2;
  ...
  инструкция цикла N;
}
```

Итерацией цикла называется один проход этого цикла.

Когда мы не знаем, сколько итераций должен произвести цикл, нам понадобится цикл `while` или `do...while`. Синтаксис цикла `while` в C++ выглядит следующим образом.

```cpp
while (Условие) {
  Тело цикла;
}
```

Данный цикл будет выполняться, пока условие, указанное в круглых скобках является истиной.

Цикл `do while` очень похож на цикл `while`. Единственное их различие в том, что при выполнении цикла `do while` один проход цикла будет выполнен независимо от условия.

Рассмотрим программу, демонстрирующую использование циклов различных видов:

```cpp
#include <cstdio>
// std-означает стандартную библиотеку с++ и
// данная директива позволяет не указывать префикс
// std:: перед каждой функцией этой библиотеки
using namespace std;

int main() {
  // рассмотрим цикл for, пусть цикл выполнится 10
  // раз и выведет значение счетчика цикла в каждой итерации

  for (int i = 0; i < 10; i++) {
    printf("for iteration = %d\n", i);
  };
  // рассмотрим цикл while, пусть цикл завершится, когда счетчик
  //  достигнет значение 5 и выведет значение переменной в каждой итерации
  int j = 0;
  while (j < 5) {
    printf("while iteration = %d\n", j);
    // переменная сама не увеличится, чтобы цикл не выполнялся
    //  бесконечно, увеличим значение переменной
    j++;
  };

  // рассмотрим цикл do-while, пусть цикл завершится, когда счетчик
  //  достигнет значение 5 и выведет значение переменной в каждой итерации
  int k = 0;
  do {
    printf("do-while iteration = %d\n", k);
    k++;
  } while (k < 5);

  return 0;
};
```

```sh
for iteration = 0
for iteration = 1
for iteration = 2
for iteration = 3
for iteration = 4
for iteration = 5
for iteration = 6
for iteration = 7
for iteration = 8
for iteration = 9
while iteration = 0
while iteration = 1
while iteration = 2
while iteration = 3
while iteration = 4
do-while iteration = 0
do-while iteration = 1
do-while iteration = 2
do-while iteration = 3
do-while iteration = 4
```
