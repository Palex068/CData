# 06.Организация памяти

Ранее мы узнали, что классы нужны, чтобы хранить и обрабатывать данные. Сейчас мы составим ТЗ на программу. После разберем, где хранятся данные, и запроектируем программу архивирования данных при помощи файлов и классов.

## Составляем тз на программу

Последовательность действий:

1. Изучаем тех. процесс и составляем список функций. Уточняем вероятность расширений.
2. Определяем главную функцию.
3. Определяем какие входные данные необходимы для исполнения функций.
4. Определяем с какой аппаратной частью нужно будет для этого взаимодействовать.
5. Решаем, что будет с данными, полученными в результате работы программы: что выводим на экран, что архивируем, а что передаем другим программам и устройствам.

## Где хранятся данные?

Во время работы программы данные из файловой системы загружаются в оперативную память машины, на которой это приложение запущено.

Чтобы реализовать механизм архивирования данных можно пойти 2-я путями:

1. Написать свой собственный алгоритм логирования данных в файловую систему на С++.
2. Или использовать готовую базу данных, но для этого нужно выучить запросы языка SQL или его альтернативы. База данных будет являться отдельным приложением. Приложение должно быть запущено, и к нему должен быть доступ.

**База данных** – это готовая, оптимизированная программа, которая сама обрабатывает и выдает запрашиваемые данные. Важным качеством базы данных является возможность единовременного доступа и последовательного изменения (накапливается очередь задач) данных несколькими пользователями. Базы данных часто запускают на серверах. Для разработки системы диспетчеризации мы будем использовать файловую систему, но это можно сделать и с помощью реляционной (табличного типа) базы данных. Для работы с реляционной базой данных нужно использовать запросы на языке SQL. Чтобы запросы работали, в программу нужно добавить соответствующую библиотеку.

**Файловая система** – это часть операционной системы. Когда программа запускается, она загружает из жесткого диска в оперативную память необходимые для своей работы данные.

Приложение может догружать в оперативную память, потребовавшуюся в процессе работы информацию.

Для того, чтобы использовать файловую систему в коде используют функции стандартных библиотек ввода-вывода.

В ближайшее время вы освоите оба этих инструмента: 1-й вариант будет разобран в видео, а 2-й здесь, в методичке.

---

**Важный факт!**<br>
Оперативная память многократно быстрее, даже твердотельного накопителя, но есть как минимум 3 причины по которым мы используем SSD или даже HDD накопители: они значительно дешевле, память на них энергонезависима, а максимальный объем постоянной памяти в отличии от оперативной практически не ограничен.

**Выбор способа архивации данных каждый раз остаётся за программистом и определяется такими факторами как:**

+ количество обрабатываемых данных;
+ частота запросов на чтение, вставку;
+ необходимость изменения и удаления данных;
+ количество источников данных;
+ необходимость аналитики данных;
+ быстродействие и требовательность к ресурсам итогового решения;
+ количество времени на реализацию.

---

### Про классы

При написании кода с большим количеством данных и функций возникает необходимость держать много идентификаторов в голове. Это неудобно и часто приводит к ошибкам по невнимательности.

Эту проблему решают Классы. Они содержат в себе описание связанных функций и данных.

Класс позволяет создавать свои типы данных и функции – методы для работы с данными.

**Экземпляр класса** – это идентификатор, по которому мы будем вызывать поля класса. С помощью идентификатора и оператора доступа к членам "->" мы можем обратиться к экземплярам класса.

Он объявляется так:

```cpp
class Identificator_1
{
  int peremennaya1 = 13;
  float peremennaya2;
  bool peremennaya3;
  Int identificator_func1 (int a)
    {
      return this-> peremennaya1*a;
    }
}
Identificator_1 ekzemplyar_classa1;
```

Чтобы обратиться к одному из полей экземпляра класса (переменной или методу) пишем:

```cpp
ekzemplyar_classa1.peremennaya3
```

или

```cpp
ekzemplyar_classa1.identificator_funk1 (5);
```

В теле экземпляра класса функция называется методом, т. к. отражает способ взаимодействия с данными.

Когда вы вводите `ekzemplyar_classa1`.

Автоматически появляется возможное продолжение: `identificatory_funk1()`.

В скобках мы ввели значение 5, а результатом вычислений будет 5*13.

При использовании классов есть инструмент, который позволяет ограничить доступ к полям и методам – с ним мы будем меньше ошибаться, т.к. редактор даже не станет предлагать использовать поля и методы вне класса. Этот инструмент называется модификатор (или спецификатор) доступа бывает `privat`|`public`|`protected`.

+ `privat` (подразумевается, если ничего не написано) – видим поле или метод только внутри класса.
+ `public` – позволяет видеть поле или метод в любом месте программы но с учетом последовательности исполнения кода и областей видимости.
+ `protected` – к полю или методу могут получить доступ внутри любых производных классов.

## Про файлы

Класс записывают в заголовочный файл "`*.h`". Если будет удобнее отдельно выписать реализации функций (описания алгоритмов) создаем файлы исходных текстов "`*.cpp`".

Если нужны дополнительные файлы для данных, используем заголовочный файл "`*.h`".

Сама программа пишется в файле исходных текстов, и, чтобы использовать описанный класс, мы пишем: `#include "название_файла_класса.h"` в самом начале кода.

## Проектирование программы

Последовательность действий:

1. Определяем функциональные блоки.<br>
Например: открыть файл редактирование сохранение выйти из программы.
2. Группируем схожие по смыслу блоки (нужно ориентироваться на объект)<br>
Например: поиск файла, показ файла, редактирование файла, сохранение файла – всё это действия над объектом.
3. Создаем классы и называем релевантными (соответствующими смыслу и содержанию) словами.<br>
Например: логирование `Log` (хронология изменений).
4. Объявляем внутри классов функции.<br>
Например: поиск – `searchFile`, показ – `showFile`, редактирование – `editFile`, сохранение - `saveFile`.
5. Реализуем функции.<br>
Например: записываем в "`{ }`" откуда что взять, какую операцию произвести, и куда отправить результат.
6. Возвращаемся в `main` и подключаем туда классы.<br>
Например: `#include "Log.h"`
7. Создаем экземпляры класса (при необходимости)<br>
Например: `Log datalog;`
8. Инструменты подготовили, далее пишем логику программы.

## Домашнее задание

Сделать программу, которая может открывать и закрывать текстовый файл, писать в него и читать из него в консоли.

В видеоматериалах вы найдёте примеры по изученным темам.

Для желающих изучать материал или часть материала углублено, есть вторая часть методички – далее по тексту.

## Динамическое выделение памяти

Статическое выделение памяти выполняется для статических и глобальных переменных.

Память выделяется один раз (при запуске программы) и сохраняется на протяжении работы всей программы.

Автоматическое выделение памяти выполняется для параметров функций и локальных переменных. Память выделяется при входе в блок, в котором находятся эти переменные, и удаляется при выходе из него.

В большинстве случаев с этим все ОК. Однако, когда дело доходит до работы с пользовательским вводом, то эти ограничения могут привести к проблемам.

Указатели — это с самого начала переменные, уже в которых хранится адрес других переменных.

Чтобы пользоваться указателями, вам нужно использовать два оператора:

`*` — показывает значение переменной по заданному адресу (показывает, кто живет в этом номере). Если вы используете оператор `*`, то вы занимаетесь операцией разыменование указателя.

`&` — показывает адрес переменной (говорит, по какому адресу проживает этот человек).

### Как создать указатели в C++

+ В самом начале мы ставим оператор `*` (звездочку). Так мы говорим компилятору, что хотим использовать тип данных — указатель.
+ Дальше мы должны указать имя нашей переменной.
+ После знака равно нам нужно передать указателю адрес какой-то переменной, что мы и делаем с помощью оператора `&` (амперсанд).

Чтобы передать адрес какой-то переменной, от одного указателя другому, нужно опускать оператор `*` для одного указателя (от которого мы передаем второму)

Динамическое выделение памяти это способ запроса памяти из операционной системы запущенными программами по мере необходимости. Эта память не выделяется из ограниченной памяти стека программы, а выделяется из гораздо большего хранилища, управляемого операционной системой — кучи.

С++ использует новые методы работы с динамической памятью при помощи операторов `new` и `delete`:

+ `new` — для выделения памяти;
+ `delete` — для освобождения памяти.

Оператор `new` используется в следующих формах:

+ `new тип;` — для переменных
+ `new тип[размер];` — для массивов

Память может быть распределена для одного объекта или для массива любого типа, в том числе типа, определенного пользователем. Результатом выполнения операции `new` будет указатель на отведенную память, или исключение `std::bad_alloc` в случае ошибки.

Память, отведенная в результате выполнения `new`, будет считаться распределенной до тех пор, пока не будет выполнена операция `delete`.

Освобождение памяти связано с тем, как выделялась память для одного элемента или для нескольких. В соответствии с этим существует и две формы применения `delete`:

+ `delete указатель;` — для одного элемента
+ `delete[] указатель;` — для массивов

Освобождаться с помощью `delete` может только память, выделенная оператором `new`.

Нулевые указатели (указатели со значением `0` или `nullptr`) особенно полезны в процессе динамического выделения памяти. Их наличие как бы сообщаем нам: «Этому указателю не выделено никакой памяти». А это, в свою очередь, можно использовать для выполнения условного выделения памяти:

```cpp
// Если для ptr до сих пор не выделено памяти, то выделяем её
if (!ptr) ptr = new int;
```

Удаление нулевого указателя ни на что не влияет.

`delete ptr;`

Если `ptr` не является нулевым, то динамически выделенная переменная будет удалена.

Если значением указателя является нуль, то ничего не произойдет.

Динамически выделенная память не имеет области видимости, т.е. она остается выделенной до тех пор, пока не будет явно освобождена или пока ваша программа не завершит свое выполнение (и операционная система очистит все буфера памяти самостоятельно). Однако указатели, используемые для хранения динамически выделенных адресов памяти, следуют правилам области видимости обычных переменных. Это несоответствие может вызвать интересное поведение, например:

```cpp
void doSomething(){
  int *ptr = new int;
}
```

Здесь мы динамически выделяем целочисленную переменную, но никогда не освобождаем память через использование оператора `delete`. Поскольку указатели
следуют всем тем же правилам, что и обычные переменные, то, когда функция завершит свое выполнение, `ptr` выйдет из области видимости. Поскольку `ptr` — это единственная переменная, хранящая адрес динамически выделенной целочисленной переменной, то, когда `ptr` уничтожится, больше не останется указателей на динамически выделенную память.

Это означает, что программа «потеряет» адрес динамически выделенной памяти.

И в результате эту динамически выделенную целочисленную переменную нельзя будет удалить.

Утечка памяти происходит, когда ваша программа теряет адрес некоторой динамически выделенной части памяти (например, переменной или массива), прежде чем вернуть её обратно в операционную систему. Когда это происходит, то программа уже не может удалить эту динамически выделенную память, поскольку она больше не знает, где она находится. Операционная система также не может использовать эту память, поскольку считается, что она по-прежнему используется вашей программой.

Программы с серьезными проблемами с утечкой памяти могут «съесть» всю доступную память, в результате чего ваш компьютер будет медленнее работать или даже произойдет сбой.

Только после того, как выполнение вашей программы завершится, операционная система сможет очистить и вернуть всю память, которая «утекла».

Рассмотрим программу, демонстрирующую выделение памяти для динамических переменных, а также ее освобождение:

```cpp
#include <cstdio>
//std-означает стандартную библиотеку с++ и данная директива позволяет не указывать
//префикс std:: перед каждой функцией этой библиотеки

using namespace std;

int main() {
//пусть динамическая переменная array будет массивом переменных типа int
//а в переменной size будет указан размер выделяемого количества переменных
//указатель объявлен, но пока память не выделена
int *size;

//выделение памяти
size = new int;

//запись значения переменной
*size = 10;

//объявим одномерный динамический массив на size элементов и выделим память:
int *array = new int [*size];

//заполним значения массива числами от 1 до 10
for (int i=0; i<*size; i++){
  array[i]=i+1;
};

//и выведем значения на экран
for (int j=0; j<*size; j++){
  printf("element #%d = %d\n",j,array[j]);
};

//не забываем очистить память
delete size;
delete [] array;
return 0;
};
```

## Структуры данных

**Структура** - это набор данных, где данные могут быть разного типа. Например, структура может содержать несколько переменных типа `int` и несколько переменных типа `char`. Переменные, которые содержатся в структуре называются членами или полями структуры. Структуры можно определять с помощью ключевого слова `struct`.

```cpp
struct Employee{
  short id;
  int age;
  double salary;
};
```

Мы определили структуру с именем `Employee`. Она содержит 3 переменные:

+ `id` типа `short`;
+ `age` типа `int`;
+ `salary` типа `double`.

**Employee** — это простое объявление структуры. Хотя мы и указали компилятору, что она имеет переменные-члены, память под нее сейчас не выделяется. Имена структур принято писать с заглавной буквы, чтобы отличать их от имен переменных.

Одна из самых простых ошибок в C++ — забыть точку с запятой в конце объявления структуры. Это приведет к ошибке компиляции в следующей строке кода.

Чтобы использовать структуру `Employee`, нам нужно просто объявить переменную типа `Employee`:

```cpp
Employee john; // имя структуры Employee начинается с заглавной буквы, а переменная john - с маленькой
```

Объявить можно и несколько переменных одной структуры:

```cpp
Employee john; // создаем отдельную структуру Employee для John-a
Employee james; // создаем отдельную структуру Employee для James-a
```

Когда мы объявляем переменную структуры, например, `Employee john`, то `john` ссылается на всю структуру. Для того, чтобы получить доступ к отдельным её членам, используется оператор выбора члена (`.`)

Например, в коде, приведенном ниже, мы используем оператор выбора членов для инициализации каждого члена структуры:

```cpp
Employee john; // создаем отдельную структуру Employee для John-а
john.id = 8; // присваиваем значение члену id структуры john
john.age = 27; // присваиваем значение члену age структуры john
john.salary = 32.17; // присваиваем значение члену salary структуры john

Employee james; // создаем отдельную структуру Employee для James-а
james.id = 9; // присваиваем значение члену id структуры james
james.age = 30; // присваиваем значение члену age структуры james
james.salary = 28.35; // присваиваем значение члену salary структуры james
```

Как и в случае с обычными переменными, переменные-члены структуры не инициализируются автоматически и обычно содержат мусор. Инициализировать их нужно вручную.

В примере, приведенном выше, легко определить, какая переменная относится к структуре `John`, а какая — к структуре `James`. Это обеспечивает гораздо более высокий уровень организации, чем в случае с обычными отдельными переменными.

Переменные-члены структуры работают так же, как и простые переменные, поэтому с ними можно выполнять обычные арифметические операции и операции сравнения.

Рассмотрим программу, демонстрирующую создание и работу со структурами как статическими так и динамическими:

```cpp
//подключим заголовочный файл ввода-вывода, для отображения информации
#include <cstdio>

//подключим заголовочный файл string, контейнерный тип обеспечивающий работу со строками
#include <string>

//std-означает стандартную библиотеку с++ и данная директива позволяет не указывать префикс
// std:: перед каждой функцией этой библиотеки

using namespace std;

int main(){

//определим структуру
  struct Test_struct{
    int x;
    int y;
    int z;
  };

//определим еще одну структуру
  struct Test_struct_2{
    int number;

    //используя инициализацию можно заранее указать какое значение по умолчанию примет данное поле структуры
    int num2=100;
    double num3;

    //в структуру можно поместить и сложные, контейнерные типы данных
    string text;

    //а также вложить другие структуры
    Test_struct sub_struct;
  };

  //обьявим структуру
  Test_struct_2 test;

  //запишем некоторые параметры
  test.number=5;
  test.num3=3.1415926535;
  test.text="hello world!";

  //доступ к вложенной структуре происходит аналогично
  test.sub_struct.x=20;
  test.sub_struct.y=32;
  test.sub_struct.z=15;

  //отобразим на экране значения в этой структуре
  printf("number=%d\n",test.number);

  //как видно, поле num2 не было записано, однако было инициализировано значением по
  //умолчанию, в данном случае числом 100
  printf("num2=%d\n",test.num2);
  printf("num3=%f\n",test.num3);
  printf("text=%s\n",test.text.c_str());
  printf("sub struct x=%d\n",test.sub_struct.x);
  printf("sub struct y=%d\n",test.sub_struct.y);
  printf("sub struct z=%d\n",test.sub_struct.z);

  //обьявим указатель на структуру которую разместим в динамической памяти
  Test_struct_2 *test_dynamic;

  //выделим память
  test_dynamic = new Test_struct_2;

  //доступ к полям динамических структур происходит через оператор -> а не .
  test_dynamic->number=100500;

  //и отобразим это число
  printf("dynamic struct number=%d\n",test_dynamic->number);

  //не забываем очистить память
  delete test_dynamic;
  return 0;
};
```

Ниже приведены некоторые специальные классы QT, которые были использованы в видеолекциях и пригодятся для выполнения домашних заданий.

## Class QTime

`QTime` - класс для работы со временем. Ниже приведена программа, демонстрирующая его работу.

[Ссылка на официальную документацию](https://doc.qt.io/qt-6/qtime.html)

```cpp
#include <QCoreApplication>
#include <QLocale>
#include <QTime>
#include <iostream>
#include <Windows.h>

int main(int argc, char *argv[])
{
  QCoreApplication a(argc, argv);
  QLocale::setDefault (QLocale(QLocale::Russian,QLocale::RussianFederation));
  SetConsoleOutputCP(65001);
  QTime time(12, 30, 45, 650);//Инициализируем класс по порядку часы, минуты, секунды, миллисекунды

  std::cout << time.toString(Qt::DateFormat::ISODateWithMs).toStdString() << std::endl;//Мы можем использовать готовые форматы
  std::cout << time.toString("hh:mm 'm'mm 'mm' секунды:ss t").toStdString() << std::endl;//либо задать свой с помощью функции toString("формат"), разделители могут быть любыми
  //с помощью одинарных кавычек можно помечать не заменяемые символы, все остальные совпадения будут заменены
  //Далее список строк, которые заменятся на значения
  //h Часы (0 to 23)
  //hh Часы (00 to 23)
  //m Минуты (0 to 59)
  //mm Минуты (00 to 59)
  //s Секунды (0 to 59)
  //ss Секунды (00 to 59)
  //z Миллисекунды (0 to 999)
  //zzz Миллисекунды (000 to 999).
  //t Таймзона

  std::cout << time.addSecs(5).toString("hh:mm секунды:ss t").toStdString() <<
  std::endl;//Мы можем добавлять время, но при этом создается новый экземпляр класса
  std::cout << time.toString("hh:mm секунды:ss t").toStdString() << std::endl;//Эта строка выведет опять старое время
  std::cout << time.addMSecs(5).toString("hh:mm секунды:ss t").toStdString() << std::endl;//Также можно добавлять и миллисекунды
  std::cout << time.hour() << ":" << time.minute() << ":" << time.second() << ":" << time.msec() <<
  std::endl;//Можем брать отдельно части времени

  bool ok = time.setHMS(25, 66, 2, 1500);//Можем установить новое время, если передано некорректное время функция возвращает false

  std::cout << "Время верное: " << ok << " " << time.toString("hh:mm секунды:ss t").toStdString() << std::endl;//0 - время не верное и оно не выводится
  bool ok2 = time.setHMS(20, 50, 2, 300);//Время верное
  std::cout << "Время верное: " << ok2 << " " << time.toString("hh:mm секунды:ss t").toStdString() << std::endl;//1 - время верное, выводится по шаблону
  std::cout << "Текущее время: " << time.currentTime().toString("hh:mm секунды:ss t").toStdString() << std::endl;//currentTime() - возвращает новый объект с текущим временем
  std::cout << "Текущее время: " << QTime::currentTime().toString("hh:mm секунды:ss t").toStdString() << std::endl;//Мы можем использовать эту функцию через оператор расширения области видимости ::
  //Это возможно, так как эта функция объявлена как статическая, и она не использует данные из экземпляра класса
  
  return a.exec();
}
```

## Class QDate

**QDate** - класс для работы с датами. Ниже приведена программа, демонстрирующая его работу.

```cpp
#include <QCoreApplication>
#include <QDate>
#include <QLocale>
#include <iostream>
#include <Windows.h>

int main(int argc, char *argv[])
{
  QCoreApplication a(argc, argv);
  //QLocale::system();

  QLocale::setDefault(QLocale(QLocale::Russian, QLocale::RussianFederation));
  SetConsoleOutputCP(65001);
  QDate date(2006, 3, 20);//Задаем дату (инициализируем класс с помощью конструктора)

  std::cout << date.toString(Q t::D ateFormat::SystemLocaleLongDate).toStdString() <<  std::endl;//Выводим в одном из стандартных форматов
  std::cout << date.toString("yyyy:mm день:dd").toStdString() << std::endl;//можем задать свой   формат
  //Можем добавлять к дате года, месяцы и дни, но функция addYears и другие не меняют   значение экземпляра класса, а передают нам временный экземпляр

  std::cout << date.addYears(5).toString("yyyy:MM день:dd").toStdString() << std::endl;
  std::cout << date.addMonths(7).toString("yyyy:MMM день:dd").toStdString() << std::endl;
  std::cout << date.addDays(8).toString("yyyy:MMMM день:dd").toStdString() << std::endl;
  std::cout << date.day() << std::endl;//Можем получить количество прошедших дней от месяца
  std::cout << date.dayOfWeek() << std::endl;//от недели
  std::cout << date.dayOfYear() << std::endl;//от года

  int year, month, day;

  date.getDate(&year, &month, &day);//Можем задать новую дату
  
  std::cout << year << ":" << month << ":" << day << std::endl;
  
  date.setDate(2020, 1, 5);
  
  std::cout << date.toString("yyyy:MMM день:dd").toStdString() << std::endl;
  std::cout << date.fromString("1MM12car2003", "d'MM'MMcaryyyy").toString("yyyy:M день:dd").toStdString() << std::endl;
  // Можно получить данные из строки по шаблону fromString принимает первым аргументом строку, а вторым шаблон
  // В шаблоне первая d найдет день (1), потом одинарные кавычки пропускаются, MM найдет месяц, yyyy год
  // Внутри одинарных кавычек замен на данные не происходит. Это работает как для toString, так и для fromString
  // d Номер дня в формате без дополняющего нуля (1 to 31)
  // dd Номер дня в формате 2 цифр с дополняющим нулем (01 to 31)
  // ddd Сокращенное название дня недели - 3 буквы (зависит от локализации программы или системы, настраивается)
  // dddd Полное название дня недели (зависит от локализации программы или системы, настраивается)
  // M Номер месяца в формате без дополняющего нуля (1 to 12)
  // MM Номер месяца в формате 2 цифр с дополняющим нулем (01 to 12)
  // MMM Сокращенное название месяца - 3 буквы (зависит от локализации программы или системы, настраивается)
  // MMMM Полное название месяца (зависит от локализации программы или системы, настраивается)
  // yyГод в формате 2 цифр (00 to 99)
  // yyyy Год в формате 4 цифр
  return a.exec();
}
```

## Class QString

**QString** - класс для работы со строками.

[Ссылка на официальную документацию](https://doc.qt.io/qt-6/qstring.html)

Класс предлагает разные варианты инициализации через вызов конструктора. Ниже приведена программа, демонстрирующая его работу.

```cpp
#include <QCoreApplication>
#include <QLocale>
#include <iostream>
#include <Windows.h>

int main(int argc, char *argv[])
{
  QCoreApplication a(argc, argv);
  QLocale::setDefault(QLocale(QLocale::Russian,
  QLocale::RussianFederation)); SetConsoleOutputCP(65001);

  QString b,c;//Можно создать экземпляр класса без инициализации

  char str[64] = "Пример строки";

  QString d(str);//Инициализация с помощью Си-строки (массив char)

  std::cout << "Вывод строки d: " << d.toStdString() << std::endl;//"cout" умеет выводить std::string, поэтому используется функция преобразования в стандартную строку toStdString()

  QString e("Константная строка");//Инициализация с помощью константной Си-строки.
  //Есть и другие способы инициализации, но они редко используются.
  
  /*
  * Для класса реализованы функции сложения (+) и сравнения (>, <, >=, <=, ==, !=)
  */
  QString f("abcde");
  QString g("abecdа");

  std::cout << "Строка f меньше строки g: " << (f < g) << std::endl;//Необходимы скобки из-за приоритета операторов
  
  //Сравнение происходит по алфавиту
  /*
  * Есть специальная функция для сравнения строк .compare()
  * В документации она выглядит так:
  * compare(const QString &other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
  * Первый аргумент - это вторая строка для сравнения.
  * Первая строка для сравнения находится перед методом с обращением через точку,
  * а второй аргумент имеет тип перечисления, означает чувствительность к регистру, перечисления имеют ограниченное количество вариантов
  * Qt::CaseSensitivity cs = Qt::CaseSensitive
  * Qt - это библиотека.
  * Далее в её области видимости есть перечисление, используем оператор расширения области видимости ::
  * Среда разработки предлагает нам варианты.
  * И здесь либо мы уже знаем, какие есть варианты в перечислении и сразу пишем CaseSensitive, (Qt::CaseSensitive) или другие,
  * либо мы не знаем, какие есть варианты, тогда пишем название перечисления и входим в его область видимости CaseSensitivity, , (Qt::CaseSensitivity)
  * далее среда предлагает только элементы перечисления, и мы выбираем нужное
  */

  QString a1("abcde");
  QString a2("abCde");

  std::cout << "Сравнение не чувствительное к регистру:" << a1.compare(a2, Qt::CaseSensitivity::CaseInsensitive) << std::endl;

  QString b1("abcde");
  QString b2("abCde");

  std::cout << "Сравнение чувствительное к регистру:" << a1.compare(a2, Qt::CaseSensitivity::CaseSensitive) << std::endl;

  //возвращает целое число, меньшее, равное или большее нуля, если строка меньше, равна или больше

  /*
  * Есть функция добавления к концу строки append()
  */
  QString v("Программирование ");
  
  v.append("С++");
  
  std::cout << v.toStdString() << std::endl;
  /*
  * Есть функция подстановки в строку
  */
  
  int files = 5, totalSize = 4056;
  QString u;
  u = QString("Создано %1 файлов, суммарный размер: %2.");
  
  std::cout << u.arg(files,3,10,QChar(' ')).arg(totalSize,8,10,QChar(' ')).toStdString() << std::endl;//Здесь важно понять что происходит
  //Сперва вычисляется функция, которая стоит ближе всех к экземпляру объекта, в которую передаем files.
  //Далее эта функция возвращает нам строку, к которой мы применяем второй по счету метод, в который передаем totalSize
  //Он также возвращает строку, у которой вызывается метод toStdString()
  //В итоге мы работаем с 3 разными строками, и результат в переменной u не сохранится

  std::cout << u.toStdString() << std::endl;
  
  /*
  * Есть функция получения символа по индексу c провер
  */
  std::cout << u.at(32).toLatin1() << u[2345].toLatin1() << " end." << std::endl;

  /*
  * Есть функция поиска подстроки в строке contains, которая возвращает true/false, и indexOf,
  которая возвращает индекс подстроки в строке
  */
  QString str2("Пример строки");

  std::cout << "строка \"Пример строки\" содержит символ 'р':" << str2.contains(L'р', Qt::CaseInsensitive) << std::endl; // returns true
  std::cout << "строка \"Пример строки\" содержит символ 'р' на позиции:" << str2.indexOf(L'р',3, Qt::CaseSensitivity::CaseSensitive) << std::endl;
  
  /*
  * Есть функция замены подстроки в строке
  */
  std::cout << "заменяем подстроку в строке:" << std::endl;
  QString x = "Say yes!";
  QString y = "no";
  x.replace(4, 3, y);
  /*
  * Есть функция section и split, для разбора файлов типа csv, путей к файлам или web и
  подобного
  */
  QString str5;
  QString csv = "forename,middlename,surname,phone";
  QString path = "/usr/local/bin/myapp";
  
  QString::SectionFlag flag = QString::SectionSkipEmpty;
  str5 = csv.section(',', 2, 2); // str == "surname"
  str5 = path.section('/', 3, 4); // str == "bin/myapp"
  str5 = path.section('/', 3, 3, flag); // str == "myapp"
  QString str8 = QStringLiteral("a,,b,c");
  QStringList list1 = str8.split(Q Latin1Char(','));
  // list1: [ "a", "", "b", "c" ]
  
  QStringList list2 = str8.split(Q Latin1Char(','), Qt::SkipEmptyParts);
  // list2: [ "a", "b", "c" ]
  
  /*
  * Есть функции size, lenght, resize, isEmpty
  */
  std::cout << "x: " << x.toStdString() << std::endl;
  std::cout << "x.size: " << x.size() << std::endl;
  std::cout << "x.lenght: " << x.length() << std::endl;
  
  x.resize(3);
  
  std::cout << "x.resize(3): " << x.toStdString() << std::endl; x.resize(6, '_');
  std::cout << "x.resize(6, '_'): " << x.toStdString() << std::endl;
  
  x.resize(0);

  /*
  * Есть множество функций начинающихся на to..., например toInt для преобразования строки в
  число(целочисленное) или toDouble для преобразования в дробное
  */
  bool ok = true;

  QString str_int("55252");

  int _int = str_int.toInt(&ok);//Передаем ссылку на переменную ok, чтобы функция ее могла изменить, после чего мы поймем смогла ли функция конвертировать строку

  if (ok) std::cout << _int + 200 << std::endl;
  else std::cout << "Ошибка." << std::endl;
  
  return a.exec();
}
```

## Class QFile

**QFile** - класс для работы с файлами. Ниже приведена программа, демонстрирующая его работу.

```cpp
#include <QCoreApplication>
#include <QFile>
#include <QTextStream>
#include <iostream>

int main(int argc, char *argv[]) {
  QCoreApplication a(argc, argv);
  QFile fileInt("C:/Projects/QtProj\\CPP_QFile\\fileInt.txt");
  QFile file(
      "C:/Projects/QtProj\\CPP_QFile\\file.txt");  // Передаем путь к файлу,
                                                   // обратные слеши либо
                                                   // экранируем повторным
                                                   // слешем, либо ставим
                                                   // одинарные обычные слеши /
  // Пытаемся открыть файл, для этого передаем в функцию open параметры
  // открытия, это перечисления которые есть в классе QIODevice, обращаемся к
  // ним с помощью :: Мы можем написать неограниченное количество флагов,
  // разделяя из вертикальной чертой |, вертикальная черта - это бинарное или
  // например, QIODevice::ReadWrite = 3, а QIODevice::ReadOnly = 1.
  // При бинарном "или" используется бинарное представление числа соответственно

  QIODevice::ReadWrite = 00000011,
  а QIODevice::ReadOnly = 00000001

      // после бинарного "или" получится 00000011, наибольшие права доступа.
      // Так сделано во всех функциях, которые принимают флаги.

      if (file.open(QIODevice::ReadWrite | QIODevice::Text) &&
          fileInt.open(QIODevice::ReadWrite | QIODevice::Truncate))
  // Функция open возвращает true, если файл открыт и false, если произошла
  // ошибка
  {
    QTextStream ts(&file);  // Создаем текстовый поток ввода-вывода, на основе
                            // открытого файла, передаем адрес файла
    ts << " world!";  // Если пишем в поток ввода-вывода, используем операторы
                      // <<
    char data0[100];
    ts >> data0;  // Для чтения >> аналогично cout/cin
    std::cout << data0 << std::endl;
    char data1[100] = "Hello!";
    char data2[100];
    file.write(data1, 100);  // Если нужно писать бинарную информацию, пишем
                             // прямо в файл, из массива
    // если мы используем массив символов char, то все работает
    int dataINT[200] = {
        1, 2, 3};  // но с массивами других типов это не сработает, так как
                   // нужно передавать количество байт а не ячеек
    fileInt.write((char *)dataINT,
                  200);  // поэтому нужно использовать явное преобразование, для
                         // этого перед переменной ставится (char *)
    std::cout << sizeof(dataINT)
              << std::endl;  // важно помнить, что при явном преобразовании мы
                             // меняем размер ячейки
    // Когда мы объявляли int dataINT[200], мы выделили 200 * sizeof(int) = 800
    // байт После чего преобразовали в тип char и выражение :200 * sizeof(сhar)
    // = 200 байт уже не верно После преобразования массива из int в char размер
    // массива вырос в 4 раза, ячеек стало 800
    fileInt.write((char *)dataINT, 800);  // Так мы запишем весь массив в файл

    char dataIntRead[800];
    fileInt.seek(0);  // устанавливаем курсор в файле на позицию 0, при записи
                      // мы также можем менять положение курсора в файле, данные
                      // будут заменяться, а не вставляться в строку

    fileInt.read(dataIntRead, 100);  // также можем прочитать из файла в массив
                                     // символов, а потом преобразовать
    std::cout << ((int *)dataIntRead)[0] << "_" << ((int *)dataIntRead)[1]
              << "_" << ((int *)dataIntRead)[2]
              << std::endl;  // Здесь необходимы дополнительные скобки перед
                             // взятием индекса. И после такого преобразования
                             // количество ячеек в массиве сократилось в 4 раза

    std::cout << data2 << std::endl;
    fileInt.seek(0);  // Устанавливаем курсор в файле на позицию 0
    QByteArray BArr = fileInt.read(100);  // читаем с начала тот же файл
    std::cout << ((int *)BArr.data())[0] << "_" << ((int *)BArr.data())[1]
              << "_" << ((int *)BArr.data())[2] << std::endl;
    file.close();
    fileInt.close();
  }
  else {
    std::cout << "file not open" << std::endl;
  }
  return a.exec();
}

// QObject -> QIODevice -> QFileDevice -> QFile -> QTemporaryFile
//  -> QSaveFile
// Классы наследуются в таком порядке, соответственно у класса QFile есть все
// методы классов QFileDevice, QIODevice и QObject Нет необходимости
// преобразовывать класс, QFile для доступа к методам класса QIODevice Так
// происходит во всей системе классов во всех языках программирования
// поддерживающих классы.
```
