# 03. Как читать код

Эта часть методички учит составлять конструкции. Ранее мы изучили – чтобы программировать на С++ нужно выучить около 73-х токенов, 7 типов конструкций и правила написания кода.

## Изучено ранее

Есть 5 групп токенов:

+ **операторы** (`operators`) (+,-,*,/,=,…) – отвечают за вычисления;
+ **ключевые слова** (`keywords`) (const, char, default,..) стандартные инструменты языка;
+ **идентификаторы** (`identifiers`) (_trip, code582, любое другое придуманное ключевое слово) – для создания своих инструментов;
+ **пунктуаторы** (`punctuators`) ( [ ] ,( ), { } , ;, :,… в том числе все операторы) – верстка текста для правильной интерпретации и последовательности исполнения кода;
+ **литералы** (`literals`) (true, false, цифра, символ, строка текста) определение конкретного значения.

Есть 7 типов конструкций:

+ **заявление декларации** (`declaration statement`) – можно обращаться к выделенной памяти по придуманному имени;
+ **нулевое заявление** (`null statement`) (`;`) – используется, если всё, что нужно делать в теле, уже происходит в условии;
+ **заявление выражения** (`expression statement`) – функция, которая принимает некоторое количество значений на вход и после исполнения дает значение на выходе;
+ **составное заявление** (`compound statement`) – используются, когда требуется сразу несколько заявлений, как единый блок;
+ **заявление о выборе** (`selection statement`) – выполняют тест, потом одну часть кода, если результат истинный (ненулевой), и другую часть кода, если результат теста ложный (нулевой);
+ **заявление итерации** (`iteration statement`) – выполняют тест и повторяют выполнение кода, пока результат теста истинный (ненулевой);
+ **заявление о прыжках** (`jump statement`) управление последовательностью исполнения кода.

## Как составлять конструкции

### Заявление декларации

1. Пишем как информация будет храниться в памяти;
2. Определяем тип информации (данных);
3. Присваиваем имя;
4. Можем ввести какие-то данные в память (это называется инициализация), или там будут случайные цифры.

#### 1. Пишем как информация будет храниться в памяти

+ `const` информация постоянная, но тогда сразу нужно ввести её значение (из пункта 4);
+ `extern` – при использовании память не выделялась, но мы сослались но существующее заявление декларации, находящееся в другом файле;

Если ничего не записать, то будет обычная переменная - это когда можно данные переписать в любой момент.

#### 2. Определяем тип данных

**Типы данных** существуют, чтобы помочь нам и компилятору договориться о форме записи и способе чтения разных данных. Типы данных напрямую связаны с памятью, вспомним о ней!

Есть очень длинная полоса с ячейками памяти, и, в зависимости от удаленности от начала, каждая ячейка имеет свой порядковый номер.

В этой полосе информацию можно интерпретировать в зависимости от типа данных, указанного в программе, ссылающейся на рассматриваемую ячейку памяти.

Типы данных можно разделить на скалярные и составные.

+ **Скалярные типы** это типы, которые хранят не более 8 байт (максимальный размер ячейки памяти).
+ **Составные типы** – используются, когда нужно хранить больше 8 байт и соответственно использовать вместе больше одной ячейки памяти. В таком случае мы создаем структуру памяти:
  + указатели на любые типы данных,
  + массивы,
  + структуры,
  + перечисления,
  + объединения,
  + классы,
  + контейнерные классы и
  + битовые поля.
  
Всё это мы изучим до 10-го урока.

##### Скалярные типы данных

+ `bool` (занимает 1 байт) – логический тип, может содержать значение `true` (что угодно, только не 0) или `false` (0)
+ `char` (занимает 1 байт) – символьный тип, содержит число от 0 до 255 (обязательно определить `signed char`, если от -127 до 128
или `unsigned char`, если от 0 до 255) если написать просто `char`, в разных системах автоматически будут выбраны настройки `signed` (под windows и linux), так и `unsigned` (под андроид, ардуино (не проверено, но предполагается)).
+ `wchar_t` или `char16_t` (занимает 2 байта) – специальный тип для 2-х байтных кодировок, например utf-8 (стандарт кодирования символов, позволяющий более компактно хранить и передавать символы `unicod` используя переменное количество байт от 1 до 4 - визуально выглядит как буквы превращенные в цифровые коды) – используется в Android, Linux Unix, IOS, Windows, и, самое главное, в веб пространстве!
+ `char32_t` (занимает 4 байта) для символов `unicode` (стандарт кодирования символов включающий в себя знаки почти всех языков мира)
+ `short` или `short int` (занимает 2 байта) – используется для хранения целых чисел от -32768 до 32767 и, если `unsigned`, то от 0 до 65535.
+ `int` или `long int` (занимает 4 байта) – целочисленные значения от -2 147 483 648 до + 2 147 483 647
+ `long long` или `long long int` (занимает 8 байт) целочисленное от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 или, если `unsigned` от 0 до 18 446 744 073 709 551 615
+ `float` (занимает 4 байта и всегда `signed`) – для хранения чисел с плавающей точкой (дробные) от 3,4E +/-38 (7 знаков)
+ `double` (занимает 8 байт) – для хранения чисел с плавающей точкой от 1,7 E +/- 308 (15 знаков)

Оператор «`*`» маркирует любой тип данных как указатель и выделяет для него 8 байт памяти.

При помощи него реализуются составные типы данных. Указатель содержит ссылку на область в памяти, где хранится любой тип данных, в том числе составные.

##### Составные типы данных

+ `struct` – так мы объявляем структуру
+ `class` так объявляется класс

Есть ещё несколько других, но они не нашли широкого применения и инженерам будут неинтересны.

---
**Важный факт!**<br>
"`struct`" и "`class`" с указателем "`*`" не используют, так как они сами содержат в себе вариант решения задачи, решаемой указателем.

---

#### 3. Правила присваивания имени

+ имя должно содержать цифры и буквы латинского алфавита. Начинаться с буквы или символа "_";
+ имя не может являться одним из стандартных ключевых слов, но может повторять любой из идентификаторов это называется перегрузкой. Компилятор в этом случае принимает решение какой идентификатор использовать, самостоятельно основываясь на определении типа передаваемых данных.

##### Рекомендации присвоения имени

+ идентификаторы для классов принято начинать с большой буквы;
+ переменные, функции и экземпляры классов – с маленькой;
+ название должно быть релевантно содержанию (отражать смысл);
+ итераторам во вложенных циклах рекомендуется давать название последовательно i, j и k в соответствии с глубиной вложенности цикла.

#### 4. Ввод данных в память

При инициализации памяти мы можем ввести любое начальное значение. Иногда пишут "какая то переменная = 0", чтобы программа не ошиблась, считав случайное значение. Это уместно, например, если нам нужно будет считать количество, путём прибавления к текущему значению (а там могут оказаться случайные числа).

### Нулевое заявление

"`;`" – требуется, когда писать ничего не нужно, но нужно соблюсти порядок. Используется, когда несколько раз повторяется блок (в цикле). Всё, что нужно делать в теле программы уже происходит в условии.

### Заявление выражения

**Это сама суть программы – исполняемый код.**

Принимаемые значения называются операндами. Операнды представляют собой идентификаторы или литералы.

Возвращаемые значения – выполнение программы приводит к результату:

+ инструкция корректна и выполняет свою работу;
+ инструкция не корректна и возвращает код ошибки.

Обращаем ваше внимание, что программа работает ровно так, как её написал программист, и это не всегда происходит в соответствии с ТЗ. Если результат работы программы отличается от диапазона ожидаемых ответов – перепроверьте код по плану проекта программы (методический отдел школы Громов ПЛК настоятельно рекомендует пользоваться инструментом "проектирование", чтобы избежать в своей практике подобных ситуаций).

---
**Важный факт!**<br>
Любые выражения всегда возвращают 8 байт, а это значит, что результатом работы инструкции не может быть структура или класс. Результат будет только скалярным.

---

Выражения бывают простыми (по умолчанию) и составными. Простым соответствует работа со скалярными типами данных, а составным соответствуют (как ясно из названия) составные типы данных.

### Составное заявление

Характерной особенностью составных выражений является наличие операторов:

+ вызов функции "`()`";
+ расширение области видимости "`::`";
+ оператор выбора члена "`.`" или "`>`".

Для исполнения простых выражений программе не требуется перехода в другие места кода, т. е. вся инструкция записана в одном месте результат вычисляется прямо в этой строке.

**Примеры простого выражения:**

`x = a + b` – для выполнения процедур нам не требуются переходы, мы можем выполнить операцию прямо в этой строке.

При составных выражениях для получения результата необходимо перейти в другую часть программы для получения промежуточных результатов.

**Пример сложного выражения:**

`x = function(y)` – для присвоения значения "x", нужно сначала посчитать функцию, которая описана в другом месте программы.

### Заявление о выборе

Сначала пишется ключевое слово "`if`", потом в круглых скобках `()` условие.

**Условие** – это выражение, результатом которого будет являться 1 или 0. Тип данных на выходе выражения условия всегда "`bool`" – это называется "Булевое (фамилия придумавшего двоичную логику - Джордж Буль 1815–1864 гг.., математик) выражение"

В зависимости от результата этого выражения исполняется 1-й блок кода, если ответ "1", и второй блок кода, если ответ "0".

Для разделения первого и второго блока кода используется "else".

---

**Важный факт!**<br>
Если 2-го блока кода нет, то программа будет исполняться только в случае соблюдения условия, иначе по правилу следования будет исполняться следующий код.

---

Условия о выборе бывают "`switch`" (условие, при котором возвращается целочисленное значение в диапазоне `int`, где каждому из значений соответствует свой блок кода). Так же можно назначить блок кода для исполнения в случае, если ни один из результатов не соответствует ожидаемым.

### Заявление итерации

Есть несколько типов циклов. Циклы придумала Августа Ада Лавлейс 1815-1852 гг. (в честь неё назван один языков программирования – язык Ada).

Несмотря на то, что есть разные типы циклов мы будем использовать только самый рациональный – цикл "`for`".

Примером проблемы, которую решает цикл "`for`" является необходимость совершения одних и тех же действий над большим количеством данных.

После "`for`" в "`()`" описываются параметры работы цикла.

1. **Определение переменных цикла итераторов** (используется для определения того откуда начинать счет в не запущенной программе, и для определения текущего номера цикла в работающей программе). <br>
В одном цикле можно объявить сколько угодно итераторов, но, чтобы не запутаться, делают по одному итератору на один цикл. Если оставить все блоки пустыми, то цикл будет выполняться бесконечно – этот механизм мы так же будем использовать.
2. **Булевое выражение** – описывает условие выполнения цикла. Это выражение может быть составным для учета большого количества параметров.<br>

    ---
    **Важный факт!**<br>
    Если мы используем составное условие – сложный расчёт происходит при исполнении каждого цикла, что приводит к нерациональному использованию вычислительных мощностей. <br>
    Чтобы не производить расчет каждый раз, в объявлении мы инициализируем итератор 1 раз рассчитанным значением составного условия, а условием будет являться выражение, сравнивающее итератор с "0". Много раз сравнить с "0" проще, чем много раз сравнить с числом, рассчитываемым составным выражением.

    ---
3. **Обязательное действие** – выражение, выполняющееся в конце цикла.<br>
В конце цикла мы обычно определяем приращение итератора (целевое использование) или можем вызывать любую функцию (безответственный подход, но компилятор и слова не скажет).<br>
Операторы приращения функции записываются "`+=число`" , "`-=число`", "`*=число`", "`%=число`", "`/=число`", и другие операторы, а вместо `+=1` можно написать `++`, чтобы было покороче.

### Заявление о прыжке

+ `break` – команда прекращает исполнение данного блока кода (используется в циклах (`for`) и в ветвлении (`switch`));
+ `continue` – прерывает исполнение кода, при этом выполняется обязательная часть цикла "`for`" и цикл начинается заново;
+ `return` прекращает исполнение функции и возвращает значение, а после код продолжает исполняться с места вызова функции;
+ `goto` – безусловное продолжение кода с указанной строки (любой) – не рекомендуется использовать, если можно обойтись другими средствами, а такие есть всегда (велик риск "перемудрить", лучше написать побольше, но с четкой и ясной структурой).

### Домашнее задание

Создать программу, которая просит пользователя ввести 2 вещественных числа, а затем отображает все их математические отношения - то есть сумму, разность, кратное, частное.

## Языковые конструкции

Это правила формирования кода. В них описывается последовательность символов и данных и правила по созданию структуры кода.

**Пример конструкции** – `if(условия){код}else{код}`

Если условия выполнились - выполняем код, иначе выполняем другой код.

## Ветвление. Логические операторы

Ветвление представляет собой выполнение различных инструкций в зависимости от обстоятельств.

Признаком разветвляющегося алгоритма является наличие операций проверки условия. Чаще всего для проверки условия используется условный оператор `if`.

Чтобы упростить запись, можно использовать оператор `else`. `Else` используется, чтобы сказать компьютеру, какие инструкции нужно выполнить, если проверяемое утверждение было ложным.

Если нужно проверить несколько условий, то воспользуемся оператором `else if`. Программа сначала проверит первое условие и, если оно ложно, будет проверять следующие за ним `else if`.

Если ни одно из условий не было верным, выполняются инструкции внутри `else`, поэтому оно всегда должно стоять в конце.

Иногда нам необходимо проверить сразу несколько условий. В C++ для этого есть следующие логические операторы:

+ `&&` — логическое «И» или логическое умножение (конъюнкция). <br>
Оператор И возвращает истину, если верны оба утверждения.
+ `||` — логическое «ИЛИ» или логическое сложение (дизъюнкция). <br>
Оператор ИЛИ возвращает истину, если верно хотя бы одно утверждение.
+ `!` — логическое отрицание. Возвращает истину, если утверждение ложно.
+ `A < B` — сравнивает две переменные и возвращает `true`, если A меньше B.
+ `A > B` — возвращает `true`, если A строго больше B.
+ `A == B` — проверяет на равенство переменные A и B.
+ `A != B` проверяет переменные A и B на неравенство
+ `A >= B` — нестрогое неравенство. Возвращает `true`, если A больше или равно B.
+ `A <= B` — противоположно неравенству `A >= B`.

Если вам нужно проверить какую-то переменную на определённое значение, то лучше использовать конструкцию `switch`.

Вместо утверждения вы передаёте в `switch` переменную и проверяете значение. Далее с помощью оператора `case` обозначаются все значения, для которых нужно выполнить какое-то действие.

В конце каждого `case` должно стоять слово `break` — оно говорит компилятору, что это конец инструкции.

Аналогом `else` в `switch` служит `default`.

Конструкция `switch-case` — это удобная замена длинной `if-else` конструкции, которая сравнивает переменную с несколькими константными значениями.

Рассмотрим программу, демонстрирующую ветвление, и работу с логическими выражениями:

```cpp
// подключим заголовочный файл ввода-вывода, для отображения информации
#include <cstdio>

// подключим заголовочный файл string, контейнерный тип, обеспечивающий работу
// со строками
#include <string>

// std-означает стандартную библиотеку с++ и данная директива позволяет не
// указывать префикс std:: перед каждой функцией этой библиотеки

using namespace std;

int main() {
  // объявим несколько чисел
  int a = 50;
  int b = 21;
  int c = -10;
  int d = 50;
  // рассмотрим конструкцию if-else

  // строгое условие
  if (a > c) {
    // выполнение условия, т.к. а(50) > c(-10)
    printf("a (%d) > c (%d)\n", a, c);
  };

  // не строгое условие
  if (a >= d) {
    // выполнение условия, т.к. а(50) = d(50)
    printf("a (%d) >= d (%d)\n", a, d);
  };
  // использование логического ИЛИ
  if (a > c || b > d) {
    // выполнение условия, т.к. а(50) > c(-10)
    printf("a (%d) > c (%d)\n", a, c);
  };
  // использование ELSE
  if (b > d) {
    // данное условие не выполнится
    printf("b (%d) > d (%d)\n", b, d);
  } else {
    // данное условие выполнится
    printf("b (%d) <= d (%d)\n", b, d);
  };
  // рассмотрим конструкцию switch-case
  switch (b) {
    // проверка переменной b на значения
    case 10:
      // данное условие не выполнится
      printf("b = %d\n", b);
      break;
    case 21:
      // данное условие выполнится
      printf("b = %d\n", b);
      break;
    default:
      // данное условие не выполнится, т.к. сработает условие выше, однако, если
      // в условии выше   21 заменить на другое число, то данный участок
      // выполнится
      printf("b = %d\n", b);
      break;
  };
  // Примечание: нельзя поставить переменную после case, после case обязательно
  // должно стоять   константное значение.
  return 0;
};
```

```sh
a (50) > c (-10)
a (50) >= d (50)
a (50) > c (-10)
b (21) <= d (50)
b = 21
```

**Примечание:** при большом количестве проверок эффективнее использовать конструкцию `switch-case` чем множество `if-else`.

Это связано с тем, что case принимает константное значение, и компилятор просто скомпилирует верный блок кода.

## Функции

Это блок кода, который позволяет структурировать программу и выполнять себя повторно избегая дублирования кода.

Пример функции – функция `calcCircleSquare` значит вычисление площади круга по длине его окружности. При этом название вы придумываете сами.

```cpp
#include <iostream>
#define Pl 3.14

// using namespace std;
float calcCircleSquare(float r) { return Pl * r * r; }

int main() {
  std::cout << calcCircleSquare(15) << std::endl;
  return 0;
}
```

```sh
706.5
```

**Примечания:** Лучше всего делать функцию, которая выполняет одно действие.

Правильно будет отобразить первое слово с маленькой буквы и последующие слитно с большой для удобства чтения (так называемый, общепринятый CamelStyle). При понятном названии не придётся писать комментарии.
