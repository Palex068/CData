# 11. Оконные приложения, сигналы и слоты в Qt

## Оконные приложения в QT

Настало время приступить к программированию оконных приложений.

Теперь программы у нас будут состоять из двух частей: **front-end** и **back-end**.

**Front-end** — это то, что видит пользователь. То, что показывается в окне программы, с чем пользователь взаимодействует: кнопки, поля вывода и так далее. Программисты, которые занимаются **front-end** описывают логику интерфейса и его работу.

**Back-end** это то, что происходит внутри программы и остаётся скрытым от пользователя, т.е. внутренняя логика.

**Для примера рассмотрим программу калькулятора из Windows.**

**Front-end** у нас — это кнопки и поле вывода полученных цифр. Но все арифметические операции происходят скрыто от пользователя. Пользователь не видит, как калькулятор внутри себя считает. Это **Back-end**. Нам нужно будет создавать подобные программы.

Кстати говоря, эта терминология используется и в веб-разработке. А те люди, которые специализируются на программировании и **Back-end** и **Front-end**, называются **Fullstack** разработчиками.

Ранее мы создавали консольные приложения, и несмотря на то, что вывод в консоль мы тоже делали это, как правило, не требует специализированного подхода в плане организации.

Теперь мы будем отдельно выделять классы, которые будут работать с внутренней логикой и отдельно описывать визуальную составляющую. Такое разделение нужно для того, чтобы иметь возможность переносить внутреннюю логику на другие программы. Это обеспечит модульность архитектуры наших программ.

## Сигналы и слоты

Итак, когда пользователь взаимодействует с одним элементом интерфейса, мы обычно хотим, чтобы другой элемент интерфейса, либо функция программы, получил об этому уведомление.

В общем случае, мы хотим, чтобы объекты любого типа могли общаться друг с другом.

Например, если пользователь нажимает кнопку Закрыть, мы хотим, чтобы была вызвана функция окна `close()`.

В Qt для этой цели служат сигналы и слоты.

**Сигнал** — метод, передающий информацию о каком-либо событии.

**Слот** — функция, которая воспринимает соответствующий сигнал и реализует дальнейшую логику работы.

Другие библиотеки добиваются такого рода общения, используя обратный вызов.

**Обратный вызов** это указатель на функцию. Если мы хотим, чтобы функция уведомила нас о каких-нибудь событиях, мы передаем указатель на другую функцию (обратно вызываемую) этой функции. Функция в таком случае делает обратный вызов, когда это необходимо.

***Чем плох обратный вызов?***

+ Он не является типобезопасным. Мы не можем быть уверены, что функция делает обратный вызов с корректными аргументами.
+ Обратный вызов жестко связан с вызывающей его функцией, так как эта функция должна точно знать, какой обратный вызов надо делать.

***Чем хорош подход в Qt?***

+ Механизм сигналов и слотов типобезопасен. Сигнатура сигнала должна совпадать с сигнатурой слота-получателя. (Фактически слот может иметь более короткую сигнатуру, чем сигнал, который он получает, так как он может игнорировать дополнительные аргументы.)
+ Сигналы и слоты слабо связаны. Класс, который вырабатывает сигнал, не знает и не заботится о том, какие слоты его получат.

**Сигнал** создается, когда происходит определенное событие, в заголовочном файле проекта в секции `signals`:

```cpp
signals:
    void valueChanged(int newValue);
```

Он служит для передачи события. Например, произошло изменение значения переменной, и необходимо обработать новое значение.

**Слот** — это функция, которая вызывается в ответ на определенный сигнал.

Чтобы создать слот для объекта в **qt** в форме `mainwindow.ui` (или другой) щелкаем ПКМ на объекте и выбираем «Перейти к слоту…». Далее мы выбираем необходимое действие и в этой функции описываем необходимые действия.

Как правило, стандартные объекты **qt** генерируют сигналы, уже заложенные в них. Однако, если создать свой сигнал о каком-то действии, то потребуется подключить этот сигнал к нужному слоту (функции, которая будет обрабатывать это событие) через `connect`:

```cpp
connect(<класс который создал сигнал>, SIGNAL(<метод этого класса>), this, SLOT(<функция обработки события>));
```

## Наследование

**Наследование** является одним из основополагающих принципов ООП.

В соответствии с ним, класс может использовать переменные и методы другого класса, как свои собственные.

Класс, который наследует данные, называется:

+ подклассом (`subclass`),
+ производным классом (`derived class`) или
+ дочерним классом (`child`).

Класс, от которого наследуются данные или методы, называется:

+ суперклассом (`super class`),
+ базовым классом (`base class`) или
+ родительским классом (`parent`).

В C ++ есть несколько типов наследования:

+ публичный (`public`) публичные (`public`) и защищенные (`protected`) данные наследуются без изменения уровня доступа к ним;
+ защищенный (`protected`) — все унаследованные данные становятся защищенными;
+ приватный (`private`) — все унаследованные данные становятся приватными.

***Что все это значит?***

+ **Public** все, описанное в этом типе, может быть использовано, будь то переменные или методы класса.
+ **Private** – все, описанное в этом типе, скрыто в классе и извне нельзя получить доступ к этим методам или переменным.
+ **Protected** - производные классы получают свободный доступ к таким свойствам или методам.

Все другие классы такого доступа не имеют.

Также в Qt есть возможность выполнения функции "по востребованию", которая строится на 3-х элементах:

+ **Сигнал** - специальная переменная (метод/функция - "инициатор"), которая есть у многих классов в Qt
+ **Connect** - специальная функция, преобразующая сигнал в команду на исполнение
+ **Слот** - ваша функция, которая будет выполнена в случае получения команды от функции `connect`

Повторим затронутые ранее основные понятия ООП (объектно-ориентированного программирования):

+ **Родитель** - класс, который взят за основу нового класса. В новом классе есть все, что было в родителе, плюс вами добавляется новый функционал, при этом изменения в новом классе не затрагивают родителя. То есть новый класс является "наследником".
+ **Наследование** - расширение возможностей класса-родителя. Можно добавить новые возможности, использующие переменные из класса-родителя.
+ **Экземпляр класса** - копия класса, отличающаяся входными данными, но идентичная по функционалу. Если в исходном классе изменить функционал, то он изменится и в экземплярах.
+ **Конструктор** - функция, которая вносит данные в память конкретного экземпляра.<br>
Она выполнится после создания экземпляра класса. Конструкторы могут быть разными для разных наборов входных параметров.
+ **Деструктор** - функция, которая освобождает память для возможности дальнейшего использования. Он требуется для удаления ранее выделенной динамически (вручную)память.<br>
Поскольку мы работаем с программно-аппаратными комплексами, мы имеем дело с ограниченным ресурсом памяти. Если память у нас закончится, программа перестанет выполняться - поэтому мы используем деструктор.

### Бытовая аналогия

Представим себе котельную и грубо разделим котельную на два функциональных блока:

+ первый функциональный блок отвечает за подачу воды,
+ второй - за ее нагрев.

Подача воды осуществляется через трубу. У этой трубы есть характеристики: длина, внутренний диаметр, и на основании этого считаем объем. Какого бы диаметра и длины ни была труба, ее объем будет рассчитываться по одной и той же формуле.

Набор переменных и формула расчета объема остается неизменной это и есть **класс**. А вот частный случай, с конкретными размерами, является **экземпляром класса**.

Второй функциональный блок трубы, где происходит нагрев — это труба с подобными характеристиками, только каждой единице объема передается определенное количество энергии. То есть характеристик стало больше, и добавилась формула нагрева, это называется наследованием.

## Домашнее задание к теме №11 "Оконные приложения, сигналы и слоты в QT часть №1"

+ Создайте программу калькулятора. Возьмите за основу самый простой калькулятор из Windows или любой другой ОС.
+ Реализуйте функцию стирания последнего введённого символа
+ Реализуйте возможность видеть оба введённых числа, над которыми совершается операция.

Можно добавить ввод нескольких операторов в одном выражении.

+ На "хорошо" - набор новых кнопок должен приводить к сбросу и началу нового расчета или результат становится первым числом для нового расчета.
+ На "отлично" - повторные нажатия на = повторяют предыдущую операцию.
+ На "экспертно" - функция памяти в калькуляторе.

## Домашнее задание к теме №11 "Оконные приложения, сигналы и слоты в QT. Часть 2"

Создайте программу, которая выводит на экран окно и требует от пользователя ввести число.

После нажатия кнопки "ОК" - это число должно быть отображено в следующем открывшемся окне.
