# Принципы работы приложений Qt

## Обзор, цель и назначение урока

Описать основные принципы работы приложений Qt. Рассмотреть базовый класс QObject и его возможности. Ознакомится с особенностями классов контейнеров фреймворка Qt.
  
**Изучив материал данного занятия, учащийся сможет:**

+ Понять принципы работы приложений на языке программирования С++, которые используют фреймворк Qt.
+ Эффективно и правильно использовать возможности класса QObject.
+ Сделать осознанный выбор между использованием STL и/или Qt контейнеров в своем приложении.

## Содержание урока

+ [1. Типа приложений Qt](#1-типа-приложений-qt)
+ [2. QObject](#2-qobject)
+ [3. Сигналы и слоты](#3-сигналы-и-слоты)
+ [4. Многопоточность](#4-многопоточность)
+ [5. Контейнеры Qt](#5-контейнеры-qt)
+ [Выводы](#выводы)
+ [Резюме](#резюме)
+ [Закрепление материала](#закрепление-материала)
+ [Самостоятельная деятельность учащегося](#самостоятельная-деятельность-учащегося)

## 1. Типа приложений Qt

Перед использованием некоторых возможностей Qt необходимо создать специальный объект приложения:

+ QCoreApplication.
+ QGuiApplication.
+ QApplication.

Это не является обязательным (но очень рекомендуемым) условием. Многие возможности Qt могут быть использованы без создания объектов приложений.

### [QCoreApplication](https://doc.qt.io/qt-6/qcoreapplication.html)

Это базовый класс для всех Qt приложений. Используется для консольных приложений. Основные функции:

+ Обработка событий и сигналов.
+ Управление общими библиотеками (shared library) во время выполнения программы.
+ Локализация приложения.
+ Доступ к аргументам командной строки.

### [QGuiApplication](https://doc.qt.io/qt-6/qguiapplication.html)

Этот класс унаследован от **QCoreApplication**. Он предоставляет дополнительный функционал для создания  приложений с графическим интерфейсом (Qt Quick, OpenGL, Vulkan). Основные функции:

+ Настройка палитры, шрифта и стиля приложения.
+ Управление окнами.
+ Обработка событий оконной системы(мышь, клавиатура и т.п.).
+ Доступ к буферу обмена.
+ Возможность управления сессиями.

### [QApplication](https://doc.qt.io/qt-6/qapplication.html)

Данный класс наследует весь функционал QGuiApplication. Также используется для приложений с графическим интерфейсом и предоставляет функционал для работы приложений, которые используют QWidget. Основные функции:

+ Установка палитры, шрифта и стиля для Qwidget.
+ Возможности взаимодействия с окружением рабочего стола.
+ Есть доступ к размеру рабочего стола и размеру области в которой можно размещать окна.
+ Нотификация об активности приложения на панели запущенных приложений.
+ Идр.

### Цикл обработки событий

Для обеспечения обработки системных событий и работы сигналов и слотов нужно запустить цикл обработки событий используя метод `QApplication::exec()`.

Данный цикл работает по следующему алгоритму:

+ ЕСЛИ (очередь событий (сигналов) для обработки пуста):
  + Ожидание новых событий.
  + Обработка событий по очереди.
  + Повторение с начала.

При этом вызов метода `QCoreApplication::exit(int returnCode)` приведет к немедленному завершению цикла обработки событий.

---
[Содержание урока](#содержание-урока)

## 2. QObject

Класс [QObject](https://doc.qt.io/qt-6/qobject.html) является базовым для большинства других классов во фреймворке Qt. Данный класс является основой объектной модели Qt и предоставляет доступ к большинству возможностей Qt. Для некоторых из них используется предварительная обработка исходников с помощью MOC. Возможности QObject:

+ Иерархия объектов.
+ Доступ к информации о реальных типах объектов без использования RTTI.
+ Свойства (property), к которым можно получить доступ по имени(в виде текстовой строки).
+ Макрос Q_INVOKABLE для доступа к методам объекта по их имени.
+ Настройка взаимодействия между объектами через сигналы и слоты .
+ "Перемещение" объектов в другие потоки.

Особенности:

+ Объекты QObject не могут быть скопированы. Это сделано по причине того, что эти объекты являются сущностями (Identity), а не значениями (Value).
+ При наследовании от класса QObject рекомендуется добавлять макрос Q_OBJECT после открывающей скобки класса для применения MOC к этому классу.

---
[Содержание урока](#содержание-урока)

## 3. Сигналы и слоты

[Signals & Slots](https://doc.qt.io/qt-6/signalsandslots.html)

+ **Сигналы** - методы без реализации, которые возвращают void, помещенные в секцию signals.
+ **Слоты** - обычные методы с реализацией, помещенные в секцию slots. Также в качестве слотов можно использовать функторы.
+ После подключения сигнала одного объекта к слоту другого объекта, каждая генерация сигнала первого объекта приведет (немедленно или при следующей итерации цикла обработки событий) к вызову метода-слота второго объекта.
+ Подключение сигнала к слоту осуществляется с помощью метода QObject::connect. Можно также подключать сигналы к сигналам.
+ Сигнатура слота должна полностью или частично совпадать с сигнатурой сигнала.

### Сигналы и слоты. Способы подключения

+ **AutoConnection** способ подключения определяется автоматически. `Qt::DirectConnection` используется если получатель находится в потоке из которого был и сигнал. Иначе Qt::QueuedConnection. Тип соединения определяется во время генерации сигнала.
+ DirectConnection слот вызывается немедленно после генерации сигнала и он выполняется в потоке в котором был сгенерирован сигнал.
+ QueuedConnection слот выполняется когда управление возвращается в цикл событий в потоке получателя. Слот выполняется в потоке получателя.
+ BlockingQueuedConnection то же самое что и Qt::QueuedConnection но выполнение потока в котором был сгенерирован сигнал приостанавливается (блокируется) пока выполнение слота не завершится.<br>
Если отправитель и получатель сигнала находятся в одном потоке, то этот поток будет заблокирован навсегда.
+ UniqueConnection препятствует многократному соединению одинаковых подключений, может быть скомбинирован с другими способами подключения при помощи оператора `|`.

---
[Содержание урока](#содержание-урока)

## 4. Многопоточность

[Многопоточность](https://doc.qt.io/qt-6/threads-qobject.html)

Qt предоставляет несколько подходов к созданию многопоточных приложений:

+ Низкоуровневый подход на основе QThread:
  + Можно передавать объекты QObject в поток QThread. Создание QThread предоставляет параллельный цикл обработки событий.
  + Наследование от QThread позволяет запустить некоторый код в другом потоке до запуска цикла обработки событий или вообще без него.
+ Использование пула потоков QThreadPool и объектов задач QRunnable:
  + Позволяет повторно использовать потоки.
  + Позволяет создавать "очереди" задач.
+ Высокоуровневое API QtConcurrent с использованием фьючеров QFuture:
  + Управлением потоками полностью автоматизировано и не требуется синхронизация.
  + Можно параллельно применить некоторую функцию к каждому элементу контейнера (или диапазону между двумя итераторами) или отфильтровать контейнер по заданному условию.
  + Можно передать на выполнение функцию.

### Многопоточность. Синхронизация

Для синхронизации потоков Qt предоставляет следующие классы:

+ QMutexиQMutexLocker.
+ QReadWriteLock, QReadLocker и QWriteLocker.
+ QSemaphore.
+ QWaitCondition.

В приложении Qt (в том числе в потоках QThread) можно использовать средства синхронизации из стандартной библиотеки C++ (или какой-либо другой). Главное самому не запутаться 🙂.

---
[Содержание урока](#содержание-урока)

## 5. Контейнеры Qt

[Контейнеры Qt](https://doc.qt.io/qt-6/containers.html)

+ Qt предоставляет набор классов-контейнеров, аналогичный контейнерам из библиотеки STL.
+ Основными преимуществами контейнеров Qt является:
  + Потоковая безопасность (в случае доступа на чтение) за счет Implicit Sharing.
  + Поддержка итераторов в стиле Java (hasNext, next, и т.п.).
  + Оптимизация скорости, используемой памяти и размера исполняемого файла (по заверениям разработчиков).
  + Внедрение новых функций раньше чем в STL.
+ Контейнеры и итераторы Qt обладают схожими с STL интерфейсами, что позволяет, например, применять алгоритмы STL к Qt итераторам.
+ В Qt приложении можно использовать как Qt так и STL контейнеры, но смешивать их не рекомендуется, так как нет дешевого способа преобразования этих контейнеров между собой.

---
[Содержание урока](#содержание-урока)

## Выводы

+ Qt предоставляет возможность создавать как консольные так и приложения с графическим интерфейсом.
+ Система сигналов и слотов является одним из ключевых преимуществ фреймворка Qt. Данная концепция позволяет разделить систему на отдельные модули и наглядно описать взаимодействия между ними.
+ Перемещение объектов в другой поток позволяет перенести некоторую часть программы в отдельный поток и безопасно с ней взаимодействовать с помочью сигналов и слотов.
+ Система свойств Q_PROPERTY и методов Q_INVOKABLE позволяет использовать мета программирование (в частности рефлексию) в вашем приложении.
+ Контейнеры Qt очень схожи и практически полностью совместимы с STL контейнерами.

---
[Содержание урока](#содержание-урока)

## Резюме

+ Для обеспечения корректной работы всех возможностей Qt (обработка событий, сигналы и слоты, локализация приложения и др.) перед их использованием необходимо создать специальный объект приложения (QCoreApplication, QGuiApplication или QApplication).  
+ Класс QObject является базовым для большинства других классов во фреймворке Qt. Данный класс является основой для объектной модели Qt и предоставляет доступ к большинству возможностей, которые Qt привносит в С++.
+ Qt позволяет создавать иерархии объектов, в которых удаление родительского объекта приведет к рекурсивному удалению дочерних объектов.
+ Сигналы и слоты позволяют настроить взаимодействиями между частями системы. После подключения сигнала одного объекта к слоту другого объекта, каждая генерация сигнала первого объекта приведет к вызову метода-слота второго объекта.  
+ Объекты класса QObject могут быть “перенесены” в отдельный поток. При этом можно обеспечить потокобезопасное взаимодействие двух объектов, которые находятся в разных потоках, при помощи сигналов и слотов.
+ Qt предоставляет набор классов-контейнеров, аналогичный контейнерам из библиотеки STL с почти идентичными интерфейсами, что позволяет совместно использовать STL и Qt контейнеры в одном приложении. Основными преимуществами контейнеров Qt является использование концепцию Implicit Sharing и потоковая безопасность.

## Закрепление материала

+ Создать проект консольного приложение с использование Qt.
+ Создать класс отправитель, который каждые t секунд будет генерировать сигнал с текстом txt и выводить отладочную информацию об этом в консоль (например, “Send: Hello”). Время t и сообщение txt должны указываться в конструкторе объекта.
+ Создать класс приемник, который будет принимать сообщения от отправителей и выводить отладочную информацию об это в консоль (например, “Received: Hello”).
+ Создать один объект приемника и несколько (для начала можно и 1) объектов отправителей и настроить соединения сигналов и слотов (используя подключение по умолчанию) так чтобы приемник получал сообщения от всех отправителей. Сообщения об получении должны приходить сразу же после сообщений об отправке.
+ Добавить в приемнике tSleep секунд ожидания (например используя QThread::sleep) после получения каждого сообщения. После получения сообщения должна быть задержка, во время которой новые сообщения не будут отправлены.

## Дополнительное задание

+ Перенести объект получателя в другой поток. Понять, как и почему изменилось поведение приложения. Попробовать разные способы подключения сигналов и слотов.

## Самостоятельная деятельность учащегося

### Задание 1

Исследовать возможности Qt для работы с сетью (в частности c UDP).

### Задание 2

Создать приложение, которое будет получать дейтаграммы по протоколу UDP и через каждые 10 секунд выводить все полученные дейтаграммы в консоль или сообщении об отсутствии дейтаграмм если их не пришло за последние 10 секунд.

### Задание 3

Изучить инструменты Qt для работы со временем и выводить полученные дейтаграммы не каждые 10 секунд, а в начале каждой новой минуты. Желательно сделать это оптимально без постоянного (каждую секунду или чаще) запроса текущего времени.
