# 1. Классы и объекты. Конструкторы и деструкторы. Методы

## Содержание

+ [Да что же такое ООП?](#10-да-что-же-такое-ооп)
  + [Объекты и классы](#объекты-и-классы)
  + [Методы класса](#методы-класса)
  + [Инкапсуляция](#инкапсуляция)
  + [Наследование и полиморфизм](#наследование-и-полиморфизм)
  + [Заключение](#заключение)
+ [1.1 Понятие классов и объектов](#11-понятие-классов-и-объектов)
  + [Что такое класс в ООП](#что-такое-класс-в-ооп)
  + [Что такое объект в ООП. Неявный указатель this](#что-такое-объект-в-ооп-неявный-указатель-this)
+ [1.2 Режимы доступа public и private](#12-режимы-доступа-public-и-private)
+ [1.3 Конструкторы. Конструктор по умолчанию. Перегрузка конструкторов](#13-конструкторы-конструктор-по-умолчанию-перегрузка-конструкторов)
  + [Конструкторы](#конструкторы)
  + [Конструктор по умолчанию](#конструктор-по-умолчанию)
  + [Перегрузка конструкторов](#перегрузка-конструкторов)
+ [1.4 Конструктор преобразования. Деструктор](#14-конструктор-преобразования-деструктор)
  + [Конструктор преобразования](#конструктор-преобразования)
  + [Ключевое слово explicit](#ключевое-слово-explicit)
  + [Деструктор класса](#деструктор-класса)
+ [1.5 Конструктор копирования. Делегирующие конструкторы](#15-конструктор-копирования-делегирующие-конструкторы)
  + [Конструктор копирования](#конструктор-копирования)
  + [Делегирование конструкторов](#делегирование-конструкторов)
+ [1.6 Этапы жизни объектов классов](#16-этапы-жизни-объектов-классов)
+ [1.7 Особенности работы конструкторов. Ключевые слова default и delete](#16-этапы-жизни-объектов-классов)
  + [Особенности работы конструкторов](#особенности-работы-конструкторов)
  + [Ключевое слово `delete`](#ключевое-слово-delete)
  + [Сокрытие конструкторов](#сокрытие-конструкторов)
+ [1.8 Описание методов вне класса](#18-описание-методов-вне-класса)
  + [Описание методов вне класса](#описание-методов-вне-класса)
  + [Многомодульные программы](#многомодульные-программы)
+ [1.9 Статические поля и методы класса](#19-статические-поля-и-методы-класса)
  + [Статические поля](#статические-поля)
  + [Статические методы](#статические-методы)
+ [1.10 Паттерн Singleton (синглтон)](#110-паттерн-singleton-синглтон)
+ [1.11 Константные методы. Ключевое слово mutable](#111-константные-методы-ключевое-слово-mutable)
  + [Константные методы](#константные-методы)
  + [Ключевое слово `mutable`](#ключевое-слово-mutable)

[Оглавдение](/OOP_C_C++/README.md)

## 1.0 Да что же такое ООП?

[Смотреть материал на видео](https://www.youtube.com/watch?v=RKMyJKXXpKM&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

[Что такое ООП?](/OOP_C_C++/videos/01.01.mp4)

Известный физик Ричард Фейнман как то произнес, ставшую крылатой фразу: «Если вы думаете, что понимаете квантовую механику, значит, вы её не понимаете». Что-то похожее можно сказать и о первом знакомстве с парадигмой объектно-ориентированного программирования (ООП): «Если в самом начале вы решили, что осознали ООП, то на самом деле вы его еще не осознали». Лично мне потребовалось порядка 10 лет практики, чтобы увидеть всю силу и красоту объектно-ориентированного подхода. Почему же часто так сложно сделать первые шаги в этом направлении и начать писать программы в новом, современном стиле? В целом, ответ прост. ООП – это именно новая парадигма программирования, то есть, новый, иной способ мышления при написании программ. А научить себя мыслить иначе, не так, как прежде, - в этом и состоит главная сложность.

А что было прежде? Большинство языков программирования (ЯП) позволяют составлять программы в виде последовательности команд (набора определенных операторов). Такой подход получил название императивное программирование. (От слова «императив» - приказ, команда.) И, например, изучая язык Си, мы придерживались именно этой императивной парадигмы. То есть, способ мышления состоял в выборе последовательности команд, которые в процессе выполнения приводили к требуемому результату. Например, в этой парадигме легко составить программу вычисления суммы значений элементов какого-либо массива:

```c
int ar[] = {1, 2, 3, 4};
int s = 0;
for(int i = 0; i < sizeof(ar) / sizeof(*ar); ++i)
    s += ar[i];
```

Как правило, сложности в понимании самой парадигмы, как набора команд, у начинающего программиста не возникает. Наверное, потому что мы, буквально, вырастаем в среде, где постоянно раздаются различные команды. И позже, перейти к другой парадигме, другой схеме мышления, оказывается не так просто.

Тем не менее, общая концепция ООП достаточно проста. Нужно лишь к ней привыкнуть и использовать во всей полноте. И мы сейчас с вами сделаем первый шаг для «перепрошивки» наших мозгов, чтобы уйти от чистого императивного программирования в сторону ООП.

---
[Содержание](#содержание)

### Объекты и классы

Начнем с того, что часто, решаемую задачу, можно разложить на относительно независимые блоки (подзадачи), которые, взаимодействуя между собой, достигают исходной поставленной цели. Давайте образно представим часы, как задачу проекта. Условно ее можно разложить на объекты: «циферблат», «маятниковый часовой механизм», «корпус». Эти объекты, согласованно взаимодействуя между собой, образуют единое устройство – маятниковые часы. И я здесь произнес первое важное слово – объект. Что такое объект в концепции ООП? В большинстве ЯП каждый объект располагается в независимой области памяти и содержит определенные данные. Например, объект «циферблат» может иметь:

+ unsigned radius; // размер циферблата
+ unsigned color; // цвет циферблата

И так далее. Все эти свойства объектов программист придумывает сам. В результате, может формироваться множество объектов, отличающихся между собой этими количественными характеристиками, образуя единый класс таких объектов. В парадигме ООП именно класс отвечает за порождение объектов определенного вида. Например, можно описать класс круглых циферблатов:

```c++
class RoundDial {
    type_digits type; // тип чисел на циферблате (арабские, римские)
    unsigned color; // цвет циферблата
};
```

А, затем, создавать объекты этого класса:

```c++
RoundDial rd1, rd2, rd3;
```

То есть, класс в ООП выступает в роли схемы, чертежа, по которому конструируются объекты этого класса. Программисту достаточно объявить нужный класс, чтобы, затем, формировать множество объектов соответствующего типа. И так для всех объектов, используемых в программе.

---
[Содержание](#содержание)

### Методы класса

Также с каждым объектом, помимо данных, могут быть еще связаны специальные функции, именуемые методами. Как правило, именно через них происходит взаимодействие с объектами. Например, в классы можно было бы добавить следующие методы:

```c++
class RoundDial {
    unsigned radius; // размер циферблата
    unsigned color; // цвет циферблата
 
public:
    void update(); 
    void set_color(unsigned);
    void set_radius(unsigned);
};
…
```

В результате каждый объект класса имеет свой независимый набор данных и общий набор методов, через которые происходит взаимодействие с этим объектом. То есть, каждый объект превращается в активный элемент программы, в котором выполняется логика работы алгоритма, описанная в классе этого объекта. Таким образом, класс выступает независимой единицей программного кода, в котором реализован определенный фрагмент. Например, класс `RoundDial` берет на себя всю логику обработки и отображения круглых часовых циферблатов. Класс `PClockWork` – логику работы часового механизма. А класс `GroundClock` обеспечивает функционирование часов, как единое целое. <br>
То есть, классы – это не просто хранилища данных, а полноценные фрагменты программы, работающие, по возможности, независимо друг от друга и остальной части программы. Причем работа алгоритма класса, как правило, выполняется на уровне объектов, так как именно объекты содержат конкретные данные, которые можно обрабатывать тем или иным способом (алгоритмом). А в классе лишь объявляются данные для объектов и порядок их обработки на уровне методов. То есть, класс нужно воспринимать, как схему, чертеж, по которой формируются и работают его объекты.

---
[Содержание](#содержание)

### Инкапсуляция

Но раз класс образует единую и независимую программную единицу со своей внутренней логикой работы, то должен существовать механизм, который бы «защищал» класс от внешних некорректных действий, нарушающих целостность его работы? И такой механизм в ООП, конечно же, есть. Он получил название инкапсуляции и часто реализуется через ограничение доступа к переменным и методам класса. Например, в классе PClockWork все переменные размещаются в закрытой (приватной) секции. И доступ к ним возможен только изнутри объекта или внутри методов при их вызове. Напрямую, извне доступ к этим данным ограничен. А вот методы, через которые происходит взаимодействие, должны объявляться как открытые (публичные), чтобы иметь к ним доступ извне. То есть, определяя тот или иной класс, программист разрешает взаимодействие с ним через публичные разрешенные методы и реже напрямую через данные. Соответственно, методы должны быть построены так, чтобы их вызов не нарушал целостность данных объекта и логику его работы, обеспечивая, тем самым, защиту объектов класса.

---
[Содержание](#содержание)

### Наследование и полиморфизм

А теперь самое главное, что ООП делает по-настоящему новой парадигмой программирования, а не просто описанием программы на уровне независимых объектов. Новые классы можно определять на основе других, ранее сформированных классов. В концепции ООП это называется наследованием классов. При этом классы, от которых происходит наследование, получили название базовых, а новые сформированные – дочерних.

На первый взгляд, ничего особенного. Просто, еще один способ объявления новых классов. Но не спешите с выводами. Базовые и дочерние классы  образуют такой симбиоз, который выводит ООП на совершенно новый уровень проектирования программ. Я покажу это на примере наших часов.

Смотрите, всю логику взаимодействия между объектами можно описать на общем уровне – уровне базовых классов, так как в них объявлены все необходимые для этого переменные и методы. А конкретная реализация будет определяться дочерними классами. Причем, методы в базовых классах можно объявлять так, чтобы реализации для них подставлялись из соответствующих дочерних классов. В концепции ООП это называется полиморфизмом. В результате, для одного набора дочерних классов мы получаем одно программное решение, а для другого набора – совершенно другое. При этом в будущем, нам будет достаточно определить какие-либо новые дочерние классы, чтобы они автоматически встраивались в общую логику работы программы и давали качественно новый результат. Именно качественно новый, так как классы – это, фактически, реализации отдельных алгоритмов. Поэтому, меняя дочерние классы, мы меняем на алгоритмическом уровне поведение соответствующих частей программы. И это потрясающий способ организации программного кода, который дает нам парадигма ООП, основанная на трех базовых элементах:

+ инкапсуляции – обеспечение целостности данных и их обработки;
+ наследовании – образование одних классов из других;
+ полиморфизма – взаимодействие с тем или иным дочерним классом через базовый класс.

---
[Содержание](#содержание)

### Заключение

Ничего подобного классический императивный подход к программированию нам дать не может. Конечно, если программа небольшая и не сложная, то писать ее с использованием  ООП нет никакого смысла. Но реальные проекты средней и более высокой сложности без применения ООП сейчас практически невозможны. Объектно-ориентированный подход позволяет нам относительно просто создавать по-настоящему модульные программы, описывать логику на общем уровне, и достаточно просто расширять функционал, добавляя новые дочерние классы.

#### Подвиг 1. Выберите верные утверждения, касающиеся классов в ООП C++

+ [ ] класс может содержать переменные (поля), но не методы (функции)
+ [x] от одного класса можно порождать множество объектов
+ [ ] от одного объекта можно порождать множество классов
+ [ ] от одного класса можно порождать только один объект
+ [x] класс следует воспринимать, как схему (чертеж), согласно которой создаются объекты класса
+ [x] класс может содержать переменные (поля) и методы (функции)

#### Подвиг 2. Выберите верные утверждения, касающиеся объектов классов в ООП C++

+ [ ] логика работы класса, как правило, выполняется (отрабатывает) на уровне этого же класса, а не объекта
+ [x] логика работы класса, как правило, выполняется (отрабатывает) на уровне его объектов
+ [x] объект класса - это программная единица, хранящая, как правило, уникальную информацию
+ [x] через объекты класса можно обращаться к публичным переменным класса
+ [x] через объекты класса можно вызывать публичные методы класса

#### Подвиг 3. Выберите верные утверждения, касающиеся понятия инкапсуляции в ООП C++

+ [ ] механизм инкапсуляции - это создание дочерних классов на основе базовых
+ [ ] инкапсуляция часто реализуется путем объявления публичных (общедоступных) атрибутов классов (переменных, методов и т.п.)
+ [x] инкапсуляция часто реализуется через ограничение прямого доступа к некоторым атрибутам класса (переменным, методам и т.п.)
+ [ ] механизм инкапсуляции позволяет вызывать переопределенные методы в дочерних классах из базового класса
+ [x] инкапсуляция позволяет сохранять целостность и независимость класса

#### Подвиг 4. Выберите верные утверждения, касающиеся понятия наследования классов в ООП C++

+ [x] благодаря механизму наследования общие элементы разных классов можно вынести в один базовый класс
+ [ ] благодаря механизму наследования можно вызывать из базового класса методы, которые переопределены в дочернем классе
+ [ ] наследование позволяет определять (объявлять) классы, как единые и независимые программные единицы
+ [x] наследование - это описание (объявление) дочерних (производных) классов на основе базовых (родительских) классов
+ [x] благодаря механизму наследования можно менять и расширять логику работы базовых классов

#### Подвиг 5. Выберите верные утверждения, касающиеся понятия полиморфизм в ООП C++

+ [ ] полиморфизм - это описание (объявление) дочерних (производных) классов на основе базовых (родительских) классов
+ [x] благодаря наследованию и полиморфизму можно описывать логику работы программы на обобщенном (абстрактном) уровне, а конкретика позже определяется дочерними классами
+ [ ] полиморфизм - это возможность определения (объявления) классов, как единых и независимых программных единиц
+ [x] полиморфизм - это возможность вызова через базовый класс метода, переопределенного в дочернем классе

#### Подвиг 6. Отметьте основные базовые элементы, которые составляют основу ООП C++

+ [x] инкапсуляция
+ [ ] верификация
+ [x] полиморфизм
+ [x] наследование
+ [ ] унификация

#### Подвиг 7. Можно ли создавать программы без использования ООП?

+ [ ] нет, ООП - неотъемлемая часть больших приложений
+ [ ] да, но только относительно простые
+ [ ] можно, но тогда придется отказаться от функционального подхода к программированию
+ [x] да, например, используя парадигму структурного программирования (не включая ООП)

---
[Содержание](#содержание)

## 1.1 Понятие классов и объектов

[Смотреть материал на видео](https://www.youtube.com/watch?v=jKHmz5MEvNw&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

[Понятие классов и объектов](/OOP_C_C++/videos/01.02.mp4)

Ранее была рассмотрена база языка C/C++ и, конечно, я буду полагать, что вы ее уже знаете. Поэтому, если вы по каким-либо причинам не уверены в своих знаниях по базе языка C/C++, то настоятельно рекомендую начать с основ, а уже потом переходить к этой части – объектно-ориентированному программированию (ООП).

Из вводной части вы уже знаете, что основу ООП составляют классы и их объекты. Поэтому мы с вами начнем с порядка объявления классов на языке C++ и способов создания их объектов.

Исторически так сложилось, что, фактически, классы в C++ можно объявить двумя способами. Первый нам уже знаком по базовому курсу и состоит в объявлении структур. Например, очень простую структуру Point для представления точек на плоскости можно записать следующим образом:

```c++
struct Point {
    int x, y;
};
```

Напомню, что имя структуры Point в C++ воспринимается как самостоятельный тип данных и может быть использован для создания переменных этого типа. Например:

```c++
Point pt;
```

или

```c++
Point* ptr_pt = new Point;
```

Так вот, в концепции ООП и переменная `pt`, и выделенная в куче память для `ptr_pt`, образуют объекты типа `Point`. Причем первый объект `pt` размещается в стековом фрейме, который ограничен по объему, а второй, как я уже сказал, в куче, то есть, в свободной памяти устройства. Второй вариант создания объектов встречается наиболее часто, так как обычно в программах предполагается создание большого числа объектов, которые, к тому же, должны существовать продолжительное время и быть доступны в разных частях программы. Как только необходимость в объекте пропадает, выделенную память нужно обязательно освободить:

```c++
delete ptr_pt;
```

![01](/OOP_C_C++/img/01_05.PNG)

Однако структуры – это исторически первый вариант объявления типов объектов. С появлением в C++ ООП, как новой парадигмы, классы объектов предполагается описывать с помощью ключевого слова `class` по аналогии со структурами. Например:

```c++
class Point2D {
    int x, y;
};
```

И, далее, абсолютно так же можно создавать объекты этого класса:

```c++
Point2D pt2D;
Point2D* ptr_pt2D = new Point2D;
```

В чем же разница между этими двумя способами объявлений классов? В действительности, между структурами языка C++ и его классами имеется только одно принципиальное отличие:

**Все поля структуры по умолчанию являются публичными и доступны напрямую, извне. Тогда, как поля класса по умолчанию приватны и недоступны вне класса.**

![01](/OOP_C_C++/img/01_06.PNG)

Покажу это на простом примере. Через объект `pt` структуры `Point` мы можем совершенно спокойно обратиться к полю x и присвоить ему какое-либо значение:

```c++
pt.x = 1;   // ok
```

Сделать то же самое через объект класса Point2D не получится, т.к. поле x приватно, закрыто от внешнего доступа:

```c++
pt2D.x = 1; // ошибка
```

Во всем остальном структуры и классы идентичны. Но, несмотря на это, опять же, исторически сложилось, что

+ **структуры** в программах используются для описания набора данных,
+ а **классы** – для описания объектов в концепции ООП.

Поэтому, когда говорят о классах в C++, то подразумевают определение через ключевое слово `class`, а не `struct`.

---
[Содержание](#содержание)

### Что такое класс в ООП

Мы уже знаем, что в классах могут быть объявлены поля (то есть, переменные) и методы (функции-члены классов). Например:

```c++
class Point2D {
    int x, y;
public:
    void set_coords(int a, int b)
        {x = a; y = b;}
    void get_coords(int& a, int& b)
        {a = x; b = y;}
};
```

Здесь `x`, `y` – приватные (закрытые) поля; `set_coords()` и `get_coords()` – публичные методы. Напомню, что когда мы проходили тему структур языка С++, то говорили о приватных секциях (задается ключевым словом `private`) и публичных (задается ключевым словом `public`). В классах все абсолютно так же, только по умолчанию все располагается в приватной секции.

Далее, обратите внимание, что в классе `Point2D` переменные `x`, `y` лишь объявляются, но не размещаются в памяти. То есть, память под `x` и `y` нигде не выделяется, т.к. это поля будущих объектов, а класс – лишь тип данных, но не сами данные. А вот методы `set_coords()` и `get_coords()` можно воспринимать, как обычные функции, принадлежащие классу и заданные в области видимости этого класса. То есть, имя класса `Point2D` помимо типа данных еще определяет и область видимости. А раз так, то формально к функциям класса можно обращаться по синтаксису:

```c++
Point2D::get_coords;
```

В будущем эта конструкция нам еще пригодится.

---
[Содержание](#содержание)

### Что такое объект в ООП. Неявный указатель this

Давайте теперь детальнее посмотрим, что из себя представляют объекты классов. Пусть для простоты они формируются командой:

```c++
Point2D pt1, pt2, pt3;
```

В результате, каждый объект будет размещен в своей независимой области памяти (в данном случае в стековом фрейме) и будет содержать целочисленные переменные x и y. То есть, у каждого объекта будут свои независимые переменные x и y, которые определяют координаты точки на плоскости.

А вот методы у всех объектов общие и располагаются в классе Point2D. Но как тогда метод «понимает», с данными какого объекта он должен работать? Об этом мы с вами тоже уже говорили. Когда происходит вызов метода через объект класса, например:

```c++
pt1.set_coords(1, 2);
```

то компилятор автоматически и неявно в этот метод передает специальный указатель с именем `this`, который ссылается на этот объект (в данном примере на объект `pt1`). При этом тип указателя `this` соответствует типу класса объекта. В нашем случае – `Point2D*`. Соответственно, через неявный указатель `this` выполняется доступ к переменным `x`, `y` текущего объекта `pt1`. Поэтому, как вариант, мы можем записать тело метода `set_coords` следующим образом:

```c++
void set_coords(int a, int b) {
    this->x = a; 
    this->y = b;
}
```

Если указатель `this` не прописывается:

```c++
void set_coords(int a, int b) {
    x = a; 
    y = b;
}
```

то он подразумевается при доступе к переменным объекта.

![01](/OOP_C_C++/img/01_07.PNG)

Так, благодаря неявному указателю `this`, единый набор методов класса может обрабатывать данные объектов, через которые они были вызваны. Именно по этой причине обычные методы вызывать напрямую из класса нельзя. Следующая команда приведет к ошибке на этапе компиляции:

```c++
Point2D::set_coords(1, 2);
```

Метод `set_coords` не может быть вызван без привязки к какому-либо объекту класса `Point2D`, так как компилятор не может определить значение неявного указателя `this`. Собственно этим методы класса отличаются от обычных функций: в методы дополнительно передается указатель `this`.

В заключение этого занятия напомню, что когда объекты класса формируются с помощью оператора new, например, так:

```c++
Point2D* p = new Point2D;
```

или так:

```c++
Point2D* p = new Point2D();
```

то обращение к переменным и методам выполняется через оператор `->`:

```c
p->set_coords(10, 20);
```

В конце, конечно же, не забываем освобождать выделенную под объект память:

```c++
delete p;
```

Как я уже говорил, объекты классов чаще всего формируются, как раз с помощью оператора `new` и уничтожаются вызовом оператора `delete`. Поэтому дальше мы часто будем использовать этот подход к порождению объектов класса.

#### Подвиг 1. Выберите все верные варианты объявления классов в C++

P.S. Здесь под классом понимается тип данных, который может содержать переменные, методы и прочие допустимые элементы.

+ [x] struct Car { };
+ [ ] void House() { }
+ [ ] char* String = "Class";
+ [ ] int Tree;
+ [x] class Book { };

#### Подвиг 2. Используя ключевое слово class, объявите класс с именем Variable, содержащий два публичных поля (переменные)

+ short var_sh;
+ double var_d;

P.S. В программе требуется только объявить класс, ничего более делать не нужно.

```c++
class Variable {
  public:
    short var_sh;
    double var_d;
};
```

#### Подвиг 3. Выберите верные утверждения справедливые для классов в C++

+ [x] класс образует пространство имен для переменных и методов, объявленных в нем
+ [x] класс, объявленный ключевым словом struct, по умолчанию все поля делает публичными (общедоступными)
+ [x] класс, объявленный ключевым словом class, по умолчанию все поля делает приватными (закрытыми для общего пользования)
+ [x] переменные в классе лишь объявляются, но не создаются (не размещаются в памяти устройства)
+ [x] каждый класс (объявленный в программе) можно воспринимать как новый (пользовательский) тип данных
+ [ ] классы порождаются от своих объектов

#### Подвиг 4. Выберите все верные утверждения, касающиеся методов класса

+ [x] метод имеет доступ ко всем переменным, объявленных в том же классе, через неявный указатель this
+ [x] метод имеет доступ ко всем переменным, объявленных в том же классе, через их имена
+ [ ] метод имеет доступ только к публичным переменным, объявленных в том же классе, через их имена
+ [x] из тела метода можно обращаться ко всем атрибутам текущего класса (область видимости - весь класс)

#### Подвиг 5. Выберите все верные утверждения, касающиеся следующего фрагмента программы

```c++
#include <string>

class Cat {
    std::string name; // имя кота
    char old; // возраст (число)
    int color; // цвет
public:
    void set_data(const std::string& name, char old, int color)
    {
        this->name = name;
        this->old = old;
        this->color = color;
    }
};

int main()
{
    Cat cat;
    cat.set_data("Murzik", 4, 255);
    Cat::set_data("Dragon", 7, 0);

    return 0;
}
```

+ [x] при вызове метода set_data через объект cat в метод неявно передается указатель this, который ссылается (указывает) на объект cat
+ [ ] при вызове метода set_data через объект cat в метод неявно передается указатель this, который ссылается (указывает) на класс Cat
+ [x] в методе set_data конструкция this->переменная выполняет обращение к соответствующей переменной текущего объекта
+ [x] в методе set_data имена name, old, color связаны с параметрами этого метода
+ [ ] в методе set_data имена name, old, color связаны с переменными текущего объекта класса (через который был вызван метод)
+ [x] при компиляции программы возникнет ошибка, т.к. вызывать метод set_data напрямую из класса нельзя

Заметка. Далее в подвигах все классы следует объявлять с помощью ключевого слова class, если не будет явно указано другое.

#### Подвиг 6. Объявите класс с именем CartData, содержащий следующие элементы

+ приватные переменные:
  + unsigned long id;
  + char name[100];
  + unsigned price;
  + double weight;

+ публичные методы:
  + void get_data(unsigned long &id, unsigned &price, double &weight); // возвращает через ссылки перечисленные поля
  + char* get_name(); // возвращает наименование товара (поле name)
  + void set_data(unsigned long id, const char* name, unsigned price, double weight); // заносит в перечисленные поля переданные значения

Методы в этом и последующих подвигах должны быть с соответствующими реализациями.

В функции `main` создайте объект класса `CartData` в виде переменной с именем ***item*** (не указатель). Занесите в его поля (переменные) следующие данные:

+ id: 10
+ name: "Toy"
+ price: 2000
+ weight: 5.45

P.S. На экран ничего выводить не нужно.

```cpp
#include <iostream>
#include <string.h>

class CartData {
  unsigned long id;
  char name[100];
  unsigned price;
  double weight;

public:
  // возвращает через ссылки перечисленные поля
  void get_data(unsigned long &id, unsigned &price, double &weight) {
    id = this->id;
    price = this->price;
    weight = this->weight;
  }
  // возвращает наименование товара (поле name)
  char *get_name() { return name; }

  // заносит в перечисленные поля переданные значения
  void set_data(unsigned long id, const char *name, unsigned price,
                double weight) {
    this->id = id;
    strcpy(this->name, name);
    this->price = price;
    this->weight = weight;
  }
};
int main(void) {
  CartData item;
  item.set_data(10, "Toy", 2000, 5.45);

  // __ASSERT_TESTS__
  return 0;
}
```

#### Подвиг 7. Объявите класс с именем Vector3D, содержащий следующие элементы

+ приватные переменные:
  + int x, y, z; // координаты в трехмерном пространстве
+ публичные методы:
  + void set_coords(int a, int b, int c); // заносит в поля x, y, z значения a, b, c
  + void get_coords(int& x, int& y, int& z); // возвращает (через ссылки) значения координат

При реализации метода `set_coords` необходимо выполнить проверку, что передаваемые координаты `a, b, c` находятся в диапазоне `[-100; 100]`. Если хотя бы одна координата выходит из этого диапазона, то поля `x, y, z` меняться не должны (присваивать ничего не нужно).

В функции `main` создайте через метод `new` два объекта класса `Vector3D`, на которые должны вести указатели `ptr_v1`, `ptr_v2`. Занесите в эти объекты координаты:

+ ptr_v1: 10, -5, 7
+ ptr_v2: 0, 12, -56

В конце функции `main` не забудьте освободить ранее выделенную память.

P.S. На экран ничего выводить не нужно.

---
[Содержание](#содержание)

## 1.2 Режимы доступа public и private

[Смотреть материал на видео](https://www.youtube.com/watch?v=jBbEOHkWE38&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

Продолжаем знакомство с ООП языка C++ и вначале несколько подробнее поговорим о режимах доступа private и public. На предыдущем занятии мы с вами работали со следующим классом:

```c++
class Point2D {
    int x, y;
public:
    void set_coords(int a, int b) 
        {x = a; y = b;}
    void get_coords(int& a, int& b)
        {a = x; b = y;}
};
```

И я отмечал, что переменные `x`, `y` объявляются в приватной секции (`private`), так как класс (`class`), в отличие от структур, по умолчанию располагает все определения именно в приватной секции. Конечно, мы можем ее прописать и явно, например:

```c++
class Point2D {
private:
    int x, y;
public:
    void set_coords(int a, int b) 
        {x = a; y = b;}
    void get_coords(int& a, int& b)
        {a = x; b = y;}
};
```

Это будет одно и то же. Тем не менее, ключевое слово `private` записывать необходимо для обозначения начала приватной секции, например, после публичной:

```c++
class Point2D {
public:
    void set_coords(int a, int b) 
        {x = a; y = b;}
    void get_coords(int& a, int& b)
        {a = x; b = y;}
private:
    int x, y;
};
```

Если бы мы здесь не прописали `private`, то переменные `x`, `y` располагались бы в публичной (общедоступной) секции. Кроме того, в ряде случаев, явное указание `private` облегчает чтение текста программы.

Чем отличаются между собой секции `private` и `public` вы должны уже знать. Но я решил собрать всю эту информацию и еще раз повторить ее здесь. Начнем с публичной секции.

Все элементы (допустимые конструкции языка C++), объявленные в `public`, доступны как внутри объекта класса, так и за его пределами. Например, методы `set_coords` и `get_coords` совершенно свободно можно вызывать через объекты класса `Point2D`:

```c++
Point2D pt;
pt.set_coords(1, 2);
```

И внутри (в телах) других методов класса:

```c++
class Point2D {
private:
    int x, y;
    
public:
    void set_coords(int a, int b) 
        {x = a; y = b;}
 
    bool set_coords_range(int a, int b, int min_coord = 0, int max_coord = 100)
        {
            if(a < min_coord || a > max_coord || b < min_coord || b > max_coord)
                return false;
            
            set_coords(a, b);
            return true;
        }
 
    void get_coords(int& a, int& b)
        {a = x; b = y;}
};
```

А вот к элементам приватной секции (переменным `x`, `y`) можно получить доступ только изнутри класса и его объектов. Например, через вызов методов `set_coords` и `get_coords`. В момент их вызова можно условно представить, что тело метода отрабатывает внутри класса (и то же самое, внутри объекта класса). Поэтому в теле метода мы имеем доступ ко всем приватным определениям объектов класса. Но напрямую вне объекта при обращении к приватным полям компилятор выдаст ошибку:

```c++
pt.x = 10; // ошибка
```

Вот в чем отличия приватной секции от публичной. И здесь важно понимать два момента:

+ Ограничение доступа `private` и `public` работает на уровне классов, а не на уровне объектов.
+ Ограничение доступа – это способ защиты программиста от возможного неправильного использования класса, а не от злоумышленников.

Давайте я поясню эти два утверждения. Первое. Что значит ограничение на уровне класса? Предположим, что мы бы хотели добавить метод в класс `Point2D`, который бы вычислял евклидово расстояние между текущей и второй переданной точкой. Этот публичный метод можно определить следующим образом:

```c++
    double length_to(const Point2D& pt)
    { 
            return sqrt((x-pt.x)*(x-pt.x) + (y-pt.y)*(y-pt.y)); 
    }
```

А, затем, вызвать:

```c++
int main() {
    Point2D pt, endp;
    
    pt.set_coords(1, 2);
    endp.set_coords(10, 20);
 
    double len = pt.length_to(endp);
 
    return 0;
}
```

Смотрите, в методе `length_to` мы имеем возможность работать с приватными переменными `x`, `y` двух разных объектов класса `Point2D`: текущего, через который был вызван метод; и переданного через параметр по ссылке. Это, как раз, говорит о том, что метод `length_to`, объявленный внутри класса, получает доступ к приватным объявлениям любого объекта этого класса. То есть, защита работает на уровне всего класса, а не отдельных объектов.

Второе утверждение о защите программиста от возможных ошибок касается корректного (правильного) использования класса и его объектов в тексте программы. Если что-либо помещено в приватную секцию, то разработчик класса полагает обращение к этим элементам извне выполняется только через публичные методы класса, а не напрямую. Причем, приватными могут быть не только переменные, но и некоторые методы класса. Все, что находится в приватной зоне предназначено исключительно для внутреннего использования, но никак не для внешнего. Конечно, ушлый программист достаточно легко может обойти эту «защиту» и напрямую поменять значение любой приватной переменной. И программа даже может работать при такой реализации. Правда, здесь возможны следующие проблемы:

+ программа на самом деле работает некорректно, просто программист этого пока еще не заметил;
+ в будущем структура класса может поменяться и его прежнее использование с прямым доступом к приватным данным легко поломает внутреннюю логику работы этого класса.

Поэтому такие ушлые программисты либо быстро отучиваются делать такие «пакости», либо лишаются работы. Здесь следует придерживаться строгого правила: все элементы приватных секций предназначены исключительно для внутренней логики работы класса и его объектов. Вклиниваться в эту работу со стороны – строго запрещено. Это, как попытаться менять масло в работающем моторе. Ни к чему хорошему это не приведет. Также и с объектами классов – это отдельно и независимо работающие программные единицы и вмешиваться в их работу не нужно, допустимо только управление через публичные методы, которые для этого и предназначены. Ровно так, как руль или педали газа/тормоза предназначены для управления автомобилем. Роно так следует воспринимать и публичные методы для управления состоянием того или иного объекта. Это принцип инкапсуляции, о котором мы говорили на вводном занятии. Через механизм защиты с помощью секций `private` и `public` она (инкапсуляция) и реализуется.

---
[Содержание](#содержание)

## 1.3 Конструкторы. Конструктор по умолчанию. Перегрузка конструкторов

[Смотреть материал на видео](https://www.youtube.com/watch?v=6OMiBbbmOCU&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

### Конструкторы

Итак, на предыдущем занятии у нас с вами получился следующий класс (если записать его в укороченном виде):

```c++
class Point2D {
    int x, y;
 
public:
    void set_coords(int a, int b) 
        {x = a; y = b;}
    void get_coords(int& a, int& b)
        {a = x; b = y;}
};
```

И мы знаем, что объекты этого класса могут создаваться либо так:

```c++
Point2D pt;
```

либо так:

```c++
Point2D* ptr_pt = new Point2D;
```

И здесь возникает один важный тонкий момент. После создания объекта класса `Point2D` мы ничего не можем сказать о его внутреннем состоянии, то есть, о значениях переменных `x` и `y`. Получается, что созданные объекты находятся в неопределенном состоянии. Это нарушает одно из положений ООП:

**Программист не должен делать каких-либо предположений о внутреннем состоянии объекта. Поведение любого объекта должно быть предсказуемым.**

Класс `Point2D` явно нарушает это правило. Если вывести значения координат созданных объектов:

```c++
int main() {
    Point2D pt;
    Point2D* ptr_pt = new Point2D;
    
    int x, y;
 
    pt.get_coords(x, y);
    std::cout << x << " " << y << std::endl;
 
    ptr_pt->get_coords(x, y);
    std::cout << x << " " << y << std::endl;
 
    delete ptr_pt;
 
    return 0;
}
```

То увидим в консоли неопределенные значения. Как же это исправить? Очень просто! После размещения нового объекта в памяти устройства всегда автоматически вызывается специальный метод, который называется конструктор. И в этом методе, как раз, часто выполняется установка начального состояния нового созданного объекта.

Конструкторы обладают следующими свойствами:

+ имя конструктора всегда должно совпадать с именем типа данных, в нашем случае с именем класса `Point2D`;
+ конструктор никогда не возвращает никаких значений, поэтому возвращаемый тип не прописывается;
+ конструктор может иметь произвольное число параметров;
+ конструктор всегда вызывается при создании каждого нового объекта.

Учитывая все это, объявим конструктор в классе `Point2D` следующим образом:

```c++
class Point2D {
    int x, y;
 
public:
    Point2D() : x(0), y(0)  // конструктор объекта
        { }
 
    void set_coords(int a, int b) 
        {x = a; y = b;}
    void get_coords(int& a, int& b)
        {a = x; b = y;}
};
```

Обратите внимание, как выполняется инициализация полей `x`, `y` при вызове конструктора. После его определения, но перед телом конструктора, ставится двоеточие и через запятую прописывается инициализация переменных `x` и `y` нулевыми значениями. И это рекомендуемая практика. Такая инициализация гарантирует, что в теле конструктора переменные `x`, `y` будут принимать нужные нам начальные значения. Кроме того, в списке инициализации переменные следует прописывать в порядке их объявления в классе. У нас сначала указана переменная `x`, а затем, переменная `y`. Именно поэтому в блоке инициализации в конструкторе переменные идут в том же порядке. Наконец, список инициализации – это единственный способ инициализации константных переменных непосредственно в конструкторе. Например:

```c++
class Point2D {
    const unsigned max_coord;
    int x, y;
 
public:
    Point2D() : max_coord{100}, x(0), y(0)  // конструктор объекта
        { }
    ...
};
```

После определения конструктора без параметров, при создании каждого нового объекта класса Point2D будем иметь нулевые значения координат. В результате мы с вами устранили неопределенность состояния создаваемых объектов.

Помимо использования списка инициализации в конструкторах, имеется возможность указывать инициализацию переменных непосредственно в классе при их объявлении. Например, так:

```c++
class Point2D {
    int x {0}, y {0};
...
};
```

И это рекомендуемая практика, которая гарантирует нужные нам начальные значения и, как следствие, начальное состояние объекта, даже если по каким-либо причинам в классе не будет явно определено ни одного конструктора. Даже в этом случае начальная инициализация, которая будет выполняться в момент создания каждого объекта, гарантирует его предсказуемое поведение.

---
[Содержание](#содержание)

### Конструктор по умолчанию

В концепции ООП конструкторы, которые можно вызывать без параметров, называются конструкторами по умолчанию. В частности, конструктор, объявленный в классе `Point2D`, является таким. Но мы можем переписать этот же конструктор с двумя параметрами и значениями по умолчанию, например:

```c++
class Point2D {
    int x, y;
 
public:
    Point2D(int a = 0, int b = 0) : x(a), y(b)  // конструктор объекта
        { }
    ...
};
```

который также будет считаться конструктором по умолчанию, так как мы можем его вызывать, не передавая никаких аргументов.

Почему акцентрируется внимание на такой тип конструкторов?

Дело в том, что в языке C++ им отведена своя особая роль. Мы уже видели, что такой конструктор срабатывает всякий раз, когда объект создается обычным образом, без указания каких-либо дополнительных аргументов. Также этот тип конструктора вызывается при создании массива объектов. Например:

```c++
Point2D ar_pt[5];
```

Здесь создается пять объектов класса `Point2D` и для каждого автоматически вызывается конструктор по умолчанию.

Внимательный слушатель сейчас может задаться вопросом, а как создаются объекты класса `Point2D` без явного объявления конструктора в классе? Он же должен всегда вызываться сразу после размещения нового объекта в памяти. А если конструктор не прописан, то что вызывается? И вызывается ли вообще? На самом деле в любом классе всегда имеется конструктор и, как мы увидим позже, не один. Если мы не прописываем свой собственный, то компилятор автоматически создает конструктор по умолчанию без параметров и с пустым телом, который не выполняет никаких действий и нужен лишь для сохранения общей логики создания объектов без передачи каких-либо аргументов.

---
[Содержание](#содержание)

### Перегрузка конструкторов

Так как конструкторы могут иметь произвольные параметры, то в одном классе можно объявлять несколько конструкторов с разным набором параметров. Например, следующим образом:

```c++
class Point2D {
    int x {0}, y {0};
 
public:
    Point2D() : x(0), y(0)
        { }
    Point2D(int a, int b) : x(a), y(b)
        { }
...
};
```

Соответственно, если объект создается без указания аргументов:

```c++
Point2D* ptr_pt = new Point2D;
```

то вызывается конструктор по умолчанию (без параметров). А если объект создается с двумя аргументами:

```c++
Point2D pt(1, 2);
```

то вызывается конструктор с двумя параметрами. Компилятор именно по типу и числу аргументов выбирает тот или иной конструктор при формировании нового объекта. Сами же конструкторы становятся перегруженными. И, как видите, перегрузка здесь происходит по тем же правилам, что и перегрузка обычных функций.

Благодаря наличию двух конструкторов в классе `Point2D`, его объекты можно создавать двумя способами: без аргументов и с указанием двух аргументов. В этом удобство механизма перегрузки конструкторов класса. Но, как мы увидим дальше, перегрузка конструкторов необходима не только для удобства создания объектов в том или ином виде, но и для обеспечения стандартных операций с объектами класса, например, копирования.

---
[Содержание](#содержание)

## 1.4 Конструктор преобразования. Деструктор

[Смотреть материал на видео](https://www.youtube.com/watch?v=WYXcAyVi6ps&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

### Конструктор преобразования

Продолжаем рассматривать варианты реализаций конструкторов в классах языка C++. И следующим шагом поближе посмотрим на работу конструктора с одним параметром. Для примера я объявлю простой класс, который будет описывать объекты комплексных чисел:

```c++
class Complex {
    double re;
    double im;
 
public:
    Complex() : re(0.0), im(0.0)
        { }
    Complex(double real) : re(real), im(0.0)
        { }
    Complex(double real, double imag) : re(real), im(imag)
        { }
 
    void get_data(double& re, double& im)
    {
        re = this->re;
        im = this->im;
    }
};
```

Здесь все вам должно быть знакомо. Очевидно, объекты этого класса допустимо создавать следующими командами:

```c++
int main() {
    Complex c1;
    Complex c2(0.5);
    Complex c3(-5.4, 7.8);
 
    return 0;
}
```

Или, вместо круглых скобок, мы можем прописывать фигурные инициализирующие скобки:

```c++
    Complex c1 {};
    Complex c2 {0.5};
    Complex c3 {-5.4, 7.8};
```

Это полный аналог предыдущего варианта создания объектов класса `Complex`. Однако мы знаем, что фигурные скобки также можно заменить на обычный знак равенства, который будет аналогом операции инициализации объекта:

```c++
    Complex c1;
    Complex c2 = 0.5;
    Complex c3 = { -5.4, 7.8 };
```

И, смотрите, что, по сути, происходит в момент создания объекта `c2`. Справа от инициализатора записано вещественное значение типа `double`, а слева – формируется объект типа `Complex`. То есть, из одного типа данных (`double`) получается объект другого типа данных (`Complex`) с вызовом конструктора, содержащим один параметр. Получается, что этот конструктор позволяет нам преобразовывать вещественные числа в объекты класса `Complex`. Именно поэтому такие конструкторы (с одним параметром) получили название конструкторов преобразования.

Возможно, на данный момент пока еще не так очевидна их роль. Поэтому я приведу пример реализации метода для прибавления к текущему комплексному числу другого комплексного числа:

```c++
    const Complex& add(const Complex& other) {
        this->re += other.re;
        this->im += other.im;
        return *this;
    }
```

Воспользоваться этим методом можно следующим образом:

```c++
int main() {
    Complex c1;
    Complex c2 = 0.5;
    Complex c3 = { -5.4, 7.8 };
 
    c2.add(c3);
 
    double re, im;
    c2.get_data(re, im);
 
    std::cout << re << " " << im << std::endl;
 
    return 0;
}
```

Пока все очевидно. Но, смотрите, этот же метод может быть вызван и так:

```c++
c2.add(4.3);
```

Мы указали обычное вещественное значение, а не объект класса `Complex`. Тем не менее, все сработало и компилятор «понял», как правильно воспринимать эту команду. Как же ему это удалось? Я, думаю, вы уже догадались. Все дело в конструкторе с одним вещественным параметром. Компилятор видит, что аргументом метода должен быть объект класса `Complex`, на входе имеется вещественное число, и он делает попытку создать временный объект типа `Complex`, инициализируя его этим вещественным значением. В итоге получается преобразование вещественного числа в тип `Complex` и метод успешно выполняется.

Видите, какую неожиданную, на первый взгляд, роль играет конструктор с одним параметром, называемый конструктором преобразования.

---
[Содержание](#содержание)

### Ключевое слово explicit

Если по каким-либо причинам неявное преобразование типов следует запретить, то перед конструктором преобразования достаточно прописать ключевое слово `explicit`, которое было введено в стандарте C++11:

```c++
    explicit Complex(double real) : re(real), im(0.0)
    { }
```

В этом случае создание объекта по синтаксису:

```c++
Complex c2 = 0.5;
```

станет невозможным, т.к. предполагает неявный вызов конструктора преобразования. А вот с явным вызовом проблем не возникнет:

```c++
Complex c2(0.5);
```

или

```c++
Complex c2{ 0.5 };
```

Аналогично и при вызове метода:

```c++
c2.add(4.3);  // ошибка (неявный вызов конструктора преобразования)
c2.add(Complex(4.3)); // ok
```

---
[Содержание](#содержание)

### Деструктор класса

Классы языка C++ содержат еще один специальный метод, называемый деструктор. Что это такое и как работает я покажу на примере класса представления точек в `N`-мерном пространстве (с `N` координатами):

```c++
class PointND {
    unsigned total {0};
    int *coords {nullptr};
public:
    PointND() : total(0), coords(nullptr)
        { }
    PointND(unsigned sz) : total(sz)
    {
        coords = new int[total] {0};
    }
    PointND(int* cr, unsigned len) : total(len)
    {
        coords = new int[total];
        set_coords(cr, len);
    }
 
    unsigned get_total() { return total; }
    const int* get_coords() { return coords; }
    void set_coords(int* cr, unsigned len)
    {
        for(unsigned i = 0; i < total; ++i)
            coords[i] = (i < len) ? cr[i] : 0;
    }
};
```

У объектов класса `PointND` две переменные: `total` – общее количество координат (размерность пространства); `coords` – указатель на массив из `total` целочисленных координат. Изначально эти переменные инициализируются очевидными значениями: `0` и `nullptr`. Эта же инициализация происходит в конструкторе по умолчанию (без параметров). Либо, можно создать объект с указанной размерностью `sz` и нулевыми координатами, или с дополнительной передачей массива координат. После конструкторов объявлены простые и очевидные методы.

Некоторые из вас в этом классе сразу заметят, что в конструкторах происходит выделение памяти под массив, но нигде нет ее освобождения. То есть, при создании объектов этого класса возможна утечка памяти. Например:

```c++
int main() {
    PointND pt(5);  // утечка памяти
 
    return 0;
}
```

Как это поправить? Для этого в классах предусмотрен еще один специальный метод под названием деструктор, обладающий следующими свойствами:

+ деструктор вызывается непосредственно перед уничтожением объекта (освобождением памяти, которую он занимает);
+ имя метода называется также, как и тип данных с тильдой (`~`) вначале;
+ деструктор ничего не возвращает;
+ деструктор не имеет параметров.

Как раз этот метод служит для освобождения всех ресурсов, захваченных текущим объектом. В нашем случае – это выделенная память под массив координат. Поэтому ее освобождение следует прописывать в деструкторе класса `PointND`:

```c++
    ~PointND() {
        delete[] coords;
    }
```

Теперь никаких утечек памяти не возникает. Правда, остается ряд проблем, связанных с копированием одного объекта другому. Но эти недостатки мы поправим на следующем занятии.

---
[Содержание](#содержание)

## 1.5 Конструктор копирования. Делегирующие конструкторы

[Смотреть материал на видео](https://www.youtube.com/watch?v=MJb-ud1ZkBI&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

### Конструктор копирования

На предыдущем занятии мы с вами получили класс для представления точек в N-мерном пространстве:

```c++
class PointND {
    unsigned total {0};
    int *coords {nullptr};
public:
    PointND() : total(0), coords(nullptr)
        { }
    PointND(unsigned sz) : total(sz)
    {
        coords = new int[total] {0};
    }
    PointND(int* cr, unsigned len) : total(len)
    {
        coords = new int[total];
        set_coords(cr, len);
    }
 
    unsigned get_total() { return total; }
    const int* get_coords() { return coords; }
    void set_coords(int* cr, unsigned len)
    {
        for(unsigned i = 0; i < total; ++i)
            coords[i] = (i < len) ? cr[i] : 0;
    }
 
    ~PointND()
    {
        delete[] coords;
    }
};
```

Но остается еще одна проблема его использования. Давайте предположим, что создается новый объект `PointND` на основе ранее созданного:

```c++
int main() {
    PointND pt(5);
    PointND pt2{ pt };
 
    return 0;
}
```

В этом случае объект `pt2` будет составлять точную копию объекта `pt`, т.к. данные из области памяти `pt` побайтно копируются в область памяти `pt2`. В результате указатель `coords` этих двух разных объектов будет ссылаться на одну и ту же область памяти:

![01](/OOP_C_C++/img/01_01.png)

Соответственно, при уничтожении этих объектов, выделенная память освобождается дважды, что приводит к аварийному завершению программы.

Для исправления этой ситуации необходимо при копировании объектов дополнительно выделять память для координат нового объекта.

![01](/OOP_C_C++/img/01_02.png)

Но где этот алгоритм копирования прописать в классе PointND? Как раз для этого предназначен еще один конструктор, который называется конструктор копирования:

```c++
    PointND(const PointND& other) : total {other.total}
    {
        coords = new int[total];
        set_coords(other.coords, total);
    }
```

Обратите внимание, как он записан. У него один параметр в виде ссылки на объект текущего класса, которую часто записывают, как константную (хотя это не обязательное условие). Именно по этому типу параметра компилятор «понимает», что это конструктор копирования и использует его при создании нового объекта на основе другого того же типа.

В конструкторе копирования мы создаем новый массив координат и заносим в него значения из объекта `other`. Теперь каждый новый созданный объект класса `PointND` имеет свой собственный массив координат, который освобождается (в деструкторе) при уничтожении объекта.

Однако обратите внимание, если мы вначале создадим объект, а потом присвоим ему другой:

```c++
int main() {
    PointND pt(5);
    PointND pt2;
    pt2 = pt;
 
    return 0;
}
```

то конструктор копирования здесь срабатывать уже не будет, и мы снова получаем ту же самую проблему, т.к. по умолчанию присваивание одного объекта другому вызывает процедуру побайтного копирования данных. Конструктор копирования вызван не будет, т.к. объект создается с вызовом конструктора по умолчанию. После того, как объект создан, более никакие конструкторы не вызываются.

Забегая вперед, отмечу, что эту операцию также можно переопределить. В самом простом варианте делается это следующим образом:

```c++
    const PointND& operator=(const PointND& other)
    {
        if(this == &other) return *this; // не присваиваем объект самому себе
 
        delete[] coords;
        total = other.total;
        coords = new int[total];
        set_coords(other.coords, total);
 
        return *this;
    }
```

В результате получаем полноценный класс `PointND`.

---
[Содержание](#содержание)

### Делегирование конструкторов

Если мы внимательно посмотрим на полученный класс `PointND`, то увидим в нем некоторое дублирование кода в его конструкторах. Поправить это можно очевидным образом:

```c++
class PointND {
    unsigned total {0};
    int *coords {nullptr};
public:
    PointND() : total(0), coords(nullptr)
        { }
    PointND(unsigned sz) : total(sz)
    {
        coords = new int[total] {0};
    }
    PointND(int* cr, unsigned len) : PointND(len)
    {
//        coords = new int[total];
        set_coords(cr, len);
    }
    PointND(const PointND& other) : PointND(other.coords, other.total)
    {
//        coords = new int[total];
//        set_coords(other.coords, total);
    }
...
};
```

Смотрите, в списке инициализации также допускается вызов конструкторов текущего класса. Такой подход получил название **делегирование конструкторов**, а сами конструкторы, которые в свою очередь вызывают другие, – **делегирующими**. Благодаря делегированию часто удается сократить дублирование кода при описании классов. Поэтому такой подход не редко используется на практике.

---
[Содержание](#содержание)

## 1.6 Этапы жизни объектов классов

[Смотреть материал на видео](https://www.youtube.com/watch?v=Qq8ZLkhcebk&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

На данный момент мы с вами в целом познакомились со способами создания объектов различных классов. При этом, как бы мы их не создавали, все они формируются по единой схеме. Что это за схема? Давайте представим, что у нас простой класс `Point`:

```c++
class Point {
    int x {-1};
    int y {-1};
 
public:
    Point() : x(0), y(0)
        { }
    Point(int a, int b) : x(a), y(b)
        { }
 
    void get_coords(int& a, int& b) { a = x; b = y; }
    void set_coords(int a, int b) { x = a; y = b; }
};
```

Его объекты можно сформировать следующими командами:

```c++
int main() {
    Point pt1, pt2(1, 2);
    Point* ptr_pt1 = new Point;
    Point* ptr_pt2 = new Point(10, 20);
 
    delete ptr_pt1;
    delete ptr_pt2;
 
    return 0;
}
```

Что же стоит за словами «создание объекта» и его «уничтожение»? В действительности, все происходит по следующим этапам:

+ Выделение памяти под объект.
+ Инициализация переменных объекта.
+ Вызов конструктора объекта.
+ Жизнь объекта.
+ Вызов деструктора объекта.
+ Удаление переменных объекта (вызов их деструкторов, при необходимости).
+ Освобождение памяти, занимаемой объектом.

И так для любых объектов класса, как бы мы их ни создавали (разумеется, речь идет о корректных способах).

Обратите внимание, что после выделения памяти происходит инициализация переменных и только после этого вызов конструктора. В частности, это означает, что инициализация переменных, прописанная в классе:

```c++
class Point {
    int x {-1};
    int y {-1};
...
};
```

отрабатывает до вызова конструктора. То же самое касается и списка инициализации у конструкторов:

```c++
    Point() : x(0), y(0)
        { }
    Point(int a, int b) : x(a), y(b)
        { }
```

Переменные `x`, `y` инициализируются нулями или значениями `a`, `b`, причем, эта инициализация имеет более высокий приоритет перед инициализацией, записанной в классе. То есть, при создании объекта, например, командой:

```c++
Point pt;
```

переменные `x`, `y` будут инициализированы нулями, а не `-1`. Инициализация с `-1` будет просто проигнорирована.

Также обратите внимание, что инициализация, записанная в классе, – это лишь объявление инициализации, а не реализация. Отрабатывает она только при создании объекта класса в самом объекте, т.к. только в нем появляются сами переменные `x`, `y`. До этого они не существуют, а значит, и не могут быть инициализированы.

Следующий важный факт, вытекающий из схемы жизни объекта, связан с использованием объектов одних классов внутри другого класса. Например, перед классом `Point` объявим еще один класс:

```c++
class Log {
public:
    Log() 
        { }
};
```

А в классе `Point` сделаем объявление объекта класса `Log`:

```c++
class Point {
    int x {-1};
    int y {-1};
    Log lg;
public:
    Point() : x(0), y(0)
        { }
    Point(int a, int b) : x(a), y(b)
        { }
...
};
```

Спрашивается, в каком порядке будут вызваны конструкторы этих классов? Схема жизни объекта дает нам однозначный ответ: сначала в блоке инициализации будет создан объект `lg` и, соответственно, вызовется конструктор класса `Log`, а затем, вызывается конструктор класса `Point`. То есть, конструктор класса `Point` вызывается только после формирования всех переменных и объектов, описанных в этом классе.

Мало того, если в классе `Log` не будет конструктора по умолчанию, например:

```c++
class Log {
    unsigned id {0};
    
public:
    Log(unsigned id_log) 
        { id = id_log; }
};
```

То при создании объектов класса `Point` возникнет ошибка невозможности формирования объекта `lg`. В этом случае нам нужно явно передать один аргумент при создании объекта `lg`. Сделать это можно либо непосредственно в классе:

```c++
class Point {
    int x {-1};
    int y {-1};
    Log lg {5};
...
};
```

Либо в списке инициализации соответствующих конструкторов:

```c++
class Point {
    int x {-1};
    int y {-1};
    Log lg;
 
public:
    Point() : x(0), y(0), lg(1)
        { }
    Point(int a, int b, unsigned id=1) : x(a), y(b), lg(id)
        { }
...
};
```

Так как список инициализации имеет более высокий приоритет, то в объекте переменная `lg` будет формироваться с передачей одного аргумента и вызова конструктора с одним параметром.

Соответственно, деструкторы вызываются в обратном порядке: сначала деструктор для объекта текущего класса, а затем, деструкторы объектов переменных. В конце происходит освобождение памяти, занимаемой объектом. Правда, не всегда этот процесс выполняется автоматически. Следует помнить, что если объект был создан с помощью оператора `new`:

```c++
Point* ptr_pt = new Point;
```

то в конце мы самостоятельно должны сделать освобождение:

```c++
delete ptr_pt;
```

Иначе, память останется выделенной, но, скорее всего, не используемой.

Вот такие этапы формирования и уничтожения объектов классов следует знать для их грамотного использования в программах.

---
[Содержание](#содержание)

## 1.7 Особенности работы конструкторов. Ключевые слова default и delete

[Смотреть материал на видео](https://www.youtube.com/watch?v=-zmUPiZShLU&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

### Особенности работы конструкторов

Рассмотрим следующий важный момент при работе с классами. Компилятор по умолчанию использует в классе свой набор следующих методов:

+ конструктор по умолчанию;
+ конструктор копирования;
+ операция присваивания копированием;
+ деструктор (в виде заглушки).

А, начиная со стандарта C++11, к ним добавилось еще два:

+ конструктор перемещения;
+ операция присваивания перемещением.

Конструктор перемещения и операцию присваивания перемещением мы с вами их оставим в стороне. Нас пока будет интересовать самый базовый набор методов по умолчанию.

Первый вопрос, почему они вообще существуют? Очевидно, что без них не возможно создание и работа с объектами классов или структур. Например, объявляя простой класс:

```c++
class Vector {
    int x {0};
    int y {0};
};
```

Мы сразу получаем базовый функционал:

```c++
int main() {
    Vector v1;      // конструктор по умолчанию
    Vector v2(v1);  // конструктор копирования
    Vector v3;
    v3 = v1;        // операция присваивания копированием
 
    return 0;
}
```

И все благодаря наличию у компилятора набора методов класса, используемых по умолчанию. Но мы уже знаем, что все эти методы могут быть замещены собственными, явно прописанными в классе. Причем, если в классе явно объявить любой конструктор (отличный от конструктора копирования), то конструктор по умолчанию перестает существовать. Например:

```c++
class Vector {
    int x {0};
    int y {0};
 
public:
    Vector(int a, int b): x(a), y(b)
        { }
};
```

Обратите внимание, что конструктор с двумя параметрами – это не конструктор по умолчанию. Тем не менее, компилятор более не станет использовать конструктор без параметров по умолчанию. Он, как бы, перестает существовать для класса `Vector`. А вот конструктор копирования и операция присваивания копирования при этом никуда не пропали.

Если же вместо конструктора с двумя параметрами объявить конструктор копирования:

```c++
class Vector {
    int x {0};
    int y {0};
 
public:
    Vector(const Vector& other) { 
        x = other.x;
        y = other.y;
    }
};
```

то будет замещен и конструктор копирования и конструктор по умолчанию (без параметров). Останется только стандартная операция присваивания копированием. В результате, объект класса `Vector` создать командой:

```c++
Vector v1;
```

станет невозможно. Однако поправить это достаточно просто. В классе `Vector` указать компилятору продолжать использовать свой собственный конструктор по умолчанию:

```c++
Vector() = default;
```

Здесь ключевое слово `default`, как раз и предписывает компилятору подставлять (при необходимости) вызов встроенного конструктора без параметров. Либо, как вариант, мы можем объявить свой собственный конструктор по умолчанию:

```c++
Vector() {};
```

В данном случае различий в работе класса никаких не будет.

Забегая вперед, отмечу, что операцию присваивания мы также можем переопределить (заменить) своей собственной. Сделать это можно следующим образом:

```c++
class Vector {
    int x {0};
    int y {0};
 
public:
    Vector() {};
    Vector(const Vector& other) { 
        x = other.x;
        y = other.y;
    }
 
    const Vector& operator=(const Vector& other) {
        if(this == &other) return *this;
 
        this->x = other.x;
        this->y = other.y;
        return *this;
    }
};
```

Переопределение операции присваивания никак не влияет на сокрытие встроенных (стандартных) конструкторов класса.

---
[Содержание](#содержание)

### Ключевое слово `delete`

При желании мы можем явно отказаться от использования в классе того или иного стандартного конструктора. Для этого, начиная со стандарта C++11, вводится ключевое слово `delete`, с помощью которого можно помечать определенный конструктор следующим образом:

```c++
class Vector {
    int x {0};
    int y {0};
 
public:
    Vector() = delete;
};
```

В этом случае, в классе `Vector` остается конструктор копирования, но отменяется конструктор по умолчанию. Соответственно, объекты этого класса не могут быть созданы стандартным образом:

```c++
Vector v1;  // ошибка, нет конструктора по умолчанию
```

Но, если пометить конструктор копирования, как удаленный:

```c++
class Vector {
    int x {0};
    int y {0};
 
public:
    Vector(const Vector& other) = delete;
};
```

то компилятор откажется от использования и конструктора копирования и конструктора по умолчанию. Выйти из этой ситуации можно следующим образом:

```c++
class Vector {
    int x {0};
    int y {0};
 
public:
    Vector() = default;
    Vector(const Vector& other) = delete;
};
```

Тогда будет использоваться стандартный конструктор по умолчанию, но отсутствовать конструктор копирования.

---
[Содержание](#содержание)

### Сокрытие конструкторов

Еще одним распространенным на практике способом управления созданием объектов является определение конструкторов в приватной секции. Например, если определить приватный конструктор копирования и публичный конструктор по умолчанию:

```c++
class Vector {
    int x {0};
    int y {0};
 
private:
    Vector(const Vector& other) = default;
public:
    Vector() = default;
};
```

то, очевидно, объекты класса можно совершенно спокойно создавать, но нельзя будет инициализировать другими подобными объектами.

Если оба конструктора сделать приватными:

```c++
class Vector {
    int x {0};
    int y {0};
 
private:
    Vector() = default;
    Vector(const Vector& other) = default;
};
```

то объекты этого класса можно будет создавать только внутри методов этого класса. Таким образом, используя секцию `private`, мы можем управлять возможностью создания и копирования объектов определенного класса. Эта возможность не редко применяется в практике программирования.

---
[Содержание](#содержание)

## 1.8 Описание методов вне класса

[Смотреть материал на видео](https://www.youtube.com/watch?v=LXEPyLDsew0&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

### Описание методов вне класса

Классы часто имеют тенденцию разрастаться по мере написания программы. Например, класс `PointND` на предыдущих занятиях приобретал такой вид:

```c++
class PointND {
    unsigned total{ 0 };
    int* coords{ nullptr };
public:
    PointND() : total(0), coords(nullptr)
    { }
    PointND(unsigned sz) : total(sz)
    {
        coords = new int[total] {0};
    }
    PointND(int* cr, unsigned len) : PointND(len)
    {
        set_coords(cr, len);
    }
    PointND(const PointND& other) : PointND(other.coords, other.total)
    { }
 
    const PointND& operator=(const PointND& other)
    {
        delete[] coords;
        total = other.total;
        coords = new int[total];
        set_coords(other.coords, total);
 
        return *this;
    }
 
    unsigned get_total() { return total; }
    const int* get_coords() { return coords; }
    void set_coords(int* cr, unsigned len)
    {
        for (unsigned i = 0; i < total; ++i)
            coords[i] = (i < len) ? cr[i] : 0;
    }
 
    ~PointND()
    {
        delete[] coords;
    }
};
```

И это еще относительно небольшой класс. Если он и дальше продолжит увеличиваться, то программисту станет сложно в нем ориентироваться: искать нужные методы, вносить правки и т.п. Но как можно упростить это описание? Если мы вспомним с вами о прототипах функций, которые рассматривали в базовом курсе языка Си, то аналогичный подход можно было бы применить и при объявлении класса. Давайте посмотрим, как это делается.

Вначале мы опишем класс, который будет содержать объявления переменных, прототипы методов и методы с очень короткими реализациями:

```c++
class PointND {
    unsigned total{ 0 };
    int* coords{ nullptr };
public:
    PointND() : total(0), coords(nullptr)
        { }
    PointND(unsigned sz) : total(sz)
        { coords = new int[total] {0}; }
    PointND(int* cr, unsigned len) : PointND(len)
        { set_coords(cr, len); }
    PointND(const PointND& other) : PointND(other.coords, other.total)
        { }
    const PointND& operator=(const PointND& other);
 
    ~PointND()
        { delete[] coords; }
 
    unsigned get_total() { return total; }
    const int* get_coords() { return coords; }
    void set_coords(int* cr, unsigned len);
};
```

Смотрите, здесь методы с большим количеством операторов представлены прототипами, остальные остались как есть непосредственно в классе. В результате текст программы стал гораздо понятнее и весь список методов буквально перед глазами программиста. Ориентироваться в таком классе куда проще.

Но где и как нам определить тела (реализации) для прототипов методов? Очевидно, это делается вне класса. Как мы с вами уже говорили, класс формирует свою область видимости и для доступа к ней нужно прописать имя класса и воспользоваться символом четвероточия (раскрытия области видимости):

```c++
[тип данных] <имя класса>::<элемент класса>
```

Первый прототип у нас – это оператор присваивания. За пределами класса к его описанию (прототипу) можно обратиться следующим образом:

```c++
const PointND& PointND::operator=(const PointND& other) {
        delete[] coords;
        total = other.total;
        coords = new int[total];
        set_coords(other.coords, total);
 
        return *this;
}
```

Обратите внимание, что сначала указывается возвращаемый тип, затем, обращение к прототипу оператора в области видимости класса `PointND` и только потом – тело метода. Таким образом, мы вынесли за пределы класса реализацию метода оператора присваивания.

По аналогии и со вторым прототипом `set_coords`:

```c++
void PointND::set_coords(int* cr, unsigned len) {
        for (unsigned i = 0; i < total; ++i)
            coords[i] = (i < len) ? cr[i] : 0;
}
```

В результате, мы получили точно такой же класс `PointND`, но с разнесенным его общим описанием и реализацией некоторых методов за пределами класса. Работать он будет абсолютно так же, как и прежде.

Обратите внимание, что формировать такое раздельное описание можно не только публичных методов, но вообще любых, например, приватных. Если метод `set_coords` в классе `PointND` поместить в секцию `private`:

```c++
class PointND {
...
private:
    void set_coords(int* cr, unsigned len);
};
```

То никаких проблем с определением тела этого прототипа за пределами класса не будет, так как компилятор «понимает», что здесь прописывается реализация метода, а не его вызов. А вот просто обратиться к приватному атрибуту `set_coords` уже не получится:

```c++
int main() {
    PointND pt(5);
    PointND::set_coords;   // ошибка
    PointND::get_coords;   // ok
   
    return 0;
}
```

Тогда, как с публичным атрибутом `get_coords` таких проблем не возникает. То есть, нужно различать описание метода и его вызов. Для компилятора – это принципиально разные вещи.

---
[Содержание](#содержание)

### Многомодульные программы

Конечно, в реальных проектах объявления классов, как правило, делается в отдельных заголовочных файлах, а затем по мере необходимости, подключаются к файлам реализации.

![01](/OOP_C_C++/img/01_03.jpg)

В нашем примере было бы логично вынести объявление класса `PointND` в отдельный файл с таким же именем `pointnd.h`, а затем, подключить его к двум cpp-файлам:

+ `course.cpp` – основная логика работы программы;
+ `pointnd.cpp` – файл с реализациями прототипов методов.

Содержимое файла `pointnd.h` можно определить следующим образом:

```c++
#ifndef _POINTND_H_
#define _POINTND_H_
 
class PointND {
    unsigned total{ 0 };
    int* coords{ nullptr };
public:
    PointND() : total(0), coords(nullptr)
        { }
    PointND(unsigned sz) : total(sz)
        { coords = new int[total] {0}; }
    PointND(int* cr, unsigned len) : PointND(len)
        { set_coords(cr, len); }
    PointND(const PointND& other) : PointND(other.coords, other.total)
        { }
    const PointND& operator=(const PointND& other);
 
    ~PointND()
        { delete[] coords; }
 
    unsigned get_total() { return total; }
    const int* get_coords() { return coords; }
    void set_coords(int* cr, unsigned len);
};
 
#endif
```

Обратите внимание на директивы условной компиляции. Они часто применяются в заголовочных файлах для защиты от повторного включения заголовка к одному и тому же cpp-файлу. Подробно мы с вами об этом говорили в базовом курсе языка Си.

Файл `course.cpp` определим как:

```c++
#include <iostream>
#include "pointnd.h"
 
int main() {
    int c[] = {1, 2, 3};
    PointND pt(c, 3);
    
    return 0;
}
```

А файл `pointnd.cpp` будет содержать реализации:

```c++
#include "pointnd.h"
 
const PointND& PointND::operator=(const PointND& other) {
        delete[] coords;
        total = other.total;
        coords = new int[total];
        set_coords(other.coords, total);
 
        return *this;
}
 
void PointND::set_coords(int* cr, unsigned len) {
        for (unsigned i = 0; i < total; ++i)
            coords[i] = (i < len) ? cr[i] : 0;
}
```

Все, у нас с вами получилась программа, состоящая из двух модулей и одного заголовочного файла `pointnd.h`.

Но, давайте, детальнее посмотрим, как будет подключаться класс в каждый из этих модулей. В классе `PointND` есть определение методов вместе с их реализациями. Так как тела методов достаточно просты, то часто компилятор превращает их в `inline`-методы, то есть, они не вызываются подобно функциям, а их реализации буквально вставляются в места их вызова. Но, если какой-либо метод компилятор воспринимает на уровне обычной функции и реализация этого метода прописана в классе, то тело такого метода будет продублировано в каждом модуле программы, где есть подключение заголовка с этим классом. Конечно, это приведет к увеличению размера самой программы, хотя других последствий быть не должно. Программа в целом будет работать корректно. Поэтому большие реализации все же лучше выносить за пределы класса и объявлять их в отдельном модуле. В нашем примере – это модуль `pointnd.cpp`.

---
[Содержание](#содержание)

## 1.9 Статические поля и методы класса

[Смотреть материал на видео](https://www.youtube.com/watch?v=kI2ZWnO4PcM&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

### Статические поля

На этом занятии мы с вами увидим, как определяются и для чего предназначены статические поля и методы класса. Начнем со статических полей.

Ранее мы с вами в курсе по Си рассматривали статические переменные и отмечали, что они создаются (размещаются в памяти) один раз и существуют на всем протяжении работы программы. Напомню, что статические переменные можно объявить либо в теле функции, тогда перед ее типом нужно прописать ключевое слово `static`, либо как глобальную, тогда переменная автоматически становится статической:

```c++
#include <iostream>
 
void show_static() {
    static int counter = 0;
    std::cout << counter++ << std::endl;
}
 
int global_counter = 0; // глобальная и статическая переменная
 
int main() {
    show_static();
    show_static();
    show_static();
 
    return 0;
}
```

Аналогичные объявления переменных можно делать и в классе. Например, так:

```c++
class Point {
    static unsigned counter;
    int x, y;
public:
    Point() : x(0), y(0)
        { }
};
 
int main() {
    Point pt1, pt2;
 
    return 0;
}
```

Как правильно в классе `Point` воспринимать строчку:

```c++
static unsigned counter;
```

В действительности, это лишь объявление статической переменной. Сама переменная `counter` при этом не создается. Так же, как и обычные переменные `x` и `y`. То есть, класс по-прежнему описывает лишь тип данных, шаблон, по которому следует конструировать его объекты. И в функции `main` два таких объекта создаются: `pt1` и `pt2`. Какие в итоге данные (переменные) будут содержать эти объекты? На самом деле только переменные `x` и `y`. Статические поля объектам класса не принадлежат. И это логично, так как статическая переменная может быть только в единственном экземпляре: она создается в момент ее инициализации и пропадает при завершении программы. По сути, объявление

```c
static unsigned counter;
```

аналогично объявлению глобальной переменной с ключевым словом `extern`:

```c++
extern int global_counter;
```

Это объявление не создает саму переменную, но указывает компилятору на ее возможное наличие в этом или другом модуле программы. Поэтому если в программе попытаться вывести значение переменной `counter` (сделав ее предварительно публичной):

```c++
int main() {
    Point pt1, pt2;
    std::cout << pt1.counter;
 
    return 0;
}
```

то получим ошибку:

```c++
undefined reference to `Point::counter'
```

Как же создать статическую переменную? Для этого ее нужно проинициализировать каким-либо значением. И делается это, как правило, за пределами описания класса следующим образом:

```c++
unsigned Point::counter = 0;
```

В результате статическая переменная `counter` будет создана (размещена в памяти) и находиться в области видимости класса `Point`. И эта переменная будет существовать совершенно независимо от объектов класса `Point`. Условно это можно изобразить следующей схемой:

![01](/OOP_C_C++/img/01_04.jpg)

То есть, доступ к переменной `counter` возможен, как напрямую:

```c++
Point::counter = 100;
```

так и через объекты класса:

```c++
std::cout << pt1.counter << std::endl;
std::cout << pt2.counter << std::endl;
```

---
[Содержание](#содержание)

### Статические методы

Помимо статических полей в классе можно объявлять и статические методы. Делается это по аналогии: перед типом статического метода прописывается ключевое слово `static`, например, так:

```c++
class Point {
    static unsigned counter;
    int x, y;
 
public:
    Point() : x(0), y(0)
        { }
    void get_coords(int& a, int& b)
        {a = x; b = y;}
    static unsigned get_counter()
        { return counter; }
};
 
unsigned Point::counter = 0;
```

Обратите внимание, что, несмотря на то, что поле `counter` было помещено в секцию `private`, его инициализация за пределами этого класса вполне допустима, т.к. здесь происходит объявление статической переменной, а не обращение к ней.

В чем отличие статического метода `get_counter` от обычного метода, например, `get_coords`? По сути, только одно. Статический метод – это обычная функция, объявленная в области видимости класса. Ее вызов не связан с конкретным объектом этого класса, а потому статический метод не имеет непосредственного доступа к переменным `x`, `y`, которые размещаются в объектах. По этой же причине в статический метод компилятор не передает неявный указатель `this`, так как вызов метода не связан ни с каким объектом. Именно поэтому метод (функцию) `get_counter` можно вызывать напрямую, указав область видимости класса:

```c++
std::cout << Point::get_counter() << std::endl;
```

Хотя, никто не запрещает вызывать этот же статический метод и через объекты класса:

```c++
std::cout << pt1.get_counter() << std::endl;
```

Но, по сути, это будет эквивалентный вызов напрямую через класс.

И здесь у вас вполне может возникнуть вопрос, зачем вообще нужны эти статические поля и методы в классе?

Для ответа на него в следующем занятии мы с вами разберем реализацию известного паттерна `Singleton` (синглтон), который, как раз, использует статические поля.

---
[Содержание](#содержание)

## 1.10 Паттерн Singleton (синглтон)

[Смотреть материал на видео](https://www.youtube.com/watch?v=AXh8dVqjAz0&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

На этом занятии мы с вами рассмотрим пример использования статических переменных и методов класса для реализации известного паттерна `Singleton` (синглтон).

Смысл этого паттерна прост. Объявляется класс, так, чтобы от него мог существовать ровно один объект в один момент времени. Сделаем это следующим образом. Объявим класс, который пусть так и называется – `Singleton`. И в этом классе разместим статическое поле – указатель на возможный объект этого класса, а также некие целочисленные данные:

```c++
class Singleton {
    int data {0};
    static Singleton* instance_ptr;
};
```

Изначально значение статического поля (переменной) `instance_ptr` установим в значение `nullptr`:

```c++
Singleton* Singleton::instance_ptr = nullptr;
```

Это будет означать, что класс не имеет ни одного объекта.

Я, думаю, вы понимаете, почему мы указатель `instance_ptr` на объект определили статическим? Да, он не должен относиться к самим объектам класса (лишь ссылаться на один, при его наличии) и быть определенным в области видимости класса, так как непосредственно связан с логикой паттерна `Singleton`. Кроме того, статическое поле задается сразу в момент выполнения программы (до формирования каких-либо объектов класса) и в нашем случае принимает начальное значение `nullptr`.

Далее, мы запретим создание объектов класса напрямую, поэтому разместим конструктор по умолчанию в приватной секции. Также запретим создание копий объектов, поэтому удалим встроенный конструктор копирования. Наконец, объявим свой деструктор класса, в котором статическое поле `instance_ptr` снова установим в значение `nullptr` для возможности создания нового объекта в случае удаления прежнего. В итоге, класс `Singleton` примет вид:

```c++
class Singleton {
    int data {0};
    static Singleton* instance_ptr;
 
    Singleton()
        { }
public:
    Singleton(const Singleton& ) = delete;
    ~Singleton() { instance_ptr = nullptr; }
};
```

Хорошо, но спрашивается, как мы будем создавать объект этого класса, если единственный доступный конструктор находится в секции `private`? Очень просто! Мы объявим в классе `Singleton` специальный статический метод для создания единственного объекта. Назовем этот метод `get_instance` и определим его следующим образом:

```c++
    static Singleton* get_instance() {
        if (instance_ptr == nullptr) {
            instance_ptr = new Singleton();
        }
        
        return instance_ptr;
    }
```

Работа его вполне очевидна. Если статическое поле `instance_ptr` равно `nullptr`, значит, ни одного объекта класса не существует, и он создается. В конце возвращается указатель `instance_ptr`.

Почему этот метод мы сделали статическим? Очевидно, чтобы можно было его вызывать напрямую из класса, не имея ни одного объекта, следующим образом:

```c++
int main() {
    Singleton* ptr = Singleton::get_instance();
 
    std::cout << ptr << std::endl;
 
    delete ptr;
 
    return 0;
}
```

В теле метода `get_instance` осуществляется обращение к приватному статическому полю `instance_ptr` и при необходимости создается ровно один объект класса.

Если мы попробуем создать еще один объект:

```c++
Singleton* ptr2 = Singleton::get_instance();
```

то указатель `ptr2` будет ссылаться на тот же самый объект, второго создано не будет.

Ну и в конце описания класса объявим в нем еще два метода для работы с приватной переменной `data`:

```c++
    void set_data(int d) {data = d;}
    int get_data() { return data; }
```

В итоге у нас с вами получился следующий класс, реализующий паттерн синглтон:

```c++
class Singleton {
    int data {0};
    static Singleton* instance_ptr;
 
    Singleton()
        { }
public:
    Singleton(const Singleton& ) = delete;
    ~Singleton() { instance_ptr = nullptr; }
 
    static Singleton* get_instance() {
        if (instance_ptr == nullptr) {
            instance_ptr = new Singleton();
        }
        
        return instance_ptr;
    }
 
    void set_data(int d) {data = d;}
    int get_data() { return data; }
};
 
Singleton* Singleton::instance_ptr = nullptr;
```

А использовать его можно, например, так:

```c++
int main() {
    Singleton* ptr = Singleton::get_instance();
    ptr->set_data(1);
    Singleton* ptr2 = Singleton::get_instance();
 
    std::cout << ptr << " " << ptr2 << std::endl;
    std::cout << ptr2->get_data() << std::endl;
 
    delete ptr;
    return 0;
}
```

Видим, что оба указателя содержат одинаковый адрес, и метод `get_data` возвращает ранее записанное значение 1.

Вот так, достаточно просто, можно на C++ реализовать паттерн `Singleton`, используя статические поля и методы, а также правильно настраивая все его конструкторы.

---
[Содержание](#содержание)

## 1.11 Константные методы. Ключевое слово mutable

[Смотреть материал на видео](https://www.youtube.com/watch?v=f4lcUQ7342M&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

### Константные методы

На этом занятии познакомимся с константными методами класса и посмотрим, как они определяются и для чего они нужны.

Пусть у нас имеется следующий класс:

```c++
class Point {
    int x {0}, y{0};
 
public:
    Point(int a = 0, int b = 0) : x(a), y(b)
        { }
 
    void set_coords(const Point& p) {
        x = p.x; y = p.y;
    }
 
    void get_coords(int& x, int& y) 
        { x = this->x; y = this->y; }
};
```

Использовать его можно следующим образом:

```c++
int main() {
    Point pt, pt2(1, 2);
 
    pt.set_coords(pt2);
 
    int x, y;
    pt.get_coords(x, y);
    std::cout << x << " " << y << std::endl;
 
    return 0;
}
```

Здесь метод `set_coords` принимает константную ссылку на объект класса `Point` и задает значения координат текущего объекта. Так как параметр метода имеет модификатор `const`, то это сигнализирует программисту, что переданный объект никак меняться в методе `set_coords` не будет. И, действительно, компилятор отслеживает все эти моменты. Например, если попытаться занести в переменные `x`, `y` переданного объекта какие-либо значения:

```c++
    void set_coords(const Point& p) {
        x = p.x; y = p.y;
        p.x = 1;
        p.y = 2;
    }
```

то возникнет ошибка на этапе компиляции программы. Из-за того, что параметр `p` является константным, значение его полей можно только читать, но не менять. Однако, в отличие от обычных примитивных типов данных, объекты класса можно менять и через вызовы его методов. Например, так:

```c++
    void set_coords(const Point& p) 
    {
        x = p.x; y = p.y;
        p.set_coords(Point(10, 20));
    }
```

И здесь компилятор предусмотрительно запретит такой вызов из-за константного объекта. Но он также запретит и вполне безобидный вызов метода для получения координат:

```c++
    void set_coords(const Point& p) {
        x = p.x; y = p.y;
        p.get_coords(x, y);
    }
```

Мы знаем, что метод `get_coords` не меняет состояния объекта, а значит, вполне мог бы быть вызван через константный объект. Как сообщить компилятору, что этот или какой-либо другой метод можно вызывать для константного объекта? Для этого Бьерн Стауструп предложил такие методы помечать особым образом: записывать после их объявления ключевое слово `const` следующим образом:

```c++
    void get_coords(int& x, int& y) const 
        { x = this->x; y = this->y; }
```

Такие методы получили название константных и могут вызываться константными объектами класса. Обратите внимание, что ключевое слово `const` записано после прототипа функции, но до ее тела. Именно так следует определять константные методы. Теперь программа успешно компилируется с вызовом метода `get_coords`.

Также не следует путать запись ключевого слова `const` в начале метода, с таким же словом `const` в конце прототипа, например:

```c++
    const int get_x() const
        { return x; }
```

Первое слово `const` относится к возвращаемому типу `int` и означает, что метод `get_x` возвращает координату в виде целочисленной константы. А второе слово `const`, как раз определяет константный метод, который можно впоследствии вызывать через константные объекты класса `Point`. Эти два определения нужно четко различать.

Вообще в практике программирования рекомендуется все методы, которые не меняют состояние объектов класса, помечать, как константные. Тогда программист, пользователь класса, сможет в полной мере, свободно и корректно использовать его в своем проекте.

Также, обратите внимание, что константные методы могут, в свою очередь, вызывать только другие константные методы. Например, следующий код будет корректен:

```c++
class Point {
    int x {0}, y{0};
 
public:
    Point(int a = 0, int b = 0) : x(a), y(b)
        { }
 
    void set_coords(const Point& p) 
    {
        p.get_coords(x, y);
    }
 
    const int get_x() const
        { return x; }
 
    const int get_y() const
        { return y; }
 
    void get_coords(int& x, int& y) const 
        { x = get_x(); y = get_y(); }
};
```

Но, если хотя бы один из методов `get_x` или `get_y` не будет константным, то компилятор сообщит об этом ошибкой на этапе компиляции программы.

Следующая особенность константных методов. Если они возвращают указатель или ссылку на переменную, то нужно такие типы предварять ключевым словом `const`:

```c++
    const int& get_x() const
        { return x; }
 
    const int* get_y() const
        { return &y; }
 
    void get_coords(int& x, int& y) const 
        { x = get_x(); y = *get_y(); }
```

И понятно, почему. Если бы была возвращена обычная ссылка или указатель:

```c++
    int& get_x() const
        { return x; }
 
    int* get_y() const
        { return &y; }
```

то через них можно было бы менять значение полей объекта, что недопустимо при вызове константных методов. Но, если возвращается копия объекта:

```c++
    int get_x() const
        { return x; }
 
    int get_y() const
        { return y; }
```

то ключевое слово `const` можно не использовать, т.к. через копию данных нельзя изменить состояние объекта.

---
[Содержание](#содержание)

### Ключевое слово `mutable`

В очень редких случаях, которые следует избегать на практике, некоторые переменные объекта можно помечать специальным ключевым словом `mutable`, позволяющее изменять переменную константного объекта. Это делается следующим образом:

```c++
class Point {
    int x {0}, y{0};
 
public:
    mutable int count_call {0}; // число вызовов различных методов текущего объекта
 
    Point(int a = 0, int b = 0) : x(a), y(b)
        { }
 
    void set_coords(const Point& p) 
    {
        count_call++;
        p.get_coords(x, y);
    }
 
    int get_x() const
        { count_call++; return x; }
 
    int get_y() const
        { count_call++; return y; }
 
    void get_coords(int& x, int& y) const 
        { count_call++; x = get_x(); y = get_y(); }
};
```

Здесь переменная `count_call` помечена ключевым словом `mutable` и, соответственно, может совершенно спокойно изменяться во всех методах класса `Point`, включая константные. Если убрать слово `mutable`, то компилятор выдаст ошибку об изменении переменной в константных методах.

Однако, как я уже говорил, это не рекомендуемая практика, которую следует избегать. Использование подобных переменных нарушает принцип неизменности состояния константного объекта и может легко привести к непредвиденным последствиям.

---
[Содержание](#содержание)
